{"/home/travis/build/npmtest/node-npmtest-stormpath/test.js":"/* istanbul instrument in package npmtest_stormpath */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stormpath/lib.npmtest_stormpath.js":"/* istanbul instrument in package npmtest_stormpath */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_stormpath = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_stormpath = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-stormpath/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-stormpath && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_stormpath */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_stormpath\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_stormpath.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_stormpath.rollup.js'] =\n            local.assetsDict['/assets.npmtest_stormpath.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_stormpath.__dirname + '/lib.npmtest_stormpath.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/stormpath.js":"'use strict';\n\nvar passwordGrant = require('./oauth/password-grant');\nvar refreshGrant = require('./oauth/refresh-grant');\nvar idSiteGrant = require('./oauth/id-site-grant');\nvar stormpathToken = require('./oauth/stormpath-token');\nvar clientCredentialsGrant = require('./oauth/client-credentials');\nvar stormpathSocial = require('./oauth/stormpath-social');\n\nmodule.exports = {\n  ApiKey: require('./authc/ApiKey'),\n  loadApiKey: require('./authc/ApiKeyLoader'),\n  configLoader: require('./configLoader'),\n  Client: require('./Client'),\n  Tenant: require('./resource/Tenant'),\n  OAuthPasswordGrantRequestAuthenticator: passwordGrant.authenticator,\n  OauthPasswordGrantAuthenticationResult: passwordGrant.authenticationResult,\n  OAuthRefreshTokenGrantRequestAuthenticator: refreshGrant.authenticator,\n  OAuthIdSiteTokenGrantAuthenticator: idSiteGrant.authenticator,\n  OAuthIdSiteTokenGrantAuthenticationResult: idSiteGrant.authenticationResult,\n  OAuthStormpathTokenAuthenticator: stormpathToken.authenticator,\n  OAuthStormpathSocialAuthenticator: stormpathSocial.authenticator,\n  OAuthStormpathTokenAuthenticationResult: stormpathToken.authenticationResult,\n  OAuthClientCredentialsAuthenticator: clientCredentialsGrant.authenticator,\n  OAuthClientCredentialsAuthenticationResult: clientCredentialsGrant.authenticationResult,\n  SamlIdpUrlBuilder: require('./saml/SamlIdpUrlBuilder'),\n  AssertionAuthenticationResult: require('./authc/AssertionAuthenticationResult'),\n  StormpathAccessTokenAuthenticator: require('./oauth/stormpath-access-token-authenticator'),\n  StormpathAssertionAuthenticator: require('./authc/StormpathAssertionAuthenticator'),\n  JwtAuthenticator: require('./jwt/jwt-authenticator'),\n  OAuthAuthenticator: require('./oauth/authenticator')\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/password-grant.js":"'use strict';\n\nvar util = require('../utils');\nvar JwtAuthenticationResult = require('../jwt/jwt-authentication-result');\nvar ScopeFactoryAuthenticator = require('./scope-factory-authenticator');\n\n/**\n * @class\n *\n * @augments {JwtAuthenticationResult}\n *\n * @description\n *\n * Encapsulates the access token response from an application's `/oauth/token`\n * endpoint, when making a `password` grant request. This class allows you to\n * access the response data and get the account that was authenticated.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link OAuthPasswordGrantRequestAuthenticator#authenticate OAuthPasswordGrantRequestAuthenticator.authenticate()}.\n *\n * @param {Application} application\n * The Stormpath Application that issued the tokens.\n *\n * @param {AccessTokenResponse} accessTokenResponse\n * The access token response from the Stormpath REST API.\n *\n */\nfunction OAuthPasswordGrantAuthenticationResult(application,accessTokenResponse){\n  if (!(this instanceof OAuthPasswordGrantAuthenticationResult)) {\n    return new OAuthPasswordGrantAuthenticationResult(application,accessTokenResponse);\n  }\n\n  OAuthPasswordGrantAuthenticationResult.super_.apply(this, arguments);\n\n  /**\n   * The access token response from the Stormpath REST API.\n   *\n   * @name OAuthPasswordGrantAuthenticationResult#accessTokenResponse\n   *\n   * @type {AccessTokenResponse}\n   */\n  this.accessTokenResponse = accessTokenResponse;\n}\n\nutil.inherits(OAuthPasswordGrantAuthenticationResult, JwtAuthenticationResult);\n\n/**\n * @class\n *\n * @augments ScopeFactoryAuthenticator\n *\n * @description\n *\n * Creates an authenticator that can be used to exchange a username and password\n * for an access token and refresh token pair.  To configure the access and refresh token\n * expiration times for the application, see {@link OAuthPolicy}. The authenticator is bound to a\n * Stormpath Application, so the authentication attempt will be bound to the\n * account stores that are mapped to this application.\n *\n * @param {Application} application The Stormpath Application to authenticate against.\n *\n * @example\n * var appHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * client.getApplication(appHref, function(err, application) {\n *   var authenticator = new stormpath.OAuthPasswordGrantRequestAuthenticator(application);\n * });\n */\nfunction OAuthPasswordGrantRequestAuthenticator(application) {\n  if (!(this instanceof OAuthPasswordGrantRequestAuthenticator)) {\n    return new OAuthPasswordGrantRequestAuthenticator(application);\n  }\n\n  OAuthPasswordGrantRequestAuthenticator.super_.apply(this, arguments);\n\n  this.application = application;\n}\n\nutil.inherits(OAuthPasswordGrantRequestAuthenticator, ScopeFactoryAuthenticator);\n\n/**\n * @function\n *\n * @param {Object} passwordGrantRequest\n * An object with the password grant request properties.\n *\n * @param {String} passwordGrantRequest.username\n * The username or email address of the account that is attempting to authenticate.\n *\n * @param {String} passwordGrantRequest.password\n * The password of the account that is attempting to authenticate.\n *\n * @param {String} [passwordGrantRequest.scope]\n * User-requested scope that will be passed to the scope factory, if configured.\n * See {@link ScopeFactoryAuthenticator} for more details.\n *\n * @param {String} [passwordGrantRequest.accountStore]\n * The HREF of an account store to target during the authentication attempt.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link OAuthPasswordGrantAuthenticationResult}).\n *\n * @example\n *\n * var passwordGrantRequest = {\n *   username: 'foo@example.com',\n *   password: 'p@ssword!1'\n * };\n *\n * authenticator.authenticate(passwordGrantRequest, function(err, oAuthPasswordGrantAuthenticationResult) {\n *   oAuthPasswordGrantAuthenticationResult.getAccount(function(err, account){\n *     console.log(\n *      'The access token for ' + account.email + ' is: ' +\n *      oAuthPasswordGrantAuthenticationResult.accessTokenResponse.access_token\n *     );\n *   });\n * });\n *\n */\nOAuthPasswordGrantRequestAuthenticator.prototype.authenticate = function authenticate(formData, callback) {\n  var application = this.application;\n  var self = this;\n\n  if(arguments.length !==2 ){\n    throw new Error('Must call authenticate with (data,callback)');\n  }else{\n    var href = application.href + '/oauth/token';\n    formData.grant_type='password';\n\n    var form = util.extend({}, formData);\n\n    // No need to send the scope to the API\n    if (form.scope) {\n      delete form.scope;\n    }\n\n    application.dataStore.createResource(href, {form: form}, function(err, data) {\n      if(err){\n        return callback(err);\n      }\n\n      self.scopeAuthResult(application, formData, data, OAuthPasswordGrantAuthenticationResult, callback);\n    });\n  }\n};\n\nmodule.exports = {\n  authenticator: OAuthPasswordGrantRequestAuthenticator,\n  authenticationResult: OAuthPasswordGrantAuthenticationResult\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/utils.js":"'use strict';\n\nvar cryptoLib = require('crypto');\n/* jshint -W079 */\nvar Buffer = require('buffer').Buffer;\n/* jshint +W079 */\nvar util = require('util');\n\nvar stormpathConfig = require('stormpath-config');\nvar uuid = require('uuid');\nvar url = require('url');\n\nfunction shallowCopy(src, dest) {\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key)) {\n      dest[key] = src[key];\n    }\n  }\n\n  return dest;\n}\n\nfunction isConfigLoader(value) {\n  if (value instanceof stormpathConfig.Loader) {\n    return true;\n  }\n\n  if (value && value.constructor && value.constructor.name === 'ConfigLoader') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction take(source, fromRight) {\n  return fromRight ? source.pop() : source.shift();\n}\n\n/**\n * @private\n *\n * @description\n *\n * Takes a list of arguments and maps them to a list of names\n * in an alternating either a left-to-right, or right-to-left direction.\n */\nfunction resolveArgs(argumentsObject, nameMap, rightToLeft) {\n  var result = {};\n\n  var takeFromRight = rightToLeft;\n  var args = Array.prototype.slice.call(argumentsObject);\n\n  while (nameMap.length) {\n    var value = null;\n    var name = take(nameMap, takeFromRight);\n\n    if (args.length > 0) {\n      value = take(args, takeFromRight);\n      takeFromRight = !takeFromRight;\n    }\n\n    result[name] = value;\n  }\n\n  return result;\n}\n\n/**\n * @private\n *\n * @description\n *\n * Ensures 'undefined' is never encountered on value assignment. Works as follows:\n * 1. Return obj if not null or undefined.\n * 2. Then return defaultVal if not null or undefined.\n * 3. Return null as last resort.\n *\n * @example\n * function(someVal) {\n *   var possiblyNullButNeverUndefined = util.valueOf(someVal.foo);\n * }\n *\n * @example\n * function(someVal) {\n *   var fooOrDefaultValueIfFooDoesNotExist = util.valueOf(someVal.foo, 'DefaultVavlue');\n * }\n *\n * @param {*} obj\n * @param {*} [defaultVal]\n * @returns {*}\n */\nfunction valueOf(obj, defaultVal) {\n  if (obj) {\n    return obj;\n  }\n  if (defaultVal) {\n    return defaultVal;\n  }\n  return null;\n}\n\n\n/**\n * @private\n *\n * @description\n *\n * Returns `true` if the first constructor function is equal to, or a super of,\n * the second constructor function.\n *\n * @param {Function} ctor the constructor function that might be equal to or a super of 'toTest'.\n * @param {Object} toTest the constructor function to test\n */\nfunction isAssignableFrom(ctor, toTest) {\n\n  if (!(ctor instanceof Function) || !(toTest instanceof Function)) {\n    throw new Error('arguments must be Functions.');\n  }\n\n  if (ctor === Object || ctor === toTest) {\n    return true;\n  }\n\n  if (toTest.super_) {\n    return isAssignableFrom(ctor, toTest.super_);\n  }\n\n  return false;\n}\n\nvar base64 = {\n  encode: function encode64(string) {\n    return new Buffer(string).toString('base64');\n  },\n  decode: function decode64(string) {\n    return new Buffer(string, 'base64').toString();\n  },\n  urlEncode: function urlEncode(string) {\n    return new Buffer(string).toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n  },\n  urlDecode: function urlDecode(base64) {\n    base64 += new Array(5 - base64.length % 4).join('=');\n    base64 = base64.replace(/\\-/g, '+').replace(/\\_/g, '/');\n    return new Buffer(base64, 'base64');\n  }\n};\n\nvar crypto = {\n  hmac: function hmac(key, string, digest, fn) {\n    if (!digest) {\n      digest = 'binary';\n    }\n    if (digest === 'buffer') {\n      digest = undefined;\n    }\n    if (!fn) {\n      fn = 'sha256';\n    }\n    if (typeof string === 'string') {\n      string = new Buffer(string);\n    }\n    return cryptoLib.createHmac(fn, key).update(string).digest(digest);\n  },\n\n  sha256: function sha256(string, digest) {\n    if (!digest) {\n      digest = 'binary';\n    }\n    if (digest === 'buffer') {\n      digest = undefined;\n    }\n    if (typeof string === 'string') {\n      string = new Buffer(string);\n    }\n    return cryptoLib.createHash('sha256').update(string).digest(digest);\n  },\n\n  toHex: function toHex(data) {\n    var out = [];\n    for (var i = 0; i < data.length; i++) {\n      out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));\n    }\n    return out.join('');\n  }\n};\n\nfunction isCollectionData(data) {\n  return data &&\n    data.hasOwnProperty('items') &&\n    data.hasOwnProperty('offset') &&\n    data.hasOwnProperty('limit');\n}\n\nfunction nowEpochSeconds() {\n  return Math.round(new Date().getTime()/1000);\n}\n\nvar numberRegExp = new RegExp(/[0-9]+/);\n\nfunction isNumber(val) {\n  return (typeof val === 'number') && numberRegExp.test(val, 10);\n}\n\nfunction applyMixin(Ctor, mixin) {\n  Object.keys(mixin).forEach(function(key) {\n    if (mixin.hasOwnProperty(key)) {\n      Ctor.prototype[key] = mixin[key];\n    }\n  });\n}\n\nfunction isValidHref(href, subPath) {\n  var path;\n\n  if (typeof href !== 'string') {\n    return false;\n  }\n\n  if (href.indexOf('/') === 0) {\n    path = href;\n  } else {\n    var parsedUrl;\n\n    try {\n      parsedUrl = url.parse(href);\n    } catch (err) {\n      return false;\n    }\n\n    if (!parsedUrl.protocol || !parsedUrl.host || !parsedUrl.path) {\n      return false;\n    }\n\n    if (parsedUrl.protocol.indexOf('http') !== 0) {\n      return false;\n    }\n\n    path = parsedUrl.path;\n  }\n\n  if (subPath && path.indexOf(subPath) === -1) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction extend(/* target, src1, src2, ... */) {\n  var target = arguments[0];\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function(source) {\n    if (!source) {\n      return;\n    }\n\n    Object.keys(source).forEach(function(key) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    });\n  });\n\n  return target;\n}\n\nmodule.exports = {\n  isConfigLoader: isConfigLoader,\n  resolveArgs: resolveArgs,\n  nowEpochSeconds: nowEpochSeconds,\n  inherits: util.inherits,\n  isAssignableFrom: isAssignableFrom,\n  isCollectionData: isCollectionData,\n  isValidHref: isValidHref,\n  shallowCopy: shallowCopy,\n  valueOf: valueOf,\n  isNumber: isNumber,\n  base64: base64,\n  crypto: crypto,\n  uuid: uuid,\n  applyMixin: applyMixin,\n  extend: extend,\n  noop: function () {}\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/index.js":"'use strict';\n\nmodule.exports = {\n  strategy: require('./lib/strategy'),\n  Config: require('./lib/Config'),\n  Loader: require('./lib/ConfigLoader')\n};","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/index.js":"module.exports = {\n  NullConfigStrategy: require('./NullConfigStrategy'),\n  DebugConfigStrategy: require('./DebugConfigStrategy'),\n  ExtendConfigStrategy: require('./ExtendConfigStrategy'),\n  LoadEnvConfigStrategy: require('./LoadEnvConfigStrategy'),\n  LoadFileConfigStrategy: require('./LoadFileConfigStrategy'),\n  LoadAPIKeyConfigStrategy: require('./LoadAPIKeyConfigStrategy'),\n  LoadAPIKeyFromConfigStrategy: require('./LoadAPIKeyFromConfigStrategy'),\n  EnrichClientConfigStrategy: require('./EnrichClientConfigStrategy'),\n  EnrichClientFromRemoteConfigStrategy: require('./EnrichClientFromRemoteConfigStrategy'),\n  EnrichIntegrationConfigStrategy: require('./EnrichIntegrationConfigStrategy'),\n  EnrichIntegrationFromRemoteConfigStrategy: require('./EnrichIntegrationFromRemoteConfigStrategy'),\n  ValidateClientConfigStrategy: require('./ValidateClientConfigStrategy')\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/NullConfigStrategy.js":"'use strict';\n\n/**\n * Represents a strategy that that returns an empty object (pre loading).\n *\n * @class\n */\nfunction NullConfigStrategy (nullObject) {\n  this.nullObject = nullObject;\n}\n\nNullConfigStrategy.prototype.process = function (callback) {\n  callback(null, this.nullObject);\n};\n\nmodule.exports = NullConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/DebugConfigStrategy.js":"'use strict';\n\n/**\n * Represents a strategy that when used dumps\n * the config to the provided logger.\n *\n * @class\n */\nfunction DebugConfigStrategy(logger, section) {\n  this.logger = logger;\n  this.section = section;\n}\n\nDebugConfigStrategy.prototype.process = function (config, callback) {\n  var friendlyFormat = JSON.stringify(config, null, 4);\n  this.logger.debug(this.section + ':\\n' + friendlyFormat + '\\n');\n  callback(null, config);\n};\n\nmodule.exports = DebugConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/ExtendConfigStrategy.js":"'use strict';\n\nvar extend = require('../helpers/clone-extend').extend;\n\n/**\n * Represents a strategy that extends the configuration.\n *\n * @class\n */\nfunction ExtendConfigStrategy (extendWith) {\n  this.extendWith = extendWith;\n}\n\nExtendConfigStrategy.prototype.process = function (config, callback) {\n  extend(config, this.extendWith);\n\n  // TODO: FIX HACK! Resolve this in a more generic/re-usable way, perhaps\n  // using a different object extension library.\n  if (this.extendWith) {\n    var extendWith = this.extendWith;\n\n    if(extendWith.cacheOptions && extendWith.cacheOptions.client){\n      config.cacheOptions.client = extendWith.cacheOptions.client;\n    }\n\n    if(extendWith.requestExecutor){\n      config.requestExecutor = extendWith.requestExecutor;\n    }\n\n    // TODO: HACK! Fix issue with extend library extending arrays\n    // instead of overwriting them.\n    if (extendWith.web) {\n      var web = extendWith.web;\n\n      if (web.produces) {\n        config.web.produces = web.produces;\n      }\n\n      if (web.login && web.login.form && web.login.form.fieldOrder) {\n        config.web.login.form.fieldOrder = web.login.form.fieldOrder;\n      }\n\n      if (web.register && web.register.form && web.register.form.fieldOrder) {\n        config.web.register.form.fieldOrder = web.register.form.fieldOrder;\n      }\n    }\n  }\n\n  callback(null, config);\n};\n\nmodule.exports = ExtendConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/helpers/clone-extend.js":"/**\n * The contents of this file have been taken from:\n *\n * https://raw.githubusercontent.com/shimondoodkin/nodejs-clone-extend/47c1cb4c7fafcc51560d53bdc6a938e5f6e82bef/index.js\n */\nvar hop = Object.prototype.hasOwnProperty;\nfunction replace(a, b)\n{\n if (!b)\n {\n  return a;\n }\n var key;\n for (key in b)\n {\n  if(hop.call(b, key))\n  {\n   a[key] = b[key];\n  }\n }\n\n return a;\n} exports.replace=replace;\n\nfunction add(a, b)\n{\n if (!b)\n {\n  return a;\n }\n var key;\n for (key in b)\n {\n  if(hop.call(b,key))\n  {\n   if(typeof a[key] === 'undefined' ||  a[key]===null)\n   {\n    a[key] = b[key];\n   }\n  }\n }\n return a;\n} exports.add=add;\n\n\nfunction extend(a, b, context, newobjs, aparent, aname, haveaparent) // context is anti circular references mechanism\n{\n if (a==b){ return a;}\n if (!b)  { return a;}\n\n var key, clean_context=false, return_sublevel=false,b_pos;\n if(!haveaparent){ aparent={'a':a}; aname='a'; }\n if(!context){clean_context=true;context=[];newobjs=[];}\n b_pos=context.indexOf(b);\n if( b_pos==-1 ) {context.push(b);newobjs.push([aparent, aname]);} else { return newobjs[b_pos][0][ newobjs[b_pos][1] ]; }\n\n for (key in b)\n {\n   if(hop.call(b,key))\n   {\n   if(typeof a[key] === 'undefined')\n   {\n    if(typeof b[key] === 'object')\n    {\n     if( b[key] instanceof Array ) // http://javascript.crockford.com/remedial.html\n      {a[key] = extend([], b[key],context,newobjs,a,key,true);}\n     else if(b[key]===null)\n      {a[key] = null;}\n     else if( b[key] instanceof Date )\n      { a[key]= new b[key].constructor();a[key].setTime(b[key].getTime());  }\n     else\n      { a[key] = extend({}, b[key],context,newobjs,a,key,true); /*a[key].constructor = b[key].constructor;  a[key].prototype = b[key].prototype;*/ }\n    }\n    else\n    {  a[key] = b[key]; }\n   }\n   else if(typeof a[key] === 'object' && a[key] !== null)\n   {  a[key] = extend(a[key], b[key],context,newobjs,a,key,true); /*a[key].constructor = b[key].constructor;  a[key].prototype = b[key].prototype;*/ }\n   else\n   {  a[key] = b[key]; }\n  }\n }\n if(clean_context) {context=null;newobjs=null;}\n if(!haveaparent)\n {\n  aparent=null;\n  return a;\n }\n if(typeof a === 'object' && !(a instanceof Array) )\n {\n  /*a.constructor = b.constructor;\n  a.prototype   = b.prototype*/;\n }\n return a;\n} exports.extend=extend;\n\nfunction extenduptolevel(a, b, levels, context, newobjs, aparent, aname, haveaparent)\n{\n if (a==b){ return a;}\n if (!b){ return a;}\n\n var key, clean_context=false, return_sublevel=false;\n if(!haveaparent){ aparent={'a':a}; aname='a'; }\n if(!context){clean_context=true;context=[];newobjs=[];}\n b_pos=context.indexOf(b);\n if( b_pos==-1 ) {context.push(b);newobjs.push([aparent, aname]);} else { return newobjs[b_pos][0][ newobjs[b_pos][1] ]; }\n\n for (key in b)\n {\n  if(hop.call(b,key))\n  {\n   if(typeof a[key] === 'undefined')\n   {\n    if(typeof b[key] === 'object' && levels>0)\n    {\n     if( b[key] instanceof Array ) // http://javascript.crockford.com/remedial.html\n     { a[key] = extenduptolevel([], b[key],levels-1,context,newobjs,a,key,true); }\n     else if(b[key]===null)\n     { a[key] = null; }\n     else if( b[key] instanceof Date )\n     { a[key]= new b[key].constructor();a[key].setTime(b[key].getTime());  }\n     else\n     { a[key] = extenduptolevel({}, b[key],levels-1,context,newobjs,a,key,true); }\n    }\n    else\n    {  a[key] = b[key]; }\n   }\n   else if(typeof a[key] === 'object' && a[key] !== null && levels>0)\n   {  a[key] = extenduptolevel(a[key], b[key],levels-1,context,newobjs,a,key,true); }\n   else\n   {  a[key] = b[key]; }\n  }\n }\n if(clean_context) {context=null;newobjs=null;}\n\n if(!haveaparent)\n {\n  aparent=null;\n  return a;\n }\n if(typeof a === 'object' && !(a instanceof Array) )\n {\n  /*a.constructor = b.constructor;\n  a.prototype   = b.prototype;*/\n }\n return a;\n} exports.extenduptolevel=extenduptolevel;\n\nfunction clone(obj)\n{\n if (typeof obj === 'object')\n {\n  if (obj ===null ) { return null; }\n  if (obj instanceof Array )\n  { return extend([], obj); }\n  else if( obj instanceof Date )\n  {\n   var t= new obj.constructor();\n   t.setTime(obj.getTime());\n   return t;\n  }\n  else\n  { return extend({}, obj); }\n }\n return obj;\n} exports.clone=clone;\n\nfunction cloneextend(obj,exteddata)\n{\n if (typeof obj === 'object')\n {\n  if (obj ===null ) { return null; }\n  return extend(clone(obj),exteddata);\n }\n return obj;\n} exports.cloneextend=cloneextend;\n\n\nfunction cloneuptolevel(obj,level) // clone only numlevels levels other levels leave references\n{\n if (typeof obj === 'object')\n {\n  if (obj ===null ) { return null; }\n  if (obj instanceof Array ) { return extenduptolevel([], obj,level); }\n  return extenduptolevel({}, obj,level);\n }\n return obj;\n} exports.cloneuptolevel=cloneuptolevel;\n\nfunction foreach(object, block, context)\n{\n if (object)\n {\n  if (typeof object === \"object\" && object instanceof Array)\n   return object.forEach(object, block, context)\n  else //if (typeof object === \"object\") // or (object instanceof Function)...\n  {\n   if(object)\n   for (var key in object)\n   {\n    if(hop.call(object,key))\n    {\n     if(block.call(context, object[key], key, object)===false)break;\n    }\n   }\n  }\n }\n} exports.foreach=foreach;\n\n/*\n hasbugs and useless, yet interesting maybe developed later for dot pathed object transformation:\n\n {\n  'foo.bar':'bluebar',\n  'foo.color':'blue'\n }\n\n transforemed to\n\n {\n  foo:\n  {\n   bar:'bluebar',\n   color:'blue'\n  }\n }\n\n like:\n\n var config={};\n cloneextend.dotpath(config,{\n  'foo.bar':'bluebar',\n  'foo.color':'blue'\n })\n\n //\n function dotpath(data,dotkeys,preserve)\n {\n      if(!preserve)preserve=false;\n      var create=!preserve;\n      if(create) if(!data) data={};\n      var keys= dotkeys.split(\".\"),value=data;\n      for (var i=0;i<keys.length;i++)\n      {\n          if(!value[keys[i]]) //should you create one?\n          {\n              if(create)\n                  value[keys[i]]={};\n              else\n                  return undefined;\n          }\n          value = value[keys[i]];\n      }\n      return value;\n }\n */","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/LoadEnvConfigStrategy.js":"'use strict';\n\nvar flat = require('flat');\nvar extend = require('../helpers/clone-extend').extend;\n\n/**\n * Represents a strategy that loads configuration variables from the environment into the configuration.\n *\n * @class\n */\nfunction LoadEnvConfigStrategy (prefix, aliases) {\n  this.prefix = prefix;\n  this.aliases = aliases || {};\n}\n\nLoadEnvConfigStrategy.prototype.process = function (config, callback) {\n  var delimiter = '_';\n  var prefix = this.prefix;\n  var aliases = this.aliases;\n  var flatConfig = { delimiter: delimiter };\n  var flattendDefaultConfig = flat.flatten(config, flatConfig);\n\n  var flatEnvValues = Object.keys(flattendDefaultConfig)\n    .reduce(function(envVarMap, key) {\n      var envKey = prefix + delimiter + key.toUpperCase();\n\n      if (envKey in aliases) {\n        envKey = aliases[envKey];\n      }\n\n      var value = process.env[envKey];\n\n      if(value !== undefined){\n        envVarMap[key] = typeof flattendDefaultConfig[key] === 'number' ?\n          parseInt(value, 10) : value;\n      }\n\n      return envVarMap;\n    }, {});\n\n  var envConfig = flat.unflatten(flatEnvValues, flatConfig);\n\n  if (envConfig) {\n    extend(config, envConfig);\n  }\n\n  callback(null, config);\n};\n\nmodule.exports = LoadEnvConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/LoadFileConfigStrategy.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar extend = require('../helpers/clone-extend').extend;\nvar parsers = require('./../parser');\nvar expandHomeDir = require('../helpers/expand-home-dir');\n\n/**\n * Load File Config Strategy\n * Represents a strategy that loads configuration from either a JSON or YAML file into the configuration.\n * @constructor\n */\nfunction LoadFileConfigStrategy (filePath, mustExist, encoding) {\n  this.filePath = filePath;\n  this.mustExist = mustExist || false;\n  this.encoding = encoding || 'utf8';\n}\n\nLoadFileConfigStrategy.prototype.process = function (config, callback) {\n  var outerScope = this;\n\n  var mustExist = this.mustExist;\n  var originalFilePath = this.filePath;\n  var expandedFilePath = expandHomeDir(originalFilePath);\n\n  // In case we don't have a home path but specified a '~' in our path...\n  if (expandedFilePath === false) {\n    if (mustExist) {\n      return callback(new Error(\"Unable to load '\" + originalFilePath + \"'. Environment home not set.\"));\n    }\n    return callback(null, config);\n  }\n\n  var extension = path.extname(expandedFilePath).substring(1);\n  var parser = parsers[extension];\n\n  if (!parser) {\n    return callback(new Error(\"Unable to load file '\" + originalFilePath + \"'. Extension '\" + extension + \"' not supported.\"));\n  }\n\n  fs.exists(expandedFilePath, function (exists) {\n    if (!exists) {\n      if (mustExist) {\n        callback(new Error(\"Config file '\" + originalFilePath + \"' doesn't exist.\"));\n      } else {\n        callback(null, config);\n      }\n    } else {\n      fs.readFile(expandedFilePath, { encoding: outerScope.encoding }, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        parser(result, function (err, data) {\n          if (err) {\n            return callback(new Error(\"Error parsing file '\" + expandedFilePath + \"'.\\nDetails: \" + err));\n          }\n\n          if (data) {\n            extend(config, data);\n          }\n\n          callback(null, config);\n        });\n      });\n    }\n  });\n};\n\nmodule.exports = LoadFileConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/parser/index.js":"'use strict';\n\nmodule.exports = {\n  yml: require('./YamlParser'),\n  json: require('./JsonParser')\n};","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/parser/YamlParser.js":"'use strict';\n\nvar yaml = require('js-yaml');\n\n/**\n * Represents a parser that parses YAML strings.\n *\n * @func\n */\nmodule.exports = function YamlParser (text, callback) {\n  if (text === '' || text === undefined || text === null) {\n    callback(null, null);\n    return;\n  }\n\n  try {\n    var data = yaml.load(text);\n    callback(null, data);\n  } catch (err) {\n    callback(err);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/parser/JsonParser.js":"'use strict';\n\n/**\n * Represents a parser that parses JSON strings.\n *\n * @func\n */\n module.exports = function JsonParser (text, callback) {\n  if (text === '' || text === undefined || text === null) {\n    callback(null, null);\n    return;\n  }\n\n  try {\n    var data = JSON.parse(text);\n    callback(null, data);\n  } catch (err) {\n    callback(err);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/helpers/expand-home-dir.js":"'use strict';\n\nvar join = require('path').join;\n\nfunction expandHomeDir(path) {\n  var isWindows = process.platform == 'win32';\n  var homeDir = process.env[isWindows ? 'USERPROFILE' : 'HOME'];\n\n  if (path === '~') {\n    if (!homeDir) {\n      return false;\n    }\n    return homeDir;\n  }\n\n  if (!path || path[0] !== '~') {\n    return path;\n  }\n\n  if (!homeDir) {\n    return false;\n  }\n\n\n  return join(homeDir, path.slice(2));\n}\n\nmodule.exports = expandHomeDir;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/LoadAPIKeyConfigStrategy.js":"'use strict';\n\nvar fs = require('fs');\nvar extend = require('../helpers/clone-extend').extend;\nvar propsParser = require('properties-parser');\nvar expandHomeDir = require('../helpers/expand-home-dir');\n\n/**\n * Represents a strategy that loads API keys from a .properties file into the configuration.\n *\n * @class\n */\nfunction LoadAPIKeyConfigStrategy (filePath, mustExist) {\n  this.filePath = filePath;\n  this.mustExist = mustExist || false;\n}\n\nLoadAPIKeyConfigStrategy.prototype.process = function (config, callback) {\n  var mustExist = this.mustExist;\n  var filePath = expandHomeDir(this.filePath);\n\n  // In case we don't have a home path but specified a '~' in our path...\n  if (filePath === false) {\n    if (mustExist) {\n      return callback(new Error(\"Unable to load '\" + this.filePath + \"'. Environment home not set.\"));\n    }\n    return callback(null, config);\n  }\n\n  fs.exists(filePath, function (exist) {\n    if (!exist) {\n      if (mustExist) {\n        callback(new Error('Client API key file not found: ' + filePath));\n      } else {\n        callback(null, config);\n      }\n    } else {\n      // Extend config with default client apiKey fields.\n      extend(config, {\n        client: {\n          apiKey: {}\n        }\n      });\n\n      if (!mustExist && config.client.apiKey.id && config.client.apiKey.secret) {\n        return callback(null, config);\n      }\n\n      propsParser.read(filePath, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!result) {\n          result = {};\n        }\n\n        // If we don't require the file to exist and if the key\n        // file is empty, then just ignore it.\n        if (!mustExist && Object.keys(result).length === 0) {\n          return callback(null, config);\n        }\n\n        var apiKeyId = result['apiKey.id'];\n        var apiKeySecret = result['apiKey.secret'];\n\n        if (!apiKeyId || !apiKeySecret) {\n          return callback(new Error('Unable to read properties file: ' + filePath));\n        }\n\n        config.client.apiKey.id = apiKeyId;\n        config.client.apiKey.secret = apiKeySecret;\n\n        callback(null, config);\n      });\n    }\n  });\n};\n\nmodule.exports = LoadAPIKeyConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/LoadAPIKeyFromConfigStrategy.js":"'use strict';\n\nvar LoadAPIKeyConfigStrategy = require('./LoadAPIKeyConfigStrategy');\n\n/**\n * Represents a strategy that that loads an API key specified in config into the configuration.\n *\n * @class\n */\nfunction LoadAPIKeyFromConfigStrategy () {\n}\n\nLoadAPIKeyFromConfigStrategy.prototype.process = function (config, callback) {\n  if (!config.client || !config.client.apiKey) {\n    return callback(null, config);\n  }\n\n  var apiKey = config.client.apiKey;\n\n  if (apiKey.file) {\n    var loadKeyStrategy = new LoadAPIKeyConfigStrategy(apiKey.file, true);\n    loadKeyStrategy.process(config, callback);\n  } else {\n    callback(null, config);\n  }\n};\n\nmodule.exports = LoadAPIKeyFromConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/EnrichClientConfigStrategy.js":"'use strict';\n\nvar extend = require('../helpers/clone-extend').extend;\n\n/**\n * Represents a strategy that enriches the API Key configuration (post loading).\n *\n * @class\n */\nfunction EnrichClientConfigStrategy () {\n}\n\nEnrichClientConfigStrategy.prototype.process = function (config, callback) {\n  // If we have specified an API key in the root, then copy this to our client API key.\n  if (config.apiKey) {\n    var extendWith = {};\n\n    // Only copy if we have a value set.\n    // This is to things such as NULL defaults.\n    for (var key in config.apiKey) {\n      if (config.apiKey[key]) {\n        extendWith[key] = config.apiKey[key];\n      }\n    }\n\n    extend(config, {\n      client: {\n        apiKey: extendWith\n      }\n    })\n  }\n\n  // For backwards compatibility reasons, if no API key is specified we'll try\n  // to grab the API credentials out of our new format and shove it into the old\n  // format.  This can go away once we cut a release and decide to no longer\n  // support the old configuration formatting.\n  if (!config.apiKey && config.client && config.client.apiKey) {\n    config.apiKey = config.client.apiKey;\n  }\n\n  callback(null, config);\n};\n\nmodule.exports = EnrichClientConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/EnrichClientFromRemoteConfigStrategy.js":"'use strict';\n\nvar strings = require('../strings');\n\n/**\n * Retrieves Stormpath settings from the API service, and ensures the local\n * configuration object properly reflects these settings.\n *\n * @class\n*/\nfunction EnrichClientFromRemoteConfigStrategy (clientFactory) {\n  this.clientFactory = clientFactory;\n}\n\n// Finds and returns an Application object given an Application HREF.  Will\n// return an error if no Application is found.\nEnrichClientFromRemoteConfigStrategy.prototype._resolveApplicationByHref = function (client, config, href, cb) {\n  client.getApplication(href, function (err, app) {\n    if (err) {\n      if(err.status === 404){\n        cb(new Error(\n          strings.APP_HREF_NOT_FOUND.replace('%href%', href)\n        ));\n      }else{\n        cb(err);\n      }\n    } else {\n      config.application = app;\n      cb(null, app);\n    }\n  });\n};\n\n// Finds and returns an Application object given an Application name.  Will\n// return an error if no Application is found.\nEnrichClientFromRemoteConfigStrategy.prototype._resolveApplicationByName = function (client, config, name, cb) {\n  client.getApplications({ name: name }, function (err, applications) {\n    if (err) {\n      return cb(err);\n    }\n\n    applications.detect(function (app, cb) {\n      cb(name === app.name);\n    }, function (app) {\n      if (!app) {\n        cb(new Error(\n          strings.APP_NAME_NOT_FOUND.replace('%name%', name)\n        ));\n      } else {\n        config.application = app;\n        cb(null, app);\n      }\n    });\n  });\n};\n\n// If there are only two applications and one of them is\n// the Stormpath application, then use the other one as default.\nEnrichClientFromRemoteConfigStrategy.prototype._resolveDefaultApplication = function (client, config, cb) {\n  client.getApplications(function (err, applications) {\n    if (err) {\n      return cb(err);\n    }\n\n    var userApplications = applications.items.filter(function (app) {\n      return app.name !== 'Stormpath';\n    });\n\n    if (userApplications.length === 1) {\n      config.application = userApplications[0];\n      cb(null, userApplications[0]);\n    } else {\n      cb(new Error(\n        strings.UNABLE_TO_AUTO_RESOLVE_APP\n      ));\n    }\n  });\n};\n\nEnrichClientFromRemoteConfigStrategy.prototype.process = function (config, callback) {\n  if (config.skipRemoteConfig) {\n    return callback(null, config);\n  }\n\n  var resolver = null;\n  var application = config.application || {};\n  var client = this.clientFactory(config);\n\n  // Resolve the application either explicitly by HREF or implicitly by name.\n  if (application.href) {\n    resolver = this._resolveApplicationByHref.bind(this, client, config, application.href);\n  } else if (application.name) {\n    resolver = this._resolveApplicationByName.bind(this, client, config, application.name);\n  } else {\n    resolver = this._resolveDefaultApplication.bind(this, client, config);\n  }\n\n  client.on('ready', function () {\n    resolver(function (err) {\n      callback(err, err ? null : config);\n    });\n  });\n};\n\nmodule.exports = EnrichClientFromRemoteConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strings.js":"module.exports = {\n  APP_HREF_NOT_FOUND: 'The provided application could not be found.\\n\\nThe provided application href was: %href%\\n',\n  APP_NAME_NOT_FOUND: 'The provided application could not be found.\\n\\nThe provided application name was: %name%\\n',\n  CONFLICTING_AUTO_LOGIN_AND_EMAIL_VERIFICATION_CONFIG: 'Invalid configuration: stormpath.web.register.autoLogin is true, but the default account store of the specified application has the email verification workflow enabled. Auto login is only possible if email verification is disabled. Please disable this workflow on this application\\'s default account store.',\n  NO_ACCOUNT_STORES_MAPPED: 'No account stores are mapped to the specified application. Account stores are required for login and registration.',\n  NO_DEFAULT_ACCOUNT_STORE_MAPPED: 'No default account store is mapped to the specified application. A default account store is required for registration.',\n  UNABLE_TO_AUTO_RESOLVE_APP: 'Could not automatically resolve a Stormpath Application.  \\n\\nPlease specify your Stormpath Application in your configuration.\\n',\n  UNABLE_TO_RESOLVE_APP: 'Unable to resolve a Stormpath application.'\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/EnrichIntegrationConfigStrategy.js":"'use strict';\n\nvar extend = require('../helpers/clone-extend').extend;\n\n/**\n * Represents a strategy that enriches the configuration (post loading).\n *\n * @class\n */\nfunction EnrichIntegrationConfigStrategy (userConfig) {\n  this.userConfig = userConfig;\n}\n\nEnrichIntegrationConfigStrategy.prototype.process = function (config, callback) {\n  var webFeaturesToEnable = [];\n\n  // If a user enables a boolean configuration option named `website`, this\n  // means the user is building a website and we should automatically enable\n  // certain features in the library meant for users developing websites.  This\n  // is a simpler way of handling configuration than forcing users to specify\n  // all nested JSON configuration options themselves.\n  if (config.website) {\n    webFeaturesToEnable.push('register');\n    webFeaturesToEnable.push('login');\n    webFeaturesToEnable.push('logout');\n    webFeaturesToEnable.push('me');\n  }\n\n  // If a user enables a boolean configuration option named `api`, this means\n  // the user is building an API service, and we should automatically enable\n  // certain features in the library meant for users developing API services --\n  // namely, our OAuth2 token endpoint (/oauth/token).  This allows users\n  // building APIs to easily provision OAuth2 tokens without specifying any\n  // nested JSON configuration options.\n  if (config.api) {\n    webFeaturesToEnable.push('oauth2');\n  }\n\n  var userConfig = this.userConfig;\n\n  webFeaturesToEnable.forEach(function (feature) {\n    var webFeatures = {};\n\n    // Only turn on features that haven't already been configured by the user.\n    if (!(userConfig && userConfig.web && (feature in userConfig.web) && ('enabled' in userConfig.web[feature]))) {\n      webFeatures[feature] = {\n        enabled: true\n      };\n    }\n\n    extend(config, {\n      web: webFeatures\n    });\n  });\n\n  callback(null, config);\n};\n\nmodule.exports = EnrichIntegrationConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/EnrichIntegrationFromRemoteConfigStrategy.js":"'use strict';\n\nvar async = require('async');\nvar extend = require('../helpers/clone-extend').extend;\nvar strings = require('../strings');\n\n/**\n * Retrieves Stormpath settings from the API service, and ensures the local\n * configuration object properly reflects these settings.\n *\n * @class\n*/\nfunction EnrichIntegrationFromRemoteConfigStrategy (clientFactory) {\n  this.clientFactory = clientFactory;\n}\n\nEnrichIntegrationFromRemoteConfigStrategy.prototype._resolveApplication = function (config, callback) {\n  var application = config.application;\n  if (!application || !application.href || !application.getAccountStoreMappings) {\n    callback(new Error(strings.UNABLE_TO_RESOLVE_APP));\n  } else {\n    callback(null, config.application);\n  }\n};\n\nEnrichIntegrationFromRemoteConfigStrategy.prototype._validateAccountStore = function (config, app, callback) {\n  app.getAccountStoreMappings(function (err, mappings) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (mappings.size === 0) {\n      return callback(new Error(strings.NO_ACCOUNT_STORES_MAPPED));\n    } else if (config.web.register.enabled && app.defaultAccountStoreMapping === null) {\n      return callback(new Error(strings.NO_DEFAULT_ACCOUNT_STORE_MAPPED));\n    }\n\n    callback(null, app);\n  });\n};\n\n// Returns the OAuth policy of the Stormpath Application.\nEnrichIntegrationFromRemoteConfigStrategy.prototype._enrichWithOAuthPolicy = function (app, callback) {\n  app.getOAuthPolicy(function(err, policy) {\n    if (err) {\n      return callback(err);\n    }\n\n    app.oAuthPolicy = policy;\n\n    return callback(null, app);\n  });\n};\n\n// Iterate over all account stores on the given Application, looking for all\n// Social providers.  We'll then create a config.providers array which we'll\n// use later on to dynamically populate all social login configurations ^^\nEnrichIntegrationFromRemoteConfigStrategy.prototype._enrichWithSocialProviders = function (config, application, callback) {\n  application.getAccountStoreMappings(function(err, mappings) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!config.web.social) {\n      config.web.social = {};\n    }\n\n    mappings.each(function (mapping, next) {\n      mapping.getAccountStore(function (err, accountStore) {\n        if (err) {\n          return next(err);\n        }\n\n        // Iterate directories\n        if (/\\/directories/.test(accountStore.href)) {\n          accountStore.getProvider(function(err, remoteProvider) {\n            if (err) {\n              return next(err);\n            }\n\n            var providerId = remoteProvider.providerId;\n\n            // If the provider isn't a Stormpath, AD, or LDAP directory it's a social directory.\n            if (['stormpath', 'ad', 'ldap'].indexOf(providerId) === -1) {\n              // Remove unnecessary properties that clutter our config.\n              delete remoteProvider.href;\n              delete remoteProvider.createdAt;\n              delete remoteProvider.updatedAt;\n\n              var localProvider = config.web.social[providerId];\n\n              if (!localProvider) {\n                localProvider = config.web.social[providerId] = {};\n              }\n\n              if (!localProvider.uri) {\n                localProvider.uri = '/callbacks/' + remoteProvider.providerId;\n              }\n\n              /**\n               * \"localScope\" backwards compatibility code to preserve locally\n               * defined scope options.  Soon developers will specify their\n               * required scope on the directory provider resource.  But in the\n               * meantime, we should not overwrite what they've provided locally.\n               */\n\n              var localScope;\n\n              if (localProvider.scope) {\n                localScope = localProvider.scope;\n              }\n\n              extend(remoteProvider, { enabled: true });\n              extend(localProvider, remoteProvider);\n\n              if (localScope) {\n                localProvider.scope = localScope;\n              }\n\n            }\n\n            next();\n          });\n        } else {\n          next();\n        }\n      });\n    }, function(err) {\n      callback(err, application);\n    });\n  });\n};\n\n// Finds and returns an Application's default Account Store (Directory)\n// object.  If one doesn't exist, nothing will be returned.\nEnrichIntegrationFromRemoteConfigStrategy.prototype._resolveDirectoryHref = function (app, callback) {\n  var outerScope = this;\n\n  app.getAccountStoreMappings(function(err, mappings) {\n    if (err) {\n      return callback(err);\n    }\n\n    mappings.detect(function(mapping, detectCallback) {\n      detectCallback(mapping.isDefaultAccountStore);\n    }, function(defaultMapping) {\n      if (defaultMapping) {\n        var href = defaultMapping.accountStore.href;\n\n        if (href.match(/directories/)) {\n          return callback(null, href);\n        }\n\n        if (href.match(/group/)) {\n          outerScope.client.getGroup(href, function(err, group) {\n            return callback(err, group && group.directory.href);\n          });\n        } else {\n          return callback(null, null);\n        }\n      } else {\n        return callback(null, null);\n      }\n    });\n  });\n};\n\n// Pulls down all of a Directory's configuration settings,\n// and applies them to the local configuration.\nEnrichIntegrationFromRemoteConfigStrategy.prototype._enrichWithDirectoryPolicies = function (client, config, directoryHref, callback) {\n  if (!directoryHref) {\n    return callback(null, null);\n  }\n\n  // Helper method that checks if a status is set to \"enabled\".\n  var isEnabled = function (status) {\n    return status === 'ENABLED';\n  };\n\n  // Returns the callback immediately if there is an error.\n  // Continues processing if there isn't.\n  var stopIfError = function (process) {\n    return function (err, result) {\n      if (err) {\n        callback(err);\n      } else {\n        process(result);\n      }\n    }\n  };\n\n  // Enrich config with with directory policies.\n  client.getDirectory(directoryHref, { expand: 'passwordPolicy,accountCreationPolicy' }, stopIfError(function (directory) {\n    var resetEmailStatusEnabled = isEnabled(directory.passwordPolicy.resetEmailStatus);\n    var verificationEmailStatusEnabled = isEnabled(directory.accountCreationPolicy.verificationEmailStatus);\n\n    // Enrich config with account policies.\n    extend(config, {\n      web: {\n        forgotPassword: {\n          enabled: config.web.forgotPassword.enabled === false ? false : resetEmailStatusEnabled\n        },\n        changePassword: {\n          enabled: config.web.changePassword.enabled === false ? false : resetEmailStatusEnabled\n        },\n        verifyEmail: {\n          enabled: config.web.verifyEmail.enabled === false ? false : verificationEmailStatusEnabled\n        }\n      }\n    });\n\n    // Validate that auto login and email verification aren't enabled at the same time.\n    if (config.web.register.autoLogin && config.web.verifyEmail.enabled) {\n      return callback(new Error(strings.CONFLICTING_AUTO_LOGIN_AND_EMAIL_VERIFICATION_CONFIG));\n    }\n\n    // Enrich config with password policies.\n    directory.getPasswordPolicy(stopIfError(function (policy) {\n      policy.getStrength(stopIfError(function (strength) {\n        // Remove the href property from the Strength Resource, we don't want\n        // this to clutter up our nice passwordPolicy configuration\n        // dictionary!\n        delete strength.href;\n\n        config.passwordPolicy = strength;\n\n        callback(null, null);\n      }));\n    }));\n  }));\n};\n\nEnrichIntegrationFromRemoteConfigStrategy.prototype.process = function (config, callback) {\n  var tasks = [];\n\n  if (config.skipRemoteConfig) {\n    return callback(null, config);\n  }\n\n  var client = this.client = this.clientFactory(config);\n\n  if (config.application && config.application.href) {\n    tasks = tasks.concat([\n      this._resolveApplication.bind(this, config),\n      this._validateAccountStore.bind(this, config),\n      this._enrichWithOAuthPolicy.bind(this),\n      this._enrichWithSocialProviders.bind(this, config),\n      this._resolveDirectoryHref.bind(this),\n      this._enrichWithDirectoryPolicies.bind(this, client, config)\n    ]);\n  }\n\n  client.on('error', function (err) {\n    callback(err);\n  });\n\n  client.on('ready', function () {\n    async.waterfall(tasks, function (err) {\n      callback(err, err ? null : config);\n    });\n  });\n};\n\nmodule.exports = EnrichIntegrationFromRemoteConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/node_modules/async/dist/async.js":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.async = global.async || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest$1(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n// Lodash rest function without function.toString()\n// remappings\nfunction rest(func, start) {\n    return overRest$1(func, start, identity);\n}\n\nvar initialParams = function (fn) {\n    return rest(function (args /*..., callback*/) {\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    });\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous funuction, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function (value) {\n                callback(null, value);\n            }, function (err) {\n                callback(err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction supportsAsync() {\n    var supported;\n    try {\n        /* eslint no-eval: 0 */\n        supported = isAsync(eval('(async function () {})'));\n    } catch (e) {\n        supported = false;\n    }\n    return supported;\n}\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nvar wrapAsync$1 = supportsAsync() ? wrapAsync : identity;\n\nfunction applyEach$1(eachfn) {\n    return rest(function (fns, args) {\n        var go = initialParams(function (args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync$1(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        } else {\n            return go;\n        }\n    });\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  value = Object(value);\n  return (symToStringTag && symToStringTag in value)\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? { value: obj[key], key: key } : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function () {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (value === breakLoop || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if (++completed === length || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function (coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync$1(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply$2 = rest(function (fn, args) {\n    return rest(function (callArgs) {\n        return fn.apply(null, args.concat(callArgs));\n    });\n});\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            runningTasks--;\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function (val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = args;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = args;\n                taskComplete(key);\n            }\n        }));\n\n        runningTasks++;\n        var taskFn = wrapAsync$1(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20f0';\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg) {\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync$1(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return rest(function (fn, args) {\n        defer(function () {\n            fn.apply(null, args);\n        });\n    });\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function (node) {\n    if (node.prev) node.prev.next = node.next;else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = DLL;\n\nDLL.prototype.insertAfter = function (node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function (node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function (node) {\n    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);\n};\n\nDLL.prototype.push = function (node) {\n    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);\n};\n\nDLL.prototype.shift = function () {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function () {\n    return this.tail && this.removeLink(this.tail);\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    } else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync$1(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    }\n\n    function _next(tasks) {\n        return rest(function (args) {\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n                var index = baseIndexOf(workersList, task, 0);\n                if (index >= 0) {\n                    workersList.splice(index);\n                }\n\n                task.callback.apply(task, args);\n\n                if (args[0] != null) {\n                    q.error(args[0], task.data);\n                }\n            }\n\n            if (numRunning <= q.concurrency - q.buffer) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        });\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated: noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {\n                var tasks = [],\n                    data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    data.push(node.data);\n                }\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n                numRunning += 1;\n                workersList.push(tasks[0]);\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function () {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) {\n                return;\n            }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n  return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    eachOfSeries(coll, function (x, i, callback) {\n        _iteratee(memo, x, function (err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nvar seq$1 = rest(function seq(functions) {\n    var _functions = arrayMap(functions, wrapAsync$1);\n    return rest(function (args) {\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function (newargs, fn, cb) {\n            fn.apply(that, newargs.concat(rest(function (err, nextargs) {\n                cb(err, nextargs);\n            })));\n        }, function (err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    });\n});\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = rest(function (args) {\n  return seq$1.apply(null, args.reverse());\n});\n\nfunction concat$1(eachfn, arr, fn, callback) {\n    var result = [];\n    eachfn(arr, function (x, index, cb) {\n        fn(x, function (err, y) {\n            result = result.concat(y || []);\n            cb(err);\n        });\n    }, function (err) {\n        callback(err, result);\n    });\n}\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doParallel(concat$1);\n\nfunction doSeries(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOfSeries, obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doSeries(concat$1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = rest(function (values) {\n    var args = [null].concat(values);\n    return initialParams(function (ignoredArgs, callback) {\n        return callback.apply(this, args);\n    });\n});\n\nfunction _createTester(check, getResult) {\n    return function (eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function (value, _, callback) {\n            iteratee(value, function (err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return rest(function (fn, args) {\n        wrapAsync$1(fn).apply(null, args.concat(rest(function (err, args) {\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        })));\n    });\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync$1(fn);\n    var _test = wrapAsync$1(test);\n\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        args.push(check);\n        _test.apply(this, args);\n    });\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function () {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync$1(fn);\n    var _test = wrapAsync$1(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({ index: index, value: x });\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync$1(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync$1(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function (coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync$1(iteratee);\n    mapLimit(coll, limit, function (val, callback) {\n        _iteratee(val, function (err, key) {\n            if (err) return callback(err);\n            return callback(null, { key: key, val: val });\n        });\n    }, function (err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync$1(iteratee);\n    eachOfLimit(obj, limit, function (val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync$1(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function () {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(rest(function (args) {\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            })));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `setImmediate`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @alias setImmediate\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync$1(task)(rest(function (err, args) {\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            results[key] = args;\n            callback(err);\n        }));\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n  _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n  _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n  var _worker = wrapAsync$1(worker);\n  return queue(function (items, cb) {\n    _worker(items[0], cb);\n  }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function (worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function (data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync$1(tasks[i])(callback);\n    }\n}\n\nvar slice = Array.prototype.slice;\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight(array, memo, iteratee, callback) {\n  var reversed = slice.call(array).reverse();\n  reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync$1(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(rest(function callback(err, cbArgs) {\n            if (err) {\n                reflectCallback(null, {\n                    error: err\n                });\n            } else {\n                var value = null;\n                if (cbArgs.length === 1) {\n                    value = cbArgs[0];\n                } else if (cbArgs.length > 1) {\n                    value = cbArgs;\n                }\n                reflectCallback(null, {\n                    value: value\n                });\n            }\n        }));\n\n        return _fn.apply(this, args);\n    });\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function (value, cb) {\n        iteratee(value, function (err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function (task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // It can also be embedded within other control flow functions to retry\n * // individual methods that are not as reliable, like this:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync$1(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function (err) {\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync$1(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n  _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy(coll, iteratee, callback) {\n    var _iteratee = wrapAsync$1(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, { value: x, criteria: criteria });\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria,\n            b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var originalCallback, timer;\n    var timedOut = false;\n\n    function injectedCallback() {\n        if (!timedOut) {\n            originalCallback.apply(null, arguments);\n            clearTimeout(timer);\n        }\n    }\n\n    function timeoutCallback() {\n        var name = asyncFn.name || 'anonymous';\n        var error = new Error('Callback function \"' + name + '\" timed out.');\n        error.code = 'ETIMEDOUT';\n        if (info) {\n            error.info = info;\n        }\n        timedOut = true;\n        originalCallback(error);\n    }\n\n    var fn = wrapAsync$1(asyncFn);\n\n    return initialParams(function (args, origCallback) {\n        originalCallback = origCallback;\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args.concat(injectedCallback));\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax$1 = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n  var _iteratee = wrapAsync$1(iteratee);\n  mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform(coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n\n    eachOf(coll, function (v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function (err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    if (!test()) return callback(null);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function () {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function (tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        if (taskIndex === tasks.length) {\n            return callback.apply(null, [null].concat(args));\n        }\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            if (err) {\n                return callback.apply(null, [err].concat(args));\n            }\n            nextTask(args);\n        }));\n\n        args.push(taskCallback);\n\n        var task = wrapAsync$1(tasks[taskIndex++]);\n        task.apply(null, args);\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n  applyEach: applyEach,\n  applyEachSeries: applyEachSeries,\n  apply: apply$2,\n  asyncify: asyncify,\n  auto: auto,\n  autoInject: autoInject,\n  cargo: cargo,\n  compose: compose,\n  concat: concat,\n  concatSeries: concatSeries,\n  constant: constant,\n  detect: detect,\n  detectLimit: detectLimit,\n  detectSeries: detectSeries,\n  dir: dir,\n  doDuring: doDuring,\n  doUntil: doUntil,\n  doWhilst: doWhilst,\n  during: during,\n  each: eachLimit,\n  eachLimit: eachLimit$1,\n  eachOf: eachOf,\n  eachOfLimit: eachOfLimit,\n  eachOfSeries: eachOfSeries,\n  eachSeries: eachSeries,\n  ensureAsync: ensureAsync,\n  every: every,\n  everyLimit: everyLimit,\n  everySeries: everySeries,\n  filter: filter,\n  filterLimit: filterLimit,\n  filterSeries: filterSeries,\n  forever: forever,\n  groupBy: groupBy,\n  groupByLimit: groupByLimit,\n  groupBySeries: groupBySeries,\n  log: log,\n  map: map,\n  mapLimit: mapLimit,\n  mapSeries: mapSeries,\n  mapValues: mapValues,\n  mapValuesLimit: mapValuesLimit,\n  mapValuesSeries: mapValuesSeries,\n  memoize: memoize,\n  nextTick: nextTick,\n  parallel: parallelLimit,\n  parallelLimit: parallelLimit$1,\n  priorityQueue: priorityQueue,\n  queue: queue$1,\n  race: race,\n  reduce: reduce,\n  reduceRight: reduceRight,\n  reflect: reflect,\n  reflectAll: reflectAll,\n  reject: reject,\n  rejectLimit: rejectLimit,\n  rejectSeries: rejectSeries,\n  retry: retry,\n  retryable: retryable,\n  seq: seq$1,\n  series: series,\n  setImmediate: setImmediate$1,\n  some: some,\n  someLimit: someLimit,\n  someSeries: someSeries,\n  sortBy: sortBy,\n  timeout: timeout,\n  times: times,\n  timesLimit: timeLimit,\n  timesSeries: timesSeries,\n  transform: transform,\n  unmemoize: unmemoize,\n  until: until,\n  waterfall: waterfall,\n  whilst: whilst,\n\n  // aliases\n  all: every,\n  any: some,\n  forEach: eachLimit,\n  forEachSeries: eachSeries,\n  forEachLimit: eachLimit$1,\n  forEachOf: eachOf,\n  forEachOfSeries: eachOfSeries,\n  forEachOfLimit: eachOfLimit,\n  inject: reduce,\n  foldl: reduce,\n  foldr: reduceRight,\n  select: filter,\n  selectLimit: filterLimit,\n  selectSeries: filterSeries,\n  wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.apply = apply$2;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq$1;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/strategy/ValidateClientConfigStrategy.js":"'use strict';\n\nvar extend = require('../helpers/clone-extend').extend;\n\n/**\n * Represents a strategy that validates the configuration (post loading).\n *\n * @class\n */\nfunction ValidateClientConfigStrategy () {\n}\n\nValidateClientConfigStrategy.prototype.process = function (config, callback) {\n  var newError = function (err) {\n    callback(new Error(err));\n  };\n\n  if (!config) {\n    return newError(\"Configuration not instantiated.\");\n  }\n\n  var client = config.client;\n\n  if (!client) {\n    return newError(\"Client cannot be empty.\");\n  }\n\n  var apiKey = client.apiKey;\n\n  if (!apiKey) {\n    return newError(\"API key cannot be empty.\");\n  } if (!apiKey.id || !apiKey.secret) {\n    return newError(\"API key ID and secret is required.\");\n  }\n\n  var application = config.application;\n\n  if (!application) {\n    return newError(\"Application cannot be empty.\");\n  }\n\n  if (application.href && application.href.indexOf('/applications/') === -1) {\n    return newError(\"Application HREF '\" + application.href + \"' is not a valid Stormpath Application HREF.\");\n  }\n\n  var web = config.web;\n\n  if (web && web.spa && web.spa.enabled && web.spa.view === null) {\n    return newError(\"SPA mode is enabled but stormpath.web.spa.view isn't set. This needs to be the absolute path to the file that you want to serve as your SPA entry.\");\n  }\n\n  callback(null, config);\n};\n\nmodule.exports = ValidateClientConfigStrategy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/Config.js":"var deepCopy = require('lodash').deepCopy;\n\nfunction Config() {\n}\n\nConfig.prototype.clone = function () {\n  return deepCopy(this);\n};\n\nConfig.prototype.toString = function () {\n  return JSON.stringify(this, null, 4);\n};\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath-config/lib/ConfigLoader.js":"'use strict';\n\nvar async = require('async');\nvar strategy = require('./strategy');\n\nvar Config = require('./Config');\n\n/**\n * ConfigLoader\n * Represents a configuration loader that loads a configuration through a list of strategies.\n *\n * @constructor\n */\nfunction ConfigLoader(strategies, logger) {\n  this.strategies = [];\n\n  if (logger) {\n    if (typeof logger.debug !== 'function') {\n      throw new Error('Provided logger is required to have method debug().');\n    }\n    this.logger = logger;\n  }\n\n  if (strategies && !(strategies instanceof Array)) {\n    throw new Error('Argument \\'strategies\\' must be an array.');\n  }\n\n  for (var i = 0; i < strategies.length; i++) {\n    this.add(strategies[i]);\n  }\n}\n\nConfigLoader.prototype.add = function (item) {\n  if (!item || typeof item.process !== 'function') {\n    throw new Error('Unable to add strategy. Strategy is either empty or missing required method \\'process\\'.');\n  }\n\n  if (this.logger) {\n    if (typeof item.setLogger === 'function') {\n      item.setLogger(this.logger);\n    }\n    this.strategies.push(new strategy.DebugConfigStrategy(this.logger, 'Before:' + item.constructor.name));\n  }\n\n  this.strategies.push(item);\n};\n\nConfigLoader.prototype.prepend = function (item) {\n  if (!item || typeof item.process !== 'function') {\n    throw new Error('Unable to prepend strategy. Strategy is either empty or missing required method \\'process\\'.');\n  }\n\n  if (this.logger) {\n    if (typeof item.setLogger === 'function') {\n      item.setLogger(this.logger);\n    }\n    this.strategies.unshift(new strategy.DebugConfigStrategy(this.logger, 'Before:' + item.constructor.name));\n  }\n\n  this.strategies.unshift(item);\n};\n\nConfigLoader.prototype.load = function (callback) {\n  var logger = this.logger;\n  var strategies = this.strategies.slice();\n\n  // Ensure that we always start out with a empty config object.\n  strategies.unshift(new strategy.NullConfigStrategy(new Config()));\n\n  var tasks = [];\n\n  for (var i = 0; i < strategies.length; i++) {\n    tasks.push(strategies[i].process.bind(strategies[i]));\n  }\n\n  async.waterfall(tasks, function (err, result) {\n    if (logger) {\n      if (err) {\n        logger.debug('Error:\\n' + JSON.stringify(err, null, 4) + '\\n');\n      } else {\n        logger.debug('Result:\\n' + JSON.stringify(result, null, 4) + '\\n');\n      }\n    }\n    callback(err, result);\n  });\n};\n\nmodule.exports = ConfigLoader;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/jwt/jwt-authentication-result.js":"'use strict';\n\nvar nJwt = require('njwt');\nvar utils = require('../utils');\n\n/**\n * @typedef {Object} AccessTokenResponse\n *\n * @type {Object}\n *\n * @description\n * The verbatim response from the application's `oauth/token` endpoint.\n *\n * @property {String} access_token\n * The JWT-encoded OAuth2 access token, created by the Stormpath REST API.\n *\n * @property {String} refresh_token\n * The JWT-encoded OAuth2 refresh token, created by the Stormpath REST API.\n *\n * @property {String} token_type\n * The OAuth2 token type, will always be `Bearer`.\n *\n * @property {Number} expires_in\n * The number of seconds that this token is valid for.\n *\n * @property {String} stormpath_access_token_href\n * The HREF of the {@link AccessToken} resource.\n *\n * @example\n *\n * {\n *   \"refresh_token\": \"eyJraWQiOiI2NldURFJVM1paSkNZVFJVVlZTUUw3WEJOIiwiYWxnIjoiSFMyNTYifQ.eyJqdGkiOiI2Q01BQ2Y2YlpEUVZPb3lLZFo3dkxXIiwiaWF0IjoxNDQ5Njk1MjIzLCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8xaDcyUEZXb0d4SEtoeXNLallJa2lyIiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy80V0NDdGMwb0NSRHpRZEFIVlFUcWp6IiwiZXhwIjoxNDU0ODc5MjIzfQ.ctzC_quBRIntssbPYiNqOBtYksGPsdVy4AwuDJKjodM\",\n *   \"stormpath_access_token_href\": \"https://api.stormpath.com/v1/accessTokens/6CMACiQgTnjU1e4BpozBxa\",\n *   \"token_type\": \"Bearer\",\n *   \"access_token\": \"eyJraWQiOiI2NldURFJVM1paSkNZVFJVVlZTUUw3WEJOIiwiYWxnIjoiSFMyNTYifQ.eyJqdGkiOiI2Q01BQ2lRZ1RualUxZTRCcG96QnhhIiwiaWF0IjoxNDQ5Njk1MjIzLCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8xaDcyUEZXb0d4SEtoeXNLallJa2lyIiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy80V0NDdGMwb0NSRHpRZEFIVlFUcWp6IiwiZXhwIjoxNDQ5Njk3MDIzLCJydGkiOiI2Q01BQ2Y2YlpEUVZPb3lLZFo3dkxXIn0.iiETVSG6Fn7vM8K2nG1c7yNoK6AyqOIUAabV-vnR1Z4\",\n *   \"expires_in\": 1800\n * }\n */\n\n/**\n * @typedef {Object} Jwt\n *\n * @description\n *\n * This type is provied by the {@link https://github.com/jwtk/njwt nJwt} library,\n * this type is an object that represents a Json Web Token, allowing you to\n * inspect it's claims.\n */\n\n/**\n * @constructor\n *\n * @description\n *\n * Encapsulates the access token response from an application's `/oauth/token`\n * endpoint.  This is a base class which is extended by\n * {@link OAuthPasswordGrantAuthenticationResult} and {@link OAuthClientCredentialsAuthenticationResult}.\n *\n * @param {Application} application\n * The Stormpath Application that issued the tokens.\n *\n * @param {AccessTokenResponse} accessTokenResponse\n * The access token response from the Stormpath REST API.\n */\nfunction JwtAuthenticationResult(application,data) {\n  if (!(this instanceof JwtAuthenticationResult)) {\n    return new JwtAuthenticationResult(application,data);\n  }\n\n  /**\n   * @name JwtAuthenticationResult#stormpathAccessTokenHref\n   *\n   * @description The HREF of the {@link AccessToken} resource.\n   *\n   * @type {String}\n   */\n\n  /*\n    Take all the properties of the data response, and put them\n    on this object - but convert underscores to camelcase because\n    that's the node way bro.\n   */\n  Object.keys(data).reduce(function(a,key){\n    var newKey = key.replace(/_([A-Za-z])/g, function (g) { return g[1].toUpperCase(); });\n    a[newKey] = data[key];\n    return a;\n  },this);\n\n  /*\n    Assign application after the key reduction above,\n    otherwise it will get replaced with the object literal\n    from the response data.\n   */\n  this.application = application;\n  var apiKey = application.dataStore.requestExecutor.options.client.apiKey;\n\n  /**\n   * @name JwtAuthenticationResult#accessToken\n   *\n   * @description\n   *\n   * An object that allows you to inspect the body, claims, and header of the\n   * access token.\n   *\n   * @type {Jwt}\n   */\n\n  if(this.accessToken){\n    this.accessToken = nJwt.verify(this.accessToken, apiKey.secret);\n    this.account = {\n      href: this.accessToken.body.sub\n    };\n  }\n\n  /**\n   * @name JwtAuthenticationResult#refreshToken\n   *\n   * @description\n   *\n   * An object that allows you to inspect the body, claims, and header of the\n   * refresh token.  Note:  the `client_credentials` workflow does not use\n   * refresh tokens.\n   *\n   * @type {Jwt}\n   */\n\n  if(this.refreshToken){\n    this.refreshToken = nJwt.verify(this.refreshToken, apiKey.secret);\n  }\n}\n\nJwtAuthenticationResult.prototype.account = null;\n\nJwtAuthenticationResult.prototype.jwt = null;\n\nJwtAuthenticationResult.prototype.expandedJwt = null;\n\n/**\n * @function\n *\n * @description Get the account resource of the account that has authenticated.\n *\n * @param {ExpansionOptions} options\n * Options for expanding the fetched {@link Account} resource.\n *\n * @param  {Function} callback\n * The callback to call with the parameters (err, {@link Account}).\n */\nJwtAuthenticationResult.prototype.getAccount = function getAccount(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  // Workaround because I don't have access to a stormpath client.\n  this.application.dataStore.getResource(this.account.href, args.options, require('../resource/Account'), args.callback);\n};\n\nmodule.exports = JwtAuthenticationResult;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/scope-factory-authenticator.js":"'use strict';\n\nvar njwt = require('njwt');\n\n/**\n * @class\n *\n * @description\n * Encapsulates the behavior required by OAuth authenticator classes for adding\n * scope to access tokens that are created by Stormpath.\n *\n * This class allows you to add custom scope to Stormpath tokens by providing scope\n * factory functions.  Adding custom scope is useful if you want to do stateless\n * access control checks with a JWT scope property.\n *\n * This class should not be constructed manually. Instead, the following classes\n * inherit from this class and can use the scope factory behavior:\n *\n * * {@link OAuthClientCredentialsAuthenticator}\n * * {@link OAuthPasswordGrantRequestAuthenticator}\n * * {@link OAuthStormpathSocialAuthenticator}\n * * {@link OAuthStormpathTokenAuthenticator}\n * @example\n * <caption>Adding a user's groups to the token as scope</caption>\n *\n * var application; // An application, fetched from Client.getApplication()\n *\n * function groupScopeFactory(authenticationResult, requestedScope, callback) {\n *   authenticationResult.getAccount({expand: 'groups'}, function(err, account) {\n *     if (err) {\n *       return callback(err);\n *     }\n *\n *     var grantedScope = account.groups.items.map(function(group) {\n *       return group.name;\n *     }).join(' ');\n *\n *     callback(null, grantedScope);\n *   });\n * }\n *\n * var authenticator = new stormpath.OAuthPasswordGrantRequestAuthenticator(application);\n *\n * authenticator.setScopeFactory(groupScopeFactory);\n * authenticator.setScopeFactorySigningKey(tenantApiKeySecret); // Same secret that was given to the previously used client\n *\n * var passwordGrantRequest = {\n *   username: 'user@example.com',\n *   password: 'PAs$w0rd',\n * }\n *\n * authenticator.authenticate(passwordGrantRequest, function (err, oAuthPasswordGrantAuthenticationResult) {\n *   if (err) {\n *     return console.log(err);\n *   }\n *   console.log('Access token: ', oAuthPasswordGrantAuthenticationResult.accessToken)\n * });\n */\nfunction ScopeFactoryAuthenticator() {}\n\n/**\n * @function\n *\n * @description\n * Sets the scope factory to be used when parsing tokens.  The scope factory is a\n * developer-provided function that allows you to add custom scope to the tokens\n * that Stormpath creates.  For an example, see {@link ScopeFactoryAuthenticator}.\n *\n * @param {Function} scopeFactory\n * The scope factory to use when processing authentication results. When it is defined,\n * it will be invoked with the authentication result.  You should determine which scope\n * to grant, and provide it to the callback.\n *\n * The function must have the signature `(authenticationResult, requestedScope, callback)`.\n *\n * * `authenticationResult` is the authentication result from the authenticator's\n * authentication result class.  You can use this to fetch the account that has\n * authenticated.\n *\n * * `requestedScope` is the end-user requested scope that you passed as the\n * `scope` option when calling the authenticator's `authenticate()` method.\n *\n * * `callback` should be called with `(err, <String> grantedScope)` after you determine\n * which scope to grant to the user.  The scope will be added to the JWT as the\n * `scope` claim.  The granted scope must be a string value.\n */\nScopeFactoryAuthenticator.prototype.setScopeFactory = function setAuthenticatorScopeFactory(scopeFactory) {\n  this.scopeFactory = scopeFactory;\n};\n\n/**\n * @function\n *\n * @description\n * Sets the signing that is used to sign the new access token.\n *\n * @param {String} signingKey\n * Signing key used to pack and unpack JWTs. It is <b>required</b> if the scope\n * factory is set. If the factory is invoked without a signing key, an error will\n * be passed to the callback.\n *\n * This must be the same Tenant API Key Secret that you used to create the {@link Client}\n * that was used to initiate the authentication attempt.\n */\nScopeFactoryAuthenticator.prototype.setScopeFactorySigningKey = function setSigningKey(signingKey) {\n  this.signingKey = signingKey;\n};\n\n/**\n * @function\n *\n * @private\n *\n * @description\n * Constructs results from OAuth authentication responses, optionally adding scope parameters\n * to these results. Determines whether scope should be added and validates the parameters.\n *\n * The function is to be invoked only if the request was successful.\n *\n * @param {Application} application Stormpath application the authentication result attaches to\n *\n * @param {Object} formData Authentication request data\n *\n * @param {Object} responseData The authentication result the API responded with.\n *\n * @param {Constructor} Ctor\n * The constructor for the result instance to wrap the API response with, should\n * inherit from {@link JwtAuthenticationResult}\n *\n * @param {Function} callback\n * Callback function, will be called with (err, Ctor), where Ctor is the instance\n * passed as the argument.\n */\nScopeFactoryAuthenticator.prototype.scopeAuthResult = function scopeAuthenticatorResult(application, formData, responseData, Ctor, callback) {\n  var self = this;\n\n  if (typeof this.scopeFactory === 'undefined') {\n    return callback(null, new Ctor(application, responseData));\n  }\n\n  if (typeof this.signingKey === 'undefined') {\n    callback(new Error('Signing key required for expanding the authentication result token through scope factories. Please use `setSigningKey` first'));\n  }\n\n  njwt.verify(responseData.access_token, this.signingKey, function(err, token) {\n    if (err) {\n      return callback(err);\n    }\n\n    var responseInstance = new Ctor(application, responseData);\n\n    self.scopeFactory(responseInstance, formData.scope, function(err, grantedScope) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (grantedScope) {\n        token.body.scope = grantedScope;\n        token.setSigningKey(self.signingKey);\n\n        responseData.access_token = token.compact();\n        responseInstance = new Ctor(application, responseData);\n      }\n\n      callback(null, responseInstance);\n    });\n  });\n};\n\nmodule.exports = ScopeFactoryAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/refresh-grant.js":"'use strict';\n\nvar util = require('util');\n\nvar JwtAuthenticationResult = require('../jwt/jwt-authentication-result');\n\n/**\n * @class\n *\n * @augments {JwtAuthenticationResult}\n *\n * @description\n *\n * Encapsulates the access token response from an application's `/oauth/token`\n * endpoint, when making a `refresh_token` grant request. This class allows you\n * to access the response data and get the account that was authenticated.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link OAuthRefreshTokenGrantAuthenticator#authenticate OAuthRefreshTokenGrantAuthenticator.authenticate()}.\n *\n * @param {Application} application\n * The Stormpath Application that issued the tokens.\n *\n * @param {AccessTokenResponse} accessTokenResponse\n * The access token response from the Stormpath REST API.\n *\n */\nfunction OAuthRefreshTokenGrantAuthenticationResult(application,data){\n  if (!(this instanceof OAuthRefreshTokenGrantAuthenticationResult)) {\n    return new OAuthRefreshTokenGrantAuthenticationResult(application,data);\n  }\n\n  OAuthRefreshTokenGrantAuthenticationResult.super_.apply(this, arguments);\n  this.accessTokenResponse = data;\n}\n\nutil.inherits(OAuthRefreshTokenGrantAuthenticationResult, JwtAuthenticationResult);\n\n/**\n * @class\n *\n * @constructor\n *\n * @description\n *\n * Creates an authenticator that can exchange an existing {@link RefreshToken}\n * for a new {@link AccessToken}.\n *\n * @param {Application} application\n * The Stormpath Application to authenticate against, this should be the same\n * application that was used when the Refresh Token was created.\n *\n * @example\n * var appHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * client.getApplication(appHref, function (err, application) {\n *   var authenticator = new stormpath.OAuthRefreshTokenGrantAuthenticator(application);\n * });\n */\nfunction OAuthRefreshTokenGrantAuthenticator(application) {\n  if (!(this instanceof OAuthRefreshTokenGrantAuthenticator)) {\n    return new OAuthRefreshTokenGrantAuthenticator(application);\n  }\n\n  this.application = application;\n}\n\n/**\n * Exchange the Refresh Token for a new Access Token\n *\n * @param {Object} tokenRequest\n * An object to encapsulate the request.\n *\n * @param {String} tokenRequest.refresh_token\n * The Refresh Token, this is a compacted JWT string.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link OAuthRefreshTokenGrantAuthenticationResult}).\n *\n * @example\n *\n * var tokenRequest = {\n *   refresh_token: 'eyJraWQiOiI2NldURFJVM1paSkNZVFJVVlZTUUw3WEJOIiwic3R0IjoicmVmcmVzaCIsImFsZyI6IkhTMjU2In0.eyJqdGkiOiI1UDNSMTh6RUVveXlUTkszZTQ1YVVlIiwiaWF0IjoxNDcwMjY4MDcyLCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8yNGs3SG5ET3o0dFE5QVJzQnRQVU42Iiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy8yRWRHb3htbGpuODBlRHZjM0JzS05EIiwiZXhwIjoxNDcwMzU0NDcyfQ.P0nswcR4FgHxYILZZP8uqwGGzI3Jym5Co8YkntYjoTI'\n * };\n *\n * authenticator.authenticate(tokenRequest, function(err, oAuthRefreshTokenGrantAuthenticationResult) {\n *   oAuthRefreshTokenGrantAuthenticationResult.getAccount(function(err, account){\n *     console.log(\n *      'The new access token for ' + account.email + ' is: ' +\n *      oAuthRefreshTokenGrantAuthenticationResult.accessTokenResponse.access_token\n *     );\n *   });\n * });\n */\nOAuthRefreshTokenGrantAuthenticator.prototype.authenticate = function authenticate(data,callback) {\n  var application = this.application;\n  if(arguments.length !==2 ){\n    throw new Error('Must call authenticate with (data,callback)');\n  }else{\n    var href = application.href + '/oauth/token';\n    var formData = {\n      grant_type: 'refresh_token',\n      refresh_token: data.refresh_token\n    };\n    application.dataStore.createResource(href,{form:formData},function(err,data){\n      if(err){\n        return callback(err);\n      }\n      try {\n        callback(null,new OAuthRefreshTokenGrantAuthenticationResult(application,data));\n      } catch (err) {\n        callback(err);\n      }\n    });\n  }\n};\n\nmodule.exports = {\n  authenticator: OAuthRefreshTokenGrantAuthenticator,\n  authenticationResult: OAuthRefreshTokenGrantAuthenticationResult\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/id-site-grant.js":"'use strict';\n\nvar util = require('util');\nvar JwtAuthenticationResult = require('../jwt/jwt-authentication-result');\n\nfunction OAuthIdSiteTokenGrantAuthenticationResult(application, data){\n  OAuthIdSiteTokenGrantAuthenticationResult.super_.apply(this, arguments);\n  this.accessTokenResponse = data;\n}\nutil.inherits(OAuthIdSiteTokenGrantAuthenticationResult, JwtAuthenticationResult);\n\n/**\n * Deprecated, replaced by OAuthStormpathTokenAuthenticator.  Will be removed in 1.0.\n *\n * @private\n */\nfunction OAuthIdSiteTokenGrantAuthenticator(application) {\n  if (!(this instanceof OAuthIdSiteTokenGrantAuthenticator)) {\n    return new OAuthIdSiteTokenGrantAuthenticator(application);\n  }\n\n  this.application = application;\n}\n\nOAuthIdSiteTokenGrantAuthenticator.prototype.authenticate = util.deprecate(function authenticate(data, callback) {\n  var application = this.application;\n\n  var formData = {\n    grant_type: 'id_site_token',\n    token: data.id_site_token\n  };\n\n  var tokenHref = application.href + '/oauth/token';\n\n  application.dataStore.createResource(tokenHref, { form: formData }, function(err, tokenData) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new OAuthIdSiteTokenGrantAuthenticationResult(application, tokenData));\n  });\n},'OAuthIdSiteTokenGrantAuthenticator is deprecated. Use OAuthStormpathTokenAuthenticator instead.  See http://docs.stormpath.com/nodejs/api/oauthStormpathTokenAuthenticator');\n\nmodule.exports = {\n  authenticator: OAuthIdSiteTokenGrantAuthenticator,\n  authenticationResult: OAuthIdSiteTokenGrantAuthenticationResult\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/stormpath-token.js":"'use strict';\n\nvar util = require('../utils');\nvar JwtAuthenticationResult = require('../jwt/jwt-authentication-result');\nvar ScopeFactoryAuthenticator = require('./scope-factory-authenticator');\n\n/**\n * @class\n *\n * @augments {JwtAuthenticationResult}\n *\n * @description\n *\n * Encapsulates the access token response from an application's `/oauth/token`\n * endpoint, when making a `stormpath_token` grant request.\n *\n * This class allows you to access the response data and get the account\n * that was authenticated.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link OAuthStormpathTokenAuthenticator#authenticate OAuthStormpathTokenAuthenticator.authenticate()}.\n *\n * @param {Application} application\n * The Stormpath Application that issued the tokens.\n *\n * @param {AccessTokenResponse} accessTokenResponse\n * The access token response from the Stormpath REST API.\n *\n */\nfunction OAuthStormpathTokenAuthenticationResult(application, data){\n  OAuthStormpathTokenAuthenticationResult.super_.apply(this, arguments);\n  this.accessTokenResponse = data;\n}\n\nutil.inherits(OAuthStormpathTokenAuthenticationResult, JwtAuthenticationResult);\n\n/**\n * @class\n *\n * @augments ScopeFactoryAuthenticator\n *\n * @description\n *\n * Creates an authenticator that can be used to exchange a Stormpath Token for an\n * access token and refresh token pair.  A Stormpath Token is provided when a user\n * returns from ID Site, or from a SAML callback.  In either case, you may want\n * to exchange this token for a standard OAuth Access + Refresh token pair that\n * is bound to the authenticated account, and this authenticator will do that\n * for you.\n *\n * The authenticator is bound to a Stormpath Application, so the authentication\n * attempt will be bound to the account stores that are mapped to this application.\n * To configure the access and refresh token expiration times for the application,\n * see {@link OAuthPolicy}.\n *\n * @param {Application} application The Stormpath Application to authenticate against.\n *\n * @example\n * var appHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * client.getApplication(appHref, function(err, application) {\n *   var authenticator = new stormpath.OAuthStormpathTokenAuthenticator(application);*\n * });\n */\nfunction OAuthStormpathTokenAuthenticator(application) {\n  if (!(this instanceof OAuthStormpathTokenAuthenticator)) {\n    return new OAuthStormpathTokenAuthenticator(application);\n  }\n\n  OAuthStormpathTokenAuthenticator.super_.apply(this, arguments);\n\n  this.application = application;\n}\n\nutil.inherits(OAuthStormpathTokenAuthenticator, ScopeFactoryAuthenticator);\n\n/**\n * Exchange the Stormpath Token for an Access and Refresh token.\n *\n * @param {Object} tokenRequest\n * An object to encapsulate the request.\n *\n * @param {String} tokenRequest.stormpath_token\n * The Stormpath Token, from the ID Site or SAML callback.  This is a compacted JWT string.\n *\n * @param {String} [tokenRequest.scope]\n * User-requested scope that will be passed to the scope factory, if configured.\n * See {@link ScopeFactoryAuthenticator} for more details.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link OAuthStormpathTokenAuthenticationResult}).\n *\n * @example\n *\n * var tokenRequest = {\n *   token: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIzRHZNZ2JOVFEwZkhuS3BHd1VHUlB4IiwiaWF0IjoxNDcwMjU4MDc0LCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8yNGs3SG5ET3o0dFE5QVJzbVZ6YUNJIiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy8xdWxlM3dKbkxZVUw3VVE2OGFBdlJaOWwiLCJleHAiOjE0NzAyNjk0MTJ9.i4OWcqczU-us71zT2XIiL69s2srJ7YPH5mAzrw8rNE8'\n * };\n *\n * authenticator.authenticate(tokenRequest, function(err, oAuthStormpathTokenAuthenticationResult) {\n *   oAuthStormpathTokenAuthenticationResult.getAccount(function(err, account){\n *     console.log(\n *      'The access token for ' + account.email + ' is: ' +\n *      oAuthStormpathTokenAuthenticationResult.accessTokenResponse.access_token\n *     );\n *   });\n * });\n *\n */\nOAuthStormpathTokenAuthenticator.prototype.authenticate = function authenticate(data, callback) {\n  var application = this.application;\n  var self = this;\n\n  if (typeof data !== 'object') {\n    throw new Error('The \\'data\\' parameter must be an object.');\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('The \\'callback\\' parameter must be a function.');\n  }\n\n  var formData = {\n    grant_type: 'stormpath_token',\n    token: data.stormpath_token\n  };\n\n  var scopeFactoryData = util.extend({}, formData, {scope: data.scope});\n\n  var tokenHref = application.href + '/oauth/token';\n\n  application.dataStore.createResource(tokenHref, { form: formData }, function(err, tokenData) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.scopeAuthResult(application, scopeFactoryData, tokenData, OAuthStormpathTokenAuthenticationResult, callback);\n  });\n};\n\nmodule.exports = {\n  authenticator: OAuthStormpathTokenAuthenticator,\n  authenticationResult: OAuthStormpathTokenAuthenticationResult\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/client-credentials.js":"'use strict';\n\nvar util = require('../utils');\nvar JwtAuthenticationResult = require('../jwt/jwt-authentication-result');\nvar ScopeFactoryAuthenticator = require('./scope-factory-authenticator');\n\n/**\n * @class\n *\n * @augments {JwtAuthenticationResult}\n *\n * @description\n *\n * Encapsulates the access token response from an application's `/oauth/token`\n * endpoint, when making a `client_credentials` grant request. This class allows you to\n * access the response data and get the access token and account that was authenticated.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link OAuthClientCredentialsAuthenticator#authenticate OAuthClientCredentialsAuthenticator.authenticate()}.\n *\n * @param {Application} application\n * The Stormpath Application that issued the tokens.\n *\n * @param {AccessTokenResponse} accessTokenResponse\n * The access token response from the Stormpath REST API.\n *\n */\nfunction OAuthClientCredentialsAuthenticationResult(application, accessTokenResponse) {\n  if (!(this instanceof OAuthClientCredentialsAuthenticationResult)) {\n    return new OAuthClientCredentialsAuthenticationResult(application, accessTokenResponse);\n  }\n\n  OAuthClientCredentialsAuthenticationResult.super_.apply(this, arguments);\n\n  /**\n   * The access token response from the Stormpath REST API.\n   *\n   * @name OAuthClientCredentialsAuthenticationResult#accessTokenResponse\n   *\n   * @type {AccessTokenResponse}\n   */\n  this.accessTokenResponse = accessTokenResponse;\n\n  /**\n   * @name OAuthClientCredentialsAuthenticationResult#refreshToken\n   *\n   * @description\n   *\n   * Hidden\n   *\n   * @private\n   */\n}\n\nutil.inherits(OAuthClientCredentialsAuthenticationResult, JwtAuthenticationResult);\n\n/**\n * @function\n *\n * @description\n * Get the access token resource for the authenticated account.\n *\n * @param {Function} callback\n * The callback to call with the parameters (err, {@link AccessToken})\n */\nOAuthClientCredentialsAuthenticationResult.prototype.getAccessToken = function getAccessToken(callback) {\n  var href = this.accessTokenResponse.stormpath_access_token_href;\n\n  this.application.dataStore.getResource(href, require('../resource/AccessToken'), callback);\n};\n\n/**\n * @class\n *\n * @augments ScopeFactoryAuthenticator\n *\n * @description\n *\n * Creates an authenticator that can be used to exchange a client api key for an access token.\n * To configure the access token expiration times for the application, see {@link OAuthPolicy}.\n * The authenticator is bound to a Stormpath Application, so the authentication attempt will\n * be bound to the account stores that are mapped to this application.\n *\n * @param {Application} application The Stormpath Application to authenticate against.\n *\n * @example\n * var appHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * client.getApplication(appHref, function(err, application) {\n *   var authenticator = new stormpath.OAuthClientCredentialsAuthenticator(application);\n * });\n */\nfunction OAuthClientCredentialsAuthenticator(application) {\n  if (!(this instanceof OAuthClientCredentialsAuthenticator)) {\n    return new OAuthClientCredentialsAuthenticator(application);\n  }\n\n  OAuthClientCredentialsAuthenticator.super_.apply(this, arguments);\n\n  this.application = application;\n\n}\n\nutil.inherits(OAuthClientCredentialsAuthenticator, ScopeFactoryAuthenticator);\n\n/**\n * Formats and validates the object wrapping the api key into the format accepted by\n * the REST API and attaches the grant_type parameter to the form data.\n *\n * @private\n */\nOAuthClientCredentialsAuthenticator.prototype._formatRequestBody = function _formatRequestBody(formData) {\n  if (!formData || !formData.apiKey) {\n    throw new Error('apiKey object within request is required');\n  }\n\n  if (!formData.apiKey.id || !formData.apiKey.secret) {\n    throw new Error('apiKey object must contain \\'id\\' and \\'secret\\' fields');\n  }\n\n  return {\n    client_id: formData.apiKey.id,\n    client_secret: formData.apiKey.secret,\n    grant_type: 'client_credentials'\n  };\n};\n\n/**\n * @function\n *\n * @param {Object} clientCredentialsRequest\n * An object with the client credentials grant request properties.\n *\n * @param {Object} clientCredentialsRequest.apiKey\n * The api key object of the account that is attempting to authenticate.\n *\n * @param {String} clientCredentialsRequest.apiKey.id\n * The client id for the api key for the account that is attempting to authenticate.\n *\n * @param {String} clientCredentialsRequest.apiKey.secret\n * The client secret for the api key for the account that is attempting to authenticate.\n *\n * @param {String} [clientCredentialsRequest.scope]\n * User-requested scope that will be passed to the scope factory, if configured.\n * See {@link ScopeFactoryAuthenticator} for more details.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link OAuthClientCredentialsAuthenticationResult}).\n *\n * @example\n *\n * var clientCredentialsRequest = {\n *   apiKey: {\n *    id: 'WuQvJFCj+MNHy/MldQp/dVu9WjCc7EYl0yjR7fUp2ym',\n *    secret: '7HB3CD9YN5YXKFWRQEUIPMGZ1'\n *   };\n * };\n *\n * authenticator.authenticate(clientCredentialsRequest, function(err, oAuthClientCredentialsAuthenticationResult) {\n *   oAuthClientCredentialsAuthenticationResult.getAccount(function(err, account){\n *     console.log(\n *      oAuthClientCredentialsAuthenticationResult.accessTokenResponse.access_token\n *     );\n *   });\n * });\n *\n */\nOAuthClientCredentialsAuthenticator.prototype.authenticate = function authenticate(authenticationRequest, callback) {\n  var application = this.application;\n  var self = this;\n\n  if (typeof authenticationRequest !== 'object') {\n    throw new Error('The \\'authenticationRequest\\' parameter must be an object.');\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('The \\'callback\\' parameter must be a function.');\n  }\n\n  var href = application.href + '/oauth/token';\n  var apiData = this._formatRequestBody(authenticationRequest);\n  var scopeFactoryData = util.extend({}, apiData, {scope: authenticationRequest.scope});\n\n  application.dataStore.createResource(href, {form: apiData}, function(err, tokenData) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.scopeAuthResult(application, scopeFactoryData, tokenData, OAuthClientCredentialsAuthenticationResult, callback);\n  });\n};\n\nmodule.exports = {\n  authenticator: OAuthClientCredentialsAuthenticator,\n  authenticationResult: OAuthClientCredentialsAuthenticationResult\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/stormpath-social.js":"'use strict';\n\nvar util = require('util');\nvar JwtAuthenticationResult = require('../jwt/jwt-authentication-result');\nvar ScopeFactoryAuthenticator = require('./scope-factory-authenticator');\n\n/**\n * @class\n *\n * @augments {JwtAuthenticationResult}\n *\n * @description\n *\n * Encapsulates the access token response from an application's `/oauth/token`\n * endpoint, when making a `stormpath_social` grant request.\n *\n * This class allows you to access the response data and get the account\n * that was authenticated.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link OAuthStormpathSocialAuthenticator#authenticate OAuthStormpathSocialAuthenticator.authenticate()}.\n *\n * @param {Application} application\n * The Stormpath Application that you want tokens issued for.\n *\n * @param {AccessTokenResponse} accessTokenResponse\n * The access token response from the Stormpath REST API.\n *\n */\nfunction OAuthStormpathSocialAuthenticationResult(application, data){\n  OAuthStormpathSocialAuthenticationResult.super_.apply(this, arguments);\n  this.accessTokenResponse = data;\n}\nutil.inherits(OAuthStormpathSocialAuthenticationResult, JwtAuthenticationResult);\n\n/**\n * @class\n *\n * @augments ScopeFactoryAuthenticator\n *\n * @description\n *\n * Creates an authenticator that can be used to exchange an authorization code or access token, obtained from\n * a social provider, for a Stormpath Access Token and Refresh Token.  The new tokens will be issued by the\n * given Stormpath Application.\n *\n * The authenticator is bound to the Stormpath Application, so the authentication\n * attempt will be bound to the account stores that are mapped to this application.\n * To configure the access and refresh token expiration times for the application,\n * see {@link OAuthPolicy}.\n *\n * @param {Application} application The Stormpath Application to authenticate against.\n *\n * @example\n * var appHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * client.getApplication(appHref, function(err, application) {\n *   var authenticator = new stormpath.OAuthStormpathSocialAuthenticator(application);\n * });\n */\nfunction OAuthStormpathSocialAuthenticator(application) {\n  if (!(this instanceof OAuthStormpathSocialAuthenticator)) {\n    return new OAuthStormpathSocialAuthenticator(application);\n  }\n\n  this.application = application;\n}\n\nutil.inherits(OAuthStormpathSocialAuthenticator, ScopeFactoryAuthenticator);\n\n/**\n * Exchange an authorization code or access token, provided by a social provier, for a Stormpath Access Token and Refresh token.\n *\n * @param {Object} authenticationRequest\n * An object to encapsulate the request.  One of `accessToken` or `code` must be\n * provided.\n *\n * @param {String} authenticationRequest.providerId\n * The identity of the provider that provided the code or access token, e.g. `facebook`, `google`, `github`, `linkedin`.\n *\n * @param {String} [authenticationRequest.accessToken]\n * The access token, obtained from the provider.\n *\n * @param {String} [authenticationRequest.code]\n * The authorization code, obtained from the provider.\n *\n * @param {String} [authenticationRequest.scope]\n * User-requested scope that will be passed to the scope factory, if configured.\n * See {@link ScopeFactoryAuthenticator} for more details.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link OAuthStormpathSocialAuthenticationResult}).\n *\n * @example\n *\n * // Authorization Code example, with code obtained from Google login callback\n *\n * var authenticationRequest = {\n *   providerId: 'google',\n *   code: '5LvvqjEJl9zhoAbkNj9vFUgOBsePjpm7XY'\n * };\n *\n * authenticator.authenticate(authenticationRequest, function(err, authResult) {\n *   authResult.getAccount(function(err, account){\n *     console.log('The access token for %s is %s', account.email, authResult.accessTokenResponse.access_token);\n *   });\n * });\n *\n * @example\n *\n * // Access Token example, with code obtained from Facebook login pop-up\n *\n * var authenticationRequest = {\n *   providerId: 'facebook',\n *   accessToken: 'Sb8BvqbpxxzqjEJl9QlzKDfxfdf2d5d1NMerEAHPMqYfeoZB0CIimgBhk1DK6KFZAOF5xJB6grrrgcuOZAnekyxxURTsPaiIQ9exmzv'\n * };\n *\n * authenticator.authenticate(authenticationRequest, function(err, authResult) {\n *   authResult.getAccount(function(err, account){\n *     console.log('The access token for %s is %s', account.email, authResult.accessTokenResponse.access_token);\n *   });\n * });\n */\nOAuthStormpathSocialAuthenticator.prototype.authenticate = function authenticate(authenticationRequest, callback) {\n  var application = this.application;\n\n  if (typeof authenticationRequest !== 'object') {\n    throw new Error('The \\'authenticationRequest\\' parameter must be an object.');\n  }\n\n  if (typeof authenticationRequest.providerId !== 'string') {\n    throw new Error('The \\'authenticationRequest.providerId\\' parameter must be a string.');\n  }\n\n  if (!authenticationRequest.code && !authenticationRequest.accessToken) {\n    throw new Error('One of the parameters \\'authenticationRequest.code\\' or \\'authenticationRequest.accessToken\\' must be provided.');\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('The \\'callback\\' parameter must be a function.');\n  }\n\n  var formData = {\n    grant_type: 'stormpath_social',\n    providerId: authenticationRequest.providerId,\n    code: authenticationRequest.code,\n    accessToken: authenticationRequest.accessToken\n  };\n\n  var tokenHref = application.href + '/oauth/token';\n\n  application.dataStore.createResource(tokenHref, { form: formData }, function(err, tokenData) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new OAuthStormpathSocialAuthenticationResult(application, tokenData));\n  });\n};\n\nmodule.exports = {\n  authenticator: OAuthStormpathSocialAuthenticator,\n  authenticationResult: OAuthStormpathSocialAuthenticationResult\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/ApiKey.js":"'use strict';\n\nvar utils = require('../utils');\n\nfunction ApiKey(id, secret) {\n  this.id = id;\n  this.secret = secret;\n}\nutils.inherits(ApiKey, Object);\n\nApiKey.prototype.toString = function apiKeyToString() {\n  return 'id: ' + this.id + ', secret: <hidden>';\n};\n\nmodule.exports = ApiKey;\n\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/ApiKeyLoader.js":"'use strict';\n\nvar propsParser = require('properties-parser');\n\nvar _ = require('../underscore');\nvar ApiKey = require('./ApiKey');\n\nvar FILE_URL_PREFIX = 'file://';\nvar DEFAULT_ID_PROP_NAME = 'apiKey.id';\nvar DEFAULT_SECRET_PROP_NAME = 'apiKey.secret';\n\nfunction loadFile(path, callback) {\n  return propsParser.read(path, function(err, props) {\n    if (err) {\n      return callback(new Error(\"Unable to read properties file '\" + path + \"': \" + err.message), null);\n    }\n\n    var apiKey = new ApiKey(props[DEFAULT_ID_PROP_NAME], props[DEFAULT_SECRET_PROP_NAME]);\n    return callback(null, apiKey);\n  });\n}\n\nfunction loadApiKey(path, callback) {\n  if (_(path).startsWith(FILE_URL_PREFIX)) {\n    path = path.substring(FILE_URL_PREFIX.length);\n  }\n  loadFile(path, callback);\n}\n\nmodule.exports = loadApiKey;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/underscore.js":"'use strict';\n\nvar _  = require('underscore');\n\n// Import Underscore.string to separate object, because there are conflict functions (include, reverse, contains)\n_.str = require('underscore.string');\n\n// Mix in non-conflict functions to Underscore namespace if you want\n_.mixin(_.str.exports());\n\n// All functions, include conflict, will be available through _.str object\n_.str.include('Underscore.string', 'string'); // => true\n\nmodule.exports = _;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/configLoader.js":"var path = require('path');\n\nvar stormpathConfig = require('stormpath-config');\nvar strategy = stormpathConfig.strategy;\n\n// Set the paths the we want to load configuration files from\nvar currentPath = process.cwd();\nvar stormpathPath = '~/.stormpath';\n\n// Create a default client config loader.\nmodule.exports = function (extendWithConfig) {\n  return new stormpathConfig.Loader([\n    // Load default configuration.\n    new strategy.LoadFileConfigStrategy(path.join(__dirname, '/config.yml'), true),\n\n    // Load API keys and configuration from home (.stormpath) folder\n    new strategy.LoadAPIKeyConfigStrategy(stormpathPath + '/apiKey.properties'),\n    new strategy.LoadFileConfigStrategy(stormpathPath + '/stormpath.json'),\n    new strategy.LoadFileConfigStrategy(stormpathPath + '/stormpath.yml'),\n\n    // Load API keys and configuration from app folder\n    new strategy.LoadAPIKeyConfigStrategy(currentPath + '/apiKey.properties'),\n    new strategy.LoadFileConfigStrategy(currentPath + '/stormpath.json'),\n    new strategy.LoadFileConfigStrategy(currentPath + '/stormpath.yml'),\n\n    // Load configuration from our environment.\n    new strategy.LoadEnvConfigStrategy('STORMPATH', {\n      // Aliases used to support legacy API key.\n      STORMPATH_APIKEY_ID: 'STORMPATH_API_KEY_ID',\n      STORMPATH_APIKEY_SECRET: 'STORMPATH_API_KEY_SECRET',\n      STORMPATH_APIKEY_FILE: 'STORMPATH_API_KEY_FILE'\n    }),\n\n    // Extend our configuration with the configuration we passed into the client.\n    // Also, try and load our API key if it was specified in our config.\n    new strategy.ExtendConfigStrategy(extendWithConfig),\n    new strategy.LoadAPIKeyFromConfigStrategy(),\n\n    // Enrich our client config.\n    new strategy.EnrichClientConfigStrategy(),\n\n    // Validate config so that we know that we have an API key and can continue...\n    new strategy.ValidateClientConfigStrategy()\n\n  ]);\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/Client.js":"'use strict';\n\nvar async = require('async');\nvar events = require('events');\n\nvar utils = require('./utils');\nvar DataStore = require('./ds/DataStore');\nvar FactorInstantiator = require('./resource/FactorInstantiator');\nvar FactorInstanceCtor = FactorInstantiator.Constructor;\nvar InvalidHrefError = require('./error/invalid-href');\nvar ObjectCallProxy = require('./proxy/ObjectCallProxy');\n\n/**\n * @typedef {Object} CacheOptions\n *\n * @type {Object}\n *\n * @description\n *\n * Instances of {@link Client} will cache Stormpath resources in your local\n * server, and this object allows you to configure the behavior of that cache.\n * Pass this object to the {@link Client} constructor as `clientOptions.cacheOptions`.\n * Examples are below the options table.\n *\n * @property {Object|String|Array} [connection]\n * If you are allowing this library to create a Redis or Memcached client for you\n * (you are specifying `store` but not providing a `client`), then use this option to\n * provide the database connection information to the relevant library.\n *\n * - For Memcached, this can be any format supported by\n *   [Memcached Sever Locations](https://github.com/3rd-Eden/memcached#server-locations).\n *\n * - For Redis, provide an object with the host and port options.\n *\n * @property {String} [connection.host=localhost]\n *\n * @property {Number} [connection.port=11211 | 6379]\n *\n * @property {Number} [tti=300]\n * (Seconds) The idle time of a cached resource. If it is not accessed within this time,\n * it will be purged.\n *\n * @property {Number} [ttl=300]\n * (Seconds) The max age of a cached resource. The resource will be purged after this time.\n *\n * @property {Object} [client]\n * An existing Redis or Memcached client instance. If not provided, one will\n * be created for you when you specify the `store` property.\n *\n * @property {Object} [options]\n * If you are allowing this library to create a Redis\n * or Memcached client for you (you are specifying `store` but not providing\n * a `client`), then use this option to pass options to the relevant client\n * constructor. For more information please see the documentation of those\n * libraries:\n *\n * - [Memcached options](https://github.com/3rd-Eden/memcached)\n * - [Node-Redis options](https://github.com/NodeRedis/node_redis)\n *\n * @property {String} [store]\n * The type of cache store to use, can be `redis` or `memcached`. If not specified,\n * an in-memory cache will be used for the duration of the Node process.\n *\n * @example <caption>Allow Stormpath to create a default Redis client for you:</caption>\n * var client = new stormpath.Client({\n *   cacheOptions: {\n *     store: 'redis'\n *   }\n * });\n *\n * @example <caption>Specify the connection information for the default client:</caption>\n * var client = new stormpath.Client({\n *   cacheOptions: {\n *     store: 'redis',\n *     connection: {\n *       host: 'localhost',\n *       port: 7777\n *     }\n *   }\n * });\n *\n * @example <caption>Provide your own Redis client:</caption>\n * var redisClient = redis.createClient();\n *\n * var client = new stormpath.Client({\n *   cacheOptions: {\n *     store: 'redis',\n *     client: redisClient\n *   }\n * });\n */\n\n/**\n * @typedef {Object} ClientOptions\n *\n * @type {Object}\n *\n * @description\n * This object allows you to configure the behavior of the {@link Client} and is\n * provided when creating a new {@link Client}.\n *\n * @property {Object} [apiKey]\n * An API Key Pair for your Tenant, see\n * [Create an API Key Pair](https://docs.stormpath.com/rest/product-guide/latest/quickstart.html#create-an-api-key-pair).\n *\n * @property {String} apiKey.id\n * The ID of the Tenant API Key Pair\n *\n * @property {String} apiKey.secret\n * The Secret of the Tenant API Key Pair\n *\n * @property {String} [baseUrl]\n * The base URL for the Stormpath REST API. Enterprise Cloud customers should specify `https://enterprise.stormpath.io/v1`.\n * Private deployments should use their custom base URL.\n *\n * @property {CacheOptions} [cacheOptions]\n * Cache configuration, see {@link CacheOptions}.\n *\n * @property {Object} [nonceStore]\n * If you are using the [ID Site Feature](https://docs.stormpath.com/rest/product-guide/latest/idsite.html)\n * in your Stormpath implementation, the calls to {@link Application#createIdSiteUrl\n * Application.createIdSiteUrl()} and {@link Application#handleIdSiteCallback\n * Application.handleIdSiteCallback()}\n * will make use of a nonce value to prevent replay attacks. By default these\n * nonces will be stored in a cache region in the client's data store.\n *\n * You may use your own Nonce Store by providing an interface object that we can\n * use to communicate with it. The object should be passed as this `nonceStore`\n * value, and it should have these two methods:\n *\n * - `getNonce(nonceStringValue,callback)` - It will search your nonce store for\n *   the nonce value and then call the callback with with the (err,value) pattern,\n *   where err indicates a problem with the store and value is the found nonce or null.\n * - `putNonce(nonceStringValue,callback)` - It should place the nonce value in\n *   your nonce store and then call the callback with (err) where err is a store\n *   error or null.\n */\n\n/**\n * @class\n *\n * @description\n *\n * A client is used to retrieve and update resources in the Stormpath REST API,\n * and is required before working with any functions of this library. To create\n * a client, you must provide an API Key Pair that has been provisioned for your\n * Tenant. To learn about provisioning these keys, please read\n * [Create an API Key Pair](https://docs.stormpath.com/rest/product-guide/latest/quickstart.html#create-an-api-key-pair).\n *\n * Once you have your API Key Pair, you need to supply the ID and Secret values\n * to the client constructor. This can be done one of three ways:\n *\n * - By passing them into the client constructor as the `clientOptions.apiKey`\n *   value.\n *\n * - By placing them in a `stormpath.yml` file, in the current working directory.\n *\n * - By providing these environment variables:\n *\n *  - `STORMPATH_CLIENT_API_KEY_ID`\n *  - `STORMPATH_CLIENT_API_KEY_SECRET`\n *\n * Each of these strategies is shown by example below. The API Key pair is just\n * one of several options in the {@link ClientOptions} object.\n *\n * @param {ClientOptions} [clientOptions]\n * An optional configuration object for configuring the client.\n *\n * @example <caption>If API Key Pair is available as environment variables, or stormpath.yml:</caption>\n *\n * // Assumes API keys are in environment variables, or stormpath.yaml\n *\n * var stormpath = require('stormpath');\n * var client = new stormpath.Client();\n *\n * @example <caption>If placing the API Key Pair in stormpath.yml, the file contents should look like this:</caption>\n * {@lang yaml}\n * client:\n *   apiKey:\n *     id: YOUR_API_KEY_ID\n *     secret: YOUR_API_KEY_SECRET\n *\n * @example <caption>If you want to pass the API Key Pair directly as configuration:</caption>\n *\n * var stormpath = require('stormpath');\n *\n * var client = new stormpath.Client({\n *   apiKey: {\n *     id: 'YOUR_API_KEY_ID',\n *     secret: 'YOUR_API_KEY_SECRET'\n *   }\n * });\n */\n\nfunction Client(config) {\n  var self = this;\n\n  // Call the constructor of the EventEmitter class -- this, allows us to\n  // initialize our Client object as an EventEmitter, and allows us to fire off\n  // events later on.\n  events.EventEmitter.call(self);\n\n  // We'll maintain this class variable as an in-memory singleton for caching\n  // purposes. We do this because Tenants never ever change once a Client has\n  // been initialized, so it makes sense to cache the Tenant object so we don't\n  // make unnecessary API requests if this object is looked up more than once.\n  self._currentTenant = null;\n\n  // Indicates whether or not this client is ready yet.\n  self._isReady = false;\n\n  // Setup how we load our configuration.\n  var configLoader = null;\n\n  // If the config is a config loader, then use that.\n  if (utils.isConfigLoader(config)) {\n    configLoader = config;\n  // Just use our default client config loader.\n  } else {\n    configLoader = require('./configLoader')(config);\n  }\n\n  // Setup our call proxy.\n  var awaitReadyProxy = new ObjectCallProxy(self);\n\n  // Attach our proxy so that all calls to our client is\n  // intercepted and queued until the client is ready.\n  awaitReadyProxy.attach(function(name) {\n    // Only proxy methods that start with either 'get' or 'create'.\n    return name.indexOf('get') === 0 || name.indexOf('create') === 0;\n  });\n\n  // Load our configuration.\n  process.nextTick(function() {\n    configLoader.load(function(err, loadedConfig) {\n      if (err) {\n        self.emit('error', err);\n        awaitReadyProxy.detach(new Error('Stormpath client initialization failed. See error log for more details.'));\n      } else {\n        self.config = loadedConfig;\n        self._dataStore = new DataStore(loadedConfig);\n        self._isReady = true;\n        awaitReadyProxy.detach();\n        self.emit('ready', self);\n      }\n    });\n  });\n}\n\n// By inheriting from `events.EventEmitter`, we're making our Client object a\n// true EventEmitter -- allowing us to fire off events.\nutils.inherits(Client, Object);\nutils.inherits(Client, events.EventEmitter);\n\n/**\n * Adds an event listener to the given event. The only supported event is\n * `ready`, which is broadcast when the client has finished asynchronous\n * construction (fetching preliminary resources such as the current {@link Tenant}).\n *\n * No checks are made to see if the listener has already been added.\n * Multiple calls passing the same combination of event and listener will result in the listener being added multiple times.\n *\n * @param {String} event\n * Name of event to listen on.\n *\n * @param {Function} listener\n * Function to call when event is emitted.\n */\nClient.prototype.on = function() {\n  var args = Array.prototype.slice.call(arguments);\n\n  // If we're running late to the party and the client has already\n  // emitted the ready event, then run the callback directly.\n  if (args.length === 2 && args[0] === 'ready' && typeof args[1] === 'function') {\n    var callback = args[1];\n    if (this._isReady) {\n      callback(this);\n      return this;\n    }\n  }\n\n  return events.EventEmitter.prototype.on.apply(this, args);\n};\n\n\n/**\n * Retrieves a {@link AccessToken} resource.\n *\n * @param {String} href\n * The href of the {@link AccessToken}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link AccessToken} during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link AccessToken}).\n *\n * @example\n * var href = \"https://api.stormpath.com/v1/accessTokens/3s7TiFXrobbQ0RU1Kb0IM5\";\n *\n * client.getAccessToken(href, function (err, accessToken) {\n *   console.log(accessToken);\n * });\n */\nClient.prototype.getAccessToken = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/accessTokens/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Access Token'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/AccessToken'), args.callback);\n};\n\nClient.prototype.getApiKeyById = function() {\n  var args = utils.resolveArgs(arguments, ['id', 'options', 'callback']);\n\n  var href = this.config.client.baseUrl + '/apiKeys/' + args.id;\n\n  return this.getResource(href, args.options, require('./resource/ApiKey'), args.callback);\n};\n\n/**\n * Retrieves a {@link RefreshToken} resource.\n *\n * @param {String} href\n * The href of the {@link RefreshToken}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link RefreshToken} during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link RefreshToken}).\n *\n * @example\n * var href = \"https://api.stormpath.com/v1/refreshTokens/25hgO2ZiuJHze14GzDtzof\";\n *\n * client.getAccessToken(href, function (err, refreshToken) {\n *   console.log(refreshToken);\n * });\n */\nClient.prototype.getRefreshToken = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/refreshTokens/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Refresh Token'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/RefreshToken'), args.callback);\n};\n\n/**\n * Get the {@link Tenant} resource of the currently authenticated tenant, as\n * identified by the API Key pair that was passed to the client constructor.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Tenant} resources during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Tenant}).\n */\nClient.prototype.getCurrentTenant = function() {\n  var self = this;\n\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  // First, we'll check to see if we've already cached the current tenant (since\n  // a Tenant never changes once a Client has been initialized). This prevents\n  // us from making unnecessary repeat API requests if this method is called\n  // multiple times.\n  if (self._currentTenant) {\n    return args.callback(null, self._currentTenant);\n  }\n\n  self._dataStore.getResource('/tenants/current', args.options, require('./resource/Tenant'), function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    self._currentTenant = tenant;\n\n    return args.callback(null, tenant);\n  });\n};\n\n/**\n * @private\n *\n * @callback getResourceCallback\n *\n * @param {Error} err\n * The error (if there is one).\n *\n * @param {Object} resource\n * The retrieved resource object.\n */\n\n/**\n * Retrieves a resource object by href.\n *\n * @private\n *\n * @param {String} href\n * The URI of the resource.\n *\n * @param {Object} [query]\n * Key/value pairs to use as query parameters.\n *\n * @param {Function} [constructor]\n * The constructor function that will be invoked when the given resource\n * is retrieved. E.g. Account, Directory, Group, etc. Defaults to `InstanceResource`.\n * If a resource returned from the API is a collection (not a single resource object),\n * then each returned object in the `items` array will be passed into this constructor\n * function and initialized.\n *\n * @param {getResourceCallback} callback\n * The callback that handles the response.\n */\nClient.prototype.getResource = function() {\n  return this._dataStore.getResource.apply(this._dataStore, arguments);\n};\n\n/**\n * @private\n *\n * @callback createResourceCallback\n *\n * @param {Error} err\n * The error (if there is one).\n *\n * @param {Object} resource\n * The created resource object.\n */\n\n/**\n * Creates a new resource object as a child of the specified parentHref\n * location. The parameter `parentHref` must be a collection resource endpoint.\n * This is a utility method we use internally to handle resource creation.\n *\n * @private\n *\n * @param {String} parentHref\n * The URI of the parent's collection resource.\n *\n * @param {Object} query\n * Key/value pairs to use as query parameters.\n *\n * @param {Function} constructor\n * The constructor function that will be invoked when the given resource is\n * retrieved. E.g. Account, Directory, Group, etc. Defaults to `InstanceResource`.\n * If a resource returned from the API is a collection (not a single resource object),\n * then each returned object in the `items` array will be passed into this\n * constructor function and initialized.\n *\n * @param {createResourceCallback} callback\n * The callback that handles the response.\n */\nClient.prototype.createResource = function() {\n  this._dataStore.createResource.apply(this._dataStore, arguments);\n};\n\n/**\n * Retrieves all the {@link Application} resources in the current {@link Tenant}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Application} objects.\n *\n * @example\n * client.getApplications(function (err, applicationCollection) {\n *   applicationCollection.each(function (application, next) {\n *     console.log(application);\n *     next();\n *   });\n * });\n */\nClient.prototype.getApplications = function() {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.getApplications(args.options, args.callback);\n  });\n};\n\n/**\n * Creates a new Application resource in the current {@link Tenant}.\n *\n * @param {Object} application\n * The {@link Application} resource to create.\n *\n * @param {Object} [requestOptions]\n * Query parameters for this request. These can be any of the {@link ExpansionOptions},\n * e.g. to retrieve linked resources of the {@link Application} during this request, or one\n * of the other options listed below.\n *\n * @param {Boolean|String} [requestOptions.createDirectory]\n * Set this to `true` to have a a new {@link Directory} automatically created along with the Application.\n * The generated Directory’s name will reflect the new Application’s name as best as is possible,\n * guaranteeing that it is unique compared to any of your existing Directories. If you would like\n * a different name, simply put the value you would like instead of `true`.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Application}).\n *\n * @example <caption>Create a new application.</caption>\n * var newApplication = {\n *   name: 'Todo Application'\n * }\n *\n * client.createApplication(newApplication, function (err, application) {\n *   console.log(application);\n * });\n *\n * @example <caption>Create a new application and new directory at the same time.</caption>\n *\n * var newApplication = {\n *   name: 'Todo Application'\n * };\n *\n * var options = {\n *   createDirectory: 'Primary Accounts'\n * };\n *\n * client.createApplication(newApplication, options, function(err, application) {\n *   console.log(err, application);\n * });\n */\nClient.prototype.createApplication = function() {\n  var args = utils.resolveArgs(arguments, ['app', 'options', 'callback']);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.createApplication(args.app, args.options, args.callback);\n  });\n};\n\n/**\n * Create multiple Application resources in the current {@link Tenant} with one SDK call.\n *\n * @param {Object[]} applications\n * An array of Application objects to create.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * Options to expand linked resources on the returned {@link Application} resources.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, applications), where `applications` is an array\n * of {@link Application} objects.\n *\n * @example\n * var newApplications = [\n *   {\n *     name: 'Todo Application'\n *   },\n *   {\n *     name: 'Notes Application'\n *   }\n * ]\n *\n * client.createApplications(newApplications, function (err, applications) {\n *   console.log(applications);\n * });\n */\nClient.prototype.createApplications = function() {\n  var args = utils.resolveArgs(arguments, ['apps', 'options', 'callback']);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    async.map(args.apps, function(app, cb) {\n      return tenant.createApplication(app, args.options, cb);\n    }, function(err, applications) {\n      return args.callback(err, applications);\n    });\n  });\n};\n\n/**\n * Retrieves all the {@link Account} resources in the current {@link Tenant}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Account} objects.\n *\n * @example\n * client.getAccounts(function (err, accountsCollection) {\n *   accountsCollection.each(function (account, next) {\n *     console.log(account);\n *     next();\n *   });\n * });\n */\nClient.prototype.getAccounts = function() {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.getAccounts(args.options, args.callback);\n  });\n};\n\n/**\n * Retrieves all the {@link Group} resources in the current {@link Tenant}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Group} objects.\n *\n * @example\n * client.getGroups(function (err, groupsCollection) {\n *   groupsCollection.each(function (group, next) {\n *     console.log(group);\n *     next();\n *   });\n * });\n */\nClient.prototype.getGroups = function() {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.getGroups(args.options, args.callback);\n  });\n};\n\n/**\n * Retrieves all the {@link Directory} resources in the current {@link Tenant}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Directory} objects.\n *\n * @example\n * client.getDirectories(function (err, directoryCollection) {\n *   directoryCollection.each(function (directory, next) {\n *     console.log(directory);\n *     next();\n *   });\n * });\n */\nClient.prototype.getDirectories = function() {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.getDirectories(args.options, args.callback);\n  });\n};\n\n/**\n * Creates a new {@link Directory} resource in the current {@link Tenant}. After\n * creating a directory, you will likely want to map it to an {@link Application} using\n * {@link Application#createAccountStoreMapping Application.createAccountStoreMapping()}.\n *\n * Directories can be linked to social providers - such as Facebook, Google, Twitter, or\n * even any other generic OAuth 2.0 provider - by specifing a valid provider containing\n * the valid `providerId` and client credentials when creating or modifying the directory.\n * See {@link Provider}.\n *\n * @param {Object} directory\n * The {@link Directory} resource to create.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * Options to expand linked resources on the returned {@link Directory}.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Directory}).\n *\n * @example\n * // Creating a simple directory\n * var newDirectory = {\n *   name: 'Customers'\n * }\n *\n * client.createDirectory(newDirectory, function (err, directory) {\n *   console.log(directory);\n * });\n *\n * // Creating a social provider directory (e.g. Twitter)\n * var twitterDirectory = {\n *   name: 'Twitter Users',\n *   provider: {\n *     providerId: 'twitter',\n *     clientId: 'my-twitter-client-id',\n *     clientSecret: 'my-twitter-client-secret'\n *   }\n * };\n *\n * client.createDirectory(twitterDirectory, function (err, directory) {\n *   console.log(directory);\n * });\n */\nClient.prototype.createDirectory = function() {\n  var args = utils.resolveArgs(arguments, ['dir', 'options', 'callback']);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.createDirectory(args.dir, args.options, args.callback);\n  });\n};\n\n/**\n * Create multiple {@link Directory} resources in the current {@link Tenant} with one SDK call.\n *\n * @param {Object[]} directories\n * An array of {@link Directory} objects to create.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * Options to expand linked resources on the returned {@link Directory} resources.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, directories), where `directories` is an array\n * of {@link Directory} objects.\n *\n * @example\n * var newDirectories = [\n *   {\n *     name: 'Administrators'\n *   },\n *   {\n *     name: 'Customers'\n *   }\n * ]\n *\n * client.createDirectories(newDirectories, function (err, directories) {\n *   console.log(directories);\n * });\n */\nClient.prototype.createDirectories = function() {\n  var args = utils.resolveArgs(arguments, ['dirs', 'options', 'callback']);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    async.map(args.dirs, function(dir, cb) {\n      return tenant.createDirectory(dir, args.options, cb);\n    }, function(err, directories) {\n      return args.callback(err, directories);\n    });\n  });\n};\n\n/**\n * Creates a new {@link Organization} resource in the current {@link Tenant}.\n * After creating a organization, you will likely want to map it to an {@link Application} using\n * {@link Application#createAccountStoreMapping Application.createAccountStoreMapping()}.\n *\n * @param {Object} organization\n * The {@link Organization} resource to create.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * Options to expand linked resources on the returned {@link Organization}.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Organization}).\n *\n * @example\n * var newOrganization = {\n *   name: 'Metal Works, Inc.'\n * }\n *\n * client.createOrganization(newOrganization, function (err, organization) {\n *   console.log(organization);\n * });\n */\nClient.prototype.createOrganization = function createOrganization() {\n  var args = utils.resolveArgs(arguments, ['data', 'options', 'callback']);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.createOrganization(args.data, args.options, args.callback);\n  });\n};\n\n/**\n * Creates a new SMTP server resource in the current {@link Tenant}.\n *\n * @param {Object} server\n * The {@link SmtpServer} resource to create.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * Options to expand linked resources on the returned {@link SmtpServer}.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link SmtpServer}).\n *\n * @example\n * var newSmtpServer = {\n *   name: 'My SMTP Server',\n *   username: 'server username',\n *   password: 'server password',\n *   host: 'email.example.com',\n *   securityProtocol: 'TLS',\n *   port: 25\n * };\n *\n * client.createSmtpServer(newSmtpServer, function (err, smtpServer) {\n *   console.log(smtpServer);\n * });\n */\nClient.prototype.createSmtpServer = function createSmtpServer() {\n  var args = utils.resolveArgs(arguments, ['server', 'options', 'callback']);\n\n  this.getCurrentTenant(function(err, tenant) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    return tenant.createSmtpServer(args.server, args.options, args.callback);\n  });\n};\n\n/**\n * Retrieves a {@link Account} resource.\n *\n * @param {String} href\n * The href of the {@link Account}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Account} during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Account}).\n *\n * @example\n *\n * var href = \"https://api.stormpath.com/v1/accounts/4WCCtc0oCRDzQdAHVQTqjz\";\n *\n * client.getAccount(href, function (err, account) {\n *   console.log(account);\n * });\n */\nClient.prototype.getAccount = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/accounts/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Account'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/Account'), args.callback);\n};\n\n/**\n * Retrieves a {@link Application} resource.\n *\n * @param {String} href\n * The href of the {@link Application}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Application} during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Application}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/applications/FOahc5HvwvfuAS03Yk2h1';\n *\n * client.getApplication(href, function (err, application) {\n *   console.log(application);\n * });\n */\nClient.prototype.getApplication = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/applications/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Application'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/Application'), args.callback);\n};\n\n/**\n * Retrieves a {@link Challenge} resource.\n *\n * @param {String} href\n * The href of the {@link Challenge}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Challenge} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Challenge}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/challenges/3nSC0LiyyPnewafzBzZOaL';\n *\n * client.getChallenge(href, function (err, challenge) {\n *   console.log(challenge);\n * });\n */\nClient.prototype.getChallenge = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n  return this.getResource(args.href, args.options, require('./resource/Challenge'), args.callback);\n};\n\n/**\n * Retrieves a {@link Directory} resource.\n *\n * @param {String} href\n * The href of the {@link Directory}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Directory} during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Directory}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/directories/1h72PFWoGxHKhysKjYIkir';\n *\n * client.getDirectory(href, function (err, directory) {\n *   console.log(directory);\n * });\n */\nClient.prototype.getDirectory = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/directories/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Directory'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/Directory'), args.callback);\n};\n\n/**\n * Retrieves a {@link Factor} resource.\n *\n * @param {String} href\n * The href of the {@link Factor}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Factor} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Factor}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/groups/3OEoLpN7csNUJ5J4hajWgX';\n *\n * client.getFactor(href, function (err, factor) {\n *   console.log(factor);\n * });\n */\nClient.prototype.getFactor = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n  return this.getResource(args.href, args.options, FactorInstanceCtor, args.callback);\n};\n\n/**\n * Retrieves a {@link Group} resource.\n *\n * @param {String} href\n * The href of the {@link Group}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Group} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Group}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/groups/3OEoLpN7csNUJ5J4hajWgX';\n *\n * client.getGroup(href, function (err, group) {\n *   console.log(group);\n * });\n */\nClient.prototype.getGroup = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/groups/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Group'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/Group'), args.callback);\n};\n\n/**\n * Retrieves a {@link GroupMembership} resource.\n *\n * @param {String} href\n * The href of the {@link GroupMembership}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link GroupMembership} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link GroupMembership}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/groupMemberships/5gtaYz1b8CJ0erODEUlm8l';\n *\n * client.getGroup(href, function (err, groupMembership) {\n *   console.log(groupMembership);\n * });\n */\nClient.prototype.getGroupMembership = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/groupMemberships/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Group Membership'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/GroupMembership'), args.callback);\n};\n\n/**\n * Retrieves a {@link Organization} resource.\n *\n * @param {String} href The href of the {@link Organization}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Organization} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Organization}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/organizations/3UOCEVEzR8uVRkhGdGP0A5';\n *\n * client.getOrganization(href, function (err, organization) {\n *   console.log(organization);\n * });\n */\nClient.prototype.getOrganization = function getOrganization() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n\n  if (!utils.isValidHref(args.href, '/organizations/')) {\n    return args.callback(new InvalidHrefError(args.href, 'Organization'));\n  }\n\n  return this.getResource(args.href, args.options, require('./resource/Organization'), args.callback);\n};\n\n/**\n * Retrieves all the {@link Organization} resources in the current {@link Tenant}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Organization} objects.\n *\n * @example\n * client.getOrganizations(function (err, organizationCollection) {\n *   organizationCollection.each(function (organization, next) {\n *     console.log(organization);\n *     next();\n *   });\n * });\n */\nClient.prototype.getOrganizations = function getOrganizations(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.getCurrentTenant(function onGetCurrentTenantForGroups(err, tenant) {\n    if (err) {\n      return args.callback(err, null);\n    }\n    return tenant.getOrganizations(args.options, args.callback);\n  });\n};\n\n/**\n * Retrieves a {@link Phone} resource.\n *\n * @param {String} href\n * The href of the {@link Phone}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Phone} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Phone}).\n *\n * @example\n * var href = 'https://api.stormpath.com/v1/phones/l0z3tFiTksNZrGlV9PjB2';\n *\n * client.getPhone(href, function (err, phone) {\n *   console.log(phone);\n * });\n */\nClient.prototype.getPhone = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n  return this.getResource(args.href, args.options, require('./resource/Phone'), args.callback);\n};\n\n/**\n * Retrieves all the {@link IdSiteModel} resources for the current {@link Tenant}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link IdSiteModel} objects.\n *\n * @example\n * client.getIdSites(function (err, idSiteModels) {\n *   idSiteModels.each(function (idSiteModel, next) {\n *     console.log(idSiteModel);\n *     next();\n *   })\n * });\n */\nClient.prototype.getIdSites = function getIdSites(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.getCurrentTenant(function onGetCurrentTenant(err, tenant) {\n    if (err) {\n      return args.callback(err, null);\n    }\n\n    return tenant.getIdSites(args.options, args.callback);\n  });\n};\n\n/**\n * Retrieves a {@link SmtpServer} resource.\n *\n * @param {String} href\n * The href of the {@link SmtpServer}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link SmtpServer} during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link SmtpServer}).\n *\n * @example\n *\n * var href = \"https://api.stormpath.com/v1/smtpServers/4WCCtc0oCRDzQdAHVQTqjz\";\n *\n * client.getSmtpServer(href, function (err, smtpServer) {\n *   console.log(smtpServer);\n * });\n */\nClient.prototype.getSmtpServer = function() {\n  var args = utils.resolveArgs(arguments, ['href', 'options', 'callback']);\n  return this.getResource(args.href, args.options, require('./resource/SmtpServer'), args.callback);\n};\n\n/**\n * Retrieves all the {@link SmtpServer} resources for the current {@link Tenant}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link IdSiteModel} objects.\n *\n * @example\n * client.getSmtpServers(function (err, smtpServers) {\n *   smtpServers.each(function (smtpServer, next) {\n *     console.log(smtpServer);\n *     next();\n *   })\n * });\n */\nClient.prototype.getSmtpServers = function getSmtpServers(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.getCurrentTenant(function onGetCurrentTenant(err, tenant) {\n    if (err) {\n      return args.callback(err, null);\n    }\n\n    return tenant.getSmtpServers(args.options, args.callback);\n  });\n};\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/ds/DataStore.js":"'use strict';\n\nvar async = require('async');\nvar _ = require('underscore');\n\nvar ApiKey = require('../resource/ApiKey');\nvar ApiKeyEncryptedOptions = require('../authc/ApiKeyEncryptedOptions');\nvar CacheHandler = require('../cache/CacheHandler');\nvar InstanceResource = require('../resource/InstanceResource');\nvar NonceStore = require('./NonceStore');\nvar RequestExecutor = require('./RequestExecutor');\nvar instantiate = require('../resource/ResourceFactory').instantiate;\nvar noop = function (){};\nvar utils = require('../utils');\n\n/**\n * @private\n *\n * @description\n *\n * Creates a new `DataStore` instance using the specified (required) `config`.\n * The required `config` argument must contain a `RequestExecutor` instance or\n * contain values that may be used to construct a `RequestExecutor` instance\n * (like an `apiKey`).\n *\n * A `DataStore` interacts with the REST API server on behalf of SDK users.\n *\n * The DataStore delegates raw request execution to an internal\n * [RequestExecutor](RequestExecutor.js.html) instance. In future SDK releases,\n * the DataStore will also coordinate with a caching layer, reducing round trips\n * to the server.\n *\n * It is important that the DataStore acts as an intermediary, decoupling\n * SDK users from raw request logic: because interaction goes through the DataStore,\n * additional features (like caching) can be added at any point in the future\n * without requiring changes to SDK users' code.\n *\n * @param {Object} config\n * Required configuration object that either provides a `requestExecutor` or\n * values that may be used to instantiate a `RequestExecutor`.\n *\n * @param {Object} config.cacheOptions\n * Cache manager options.\n */\nfunction DataStore(config) {\n  if (!config) {\n    throw new Error('config argument is required.');\n  }\n  this.requestExecutor = config.requestExecutor || new RequestExecutor(config);\n  this.cacheHandler = config.cacheHandler || new CacheHandler(config);\n  this.nonceStore = config.nonceStore || new NonceStore(this);\n  this.apiKeyEncryptionOptions = new ApiKeyEncryptedOptions(config.apiKeyEncryptionOptions);\n  this.resourceRequestLogger = config.resourceRequestLogger;\n  var _request = null;\n  Object.defineProperty(this, '_request', {\n    get: function(){return _request;},\n    set: function(value){_request = value;}\n  });\n  this._request = {};\n}\nutils.inherits(DataStore, Object);\n\nDataStore.prototype._wrapGetResourceResponse =\n  function wrapGetResourceResponse(err, data, InstanceCtor, query, cb) {\n  var _this = this;\n  if (err) {\n    return cb(err, null);\n  }\n  var instance = null;\n  if (data) {\n    instance = instantiate(InstanceCtor, data, query, this);\n  }\n  if(instance instanceof ApiKey){\n    async.parallel([\n      instance._decrypt.bind(instance),\n      _this.cacheHandler.put.bind(_this.cacheHandler, instance.href, instance)\n    ],function (err, results) {\n      cb(err, err ? null : results[0]);\n    });\n  }\n  else if(utils.isCollectionData(instance) &&\n    instance.items[0] &&\n    instance.items[0] instanceof ApiKey)\n  {\n    async.map(instance.items,function(item,next){\n      item._setApiKeyMetaData(query);\n      _this.cacheHandler.put(item.href, item, utils.noop);\n      item._decrypt(next);\n    },function(err){\n      cb(err,instance);\n    });\n  }else if(data && data.href && !(data instanceof require('../cache/CacheEntry'))){\n    _this.cacheHandler.put(data.href, instance, utils.noop);\n    return cb(null, instance);\n  }else{\n    return cb(null, instance);\n  }\n\n};\n\n/**\n * @private\n *\n * @description\n *\n * Queries the server for a resource by `href`, providing the result to `callback`.\n *\n * @param {String} href\n * The URI of the resource to acquire. This must always be the first argument.\n *\n * @param {Object} query [optional=undefined]\n * Key/value pairs to use as query parameters to `href`.\n *\n * @param {Function} instanceCtor [optional=InstanceResource]\n * The Constructor function to invoke for any Instance Resource returned by the server.\n * If the resource returned by the server is a single resource, this function is used to\n * construct the resource. If the resource returned by the server is a collection,\n * `instanceCtor` is used to construct each resource in the collection's `items` field.\n *\n * @param {Function} callback\n * The callback function to invoke with the constructed Resource. `callback`'s\n * first argument is an `Error` object if an error occured, the second is the\n * constructed resource. `callback` must always be the last argument.\n *\n * @return {void} no return value; the acquired resource is instead provided to `callback`.\n */\nDataStore.prototype.getResource = function getResource(/* href, [query], [InstanceConstructor], callback */) {\n  var _this = this;\n  var args = Array.prototype.slice.call(arguments);\n  var href = args.shift();\n  var callback = args.pop();\n\n  _this = _.clone(_this);\n\n  _this._request = {\n    href: href,\n    query: (args.length > 0 && !(args[0] instanceof Function)) ? args.shift() : {},\n    InstanceCtor: (args.length > 0 && args[0] instanceof Function) ? args.shift() : InstanceResource\n  };\n\n  function loggerProxy(err, resource) {\n\n    // TODO - finish this idea of a \"resourceRequestLogger\" so that it is ready\n    // for public consumption.  Until then, don't bloat resources with the requestData\n    // object, though we need to keep it until this point so that we can make use\n    // of the originalHref for caching of access token redirects.\n\n    if (resource) {\n      if (_this.resourceRequestLogger) {\n        _this.resourceRequestLogger(resource.requestData);\n      }\n      delete resource.requestData;\n    }\n\n    callback.apply(null, arguments);\n  }\n\n  return _this.exec(loggerProxy);\n};\n\n/**\n * This is not used and will be removed in 1.0\n *\n * @private\n */\nDataStore.prototype.search = function (query, options, cb) {\n  if (!query || typeof query === 'function') {\n    throw new Error('Missing query argument in find request');\n  }\n  if (typeof options === 'function') {\n    cb = options;\n    options = query;\n  }\n  options = options || {};\n\n  if (typeof query === 'string' && query.length > 0) {\n    this._request.rawSearch = query;\n  }\n\n  if (_.isObject(query)) {\n    this._request.search = query;\n  }\n\n  this._request.limit = options.limit;\n  this._request.offset = options.offset;\n\n  return this.exec(cb);\n};\n\n/**\n * This is not used and will be removed in 1.0\n *\n * @private\n */\nDataStore.prototype.orderBy = function (orderQuery, cb) {\n  var order = {};\n\n  function isOrderDirection(word) {\n    return (word === 'asc') || (word === 'desc');\n  }\n\n  if (typeof orderQuery === 'string') {\n    var words = orderQuery.split(' ');\n    for (var i = 0; i < words.length; i++) {\n      if (isOrderDirection(words[i])) {\n        continue;\n      }\n      order[words[i]] = ((i + 1) < words.length) && isOrderDirection(words[i + 1]) ?\n        words[i + 1] : 'asc';\n    }\n  }\n  if (_.isObject(orderQuery)) {\n    _.each(orderQuery, function (val, field) {\n      order[field] = (\n        (val === -1) || (val === false) || (val === 'desc')) ? 'desc' : 'asc';\n    });\n  }\n\n  this._request.order = order;\n  return this.exec(cb);\n};\n\n/**\n * This is not used and will be removed in 1.0\n *\n * @private\n */\nDataStore.prototype.expand = function (expand, cb) {\n  var exp = {};\n  if (typeof expand === 'string') {\n    var words = expand.split(' ');\n    _.each(words, function (word) {\n      exp[word] = true;\n    });\n  }\n\n  if (_.isObject(expand)) {\n    exp = expand;\n  }\n  this._request.expand = exp;\n  return this.exec(cb);\n};\n\n/**\n * This is not used and will be removed in 1.0\n *\n * @private\n */\nDataStore.prototype.lean = function (lean) {\n  this._request.lean = lean !== false;\n  return this;\n};\n\nDataStore.prototype._buildRequestQuery = function(){\n  var queryStringObj = {};\n  if (this._request.rawSearch) {\n    queryStringObj.q = this._request.rawSearch;\n  }\n\n  if (this._request.search) {\n    _.each(this._request.search, function (val, name) {\n      queryStringObj[name] = val;\n    });\n  }\n\n  if (this._request.limit) {\n    queryStringObj.limit = this._request.limit;\n  }\n\n  if (this._request.offset) {\n    queryStringObj.offset = this._request.offset;\n  }\n\n  if (this._request.order) {\n    var orderByBuf = [];\n    _.each(this._request.order, function(direction, name){\n      orderByBuf.push(name + (direction !== 'asc' ? ' desc': ''));\n    });\n    queryStringObj.orderBy = orderByBuf.join(',');\n  }\n\n  if (this._request.expand){\n    var expandBuf = [];\n    _.each(this._request.expand, function(val, name){\n      if (val === true || val === 1){\n        return expandBuf.push(name);\n      }\n      return expandBuf.push(name + '(offset:'+val.offset+',limit:'+val.limit+')');\n    });\n\n    queryStringObj.expand = expandBuf.join(',');\n  }\n  return queryStringObj;\n};\n\nfunction applyRequestData(resource, data){\n  resource.requestData = data;\n}\n\n/**\n * @private\n * @param callback\n * @returns {object}\n */\nDataStore.prototype.exec = function executeRequest(callback){\n  var _this = this;\n\n  if (!callback){\n    return _this;\n  }\n\n  var query = _.extend({}, _this._request.query, _this._buildRequestQuery());\n  var request = {\n    uri: _this._request.href,\n    query: query\n  };\n\n  var ctor = _this._request.InstanceCtor;\n  var begin = new Date().getTime();\n  function doRequest(){\n    try {\n      _this.requestExecutor.execute(request, function onGetResourceRequestResult(err, body) {\n        if (body) {\n          applyRequestData(body, {\n            begin: begin,\n            end: new Date().getTime(),\n            originalHref: request.uri,\n            fromCache: false\n          });\n        }\n\n        _this._wrapGetResourceResponse(err, body, ctor, query, callback);\n      });\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  if (\n    ( (Object.keys(query).length > 0 ) ||\n      utils.isAssignableFrom(ctor,require('../resource/CollectionResource'))\n    ) && (ctor!==ApiKey)\n\n    ){\n    return doRequest();\n  }\n\n  var href = _this._request.href;\n\n  var cacheKey = ctor === ApiKey ? href.replace(/applications.*/,'apiKeys/'+query.id) : href;\n\n  _this.cacheHandler.get(cacheKey, function onCacheResult(err, entry) {\n    if (err || entry) {\n      if (entry) {\n        applyRequestData(entry, {\n          begin: begin,\n          end: new Date().getTime(),\n          originalHref: request.uri,\n          fromCache: true\n        });\n      }\n      _this._wrapGetResourceResponse(err, entry, ctor, query, callback);\n      return;\n    }\n\n    // Not cached, query the server.\n    doRequest();\n  });\n};\n\n/**\n * @private\n *\n * @description\n *\n * Creates a new resource on the server as a child of the specified `parentHref`\n * location (must be a collection resource endpoint).\n *\n * @param {String} parentHref\n * The URI of the parent collection under which the new resource will be created\n * as a child. This must always be the first argument.\n *\n * @param {Object} query [optional=null]\n * Key/value pairs to use as query parameters to `parentHref`.\n *\n * @param {Object} data\n * The resource (name/value pairs) to send to the server.\n *\n * @param {Function} instanceCtor [optional=InstanceResource]\n * The Constructor function to invoke for any Instance Resource returned by the server.\n * If the resource returned by the server is a single resource, this function is used to\n * construct the resource. If the resource returned by the server is a collection,\n * `instanceCtor` is used to construct each resource in the collection's `items` field.\n *\n * @param {Function} callback\n * The callback function to invoke with the constructed Resource. `callback`'s\n * first argument is an `Error` object if an error occured, the second is the\n * constructed resource. `callback` must always be the last argument.\n *\n * @return {void} no return value; the acquired resource is instead provided to `callback`.\n */\nDataStore.prototype.createResource = function createResource(/* parentHref, [query], data, [InstanceConstructor], callback */) {\n  var _this = this;\n  var args = Array.prototype.slice.call(arguments);\n  var parentHref = args.shift();\n  var callback = args.pop();\n  var ctor = (args.length > 0 && (args[args.length -1] instanceof Function)) ? args.pop() : InstanceResource;\n  var data = args.pop();\n  var query = (args.length > 0) ? args.pop() : null;\n  callback = callback || noop;\n\n  if (!utils.isAssignableFrom(InstanceResource, ctor)) {\n    throw new Error(\"If specifying a constructor function, it must be for class equal to or a subclass of InstanceResource.\");\n  }\n\n  var request = { uri: parentHref, method: 'POST' };\n  if (query) {\n    request.query = query;\n  }\n\n  if (data) {\n    request.body = data;\n  }\n\n  _this.requestExecutor.execute(request, function onCreateResourceRequestResult(err, body) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    var returnedResource = instantiate(ctor, body, null, _this);\n\n    if (returnedResource instanceof ApiKey) {\n      returnedResource._setApiKeyMetaData(query);\n      _this.cacheHandler.put(returnedResource.href, returnedResource, function(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        return returnedResource._decrypt(callback);\n      });\n    } else {\n      _this.cacheHandler.put(body.href, body, utils.noop);\n      return callback(null, returnedResource);\n    }\n  });\n};\n\n/**\n * @private\n *\n * @description\n *\n * Saves the provided resource by POSTing the resource to the href of the\n * resource.\n *\n * @param {Object} resource\n *\n * @param {String} resource.href The href of the resource to save\n *\n * @param {function} callback\n */\nDataStore.prototype.saveResource = function saveResource(resource, callback) {\n  var _this = this;\n\n  var href = utils.valueOf(resource.href);\n  callback = callback || noop;\n\n  var request = {uri: href, method: 'POST', body: resource};\n\n  _this.requestExecutor.execute(request, function onSaveResourceRequestResult(err, body) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    var returnedResource = instantiate(resource.constructor, body, null, _this);\n\n    // Cache for future use.\n    _this.cacheHandler.put(body.href, body, false, utils.noop);\n\n    return callback(null, returnedResource);\n  });\n};\n\n/**\n * @private\n *\n * @description\n *\n * Deletes the provided resource by issuing a DELETE request agaisnt the href of\n * the resource.\n *\n * @param {Object} resource\n *\n * @param {String} resource.href The href of the resource to delete\n *\n * @param {function} callback\n */\nDataStore.prototype.deleteResource = function deleteResource(resource, callback) {\n  var _this = this;\n  var href = utils.valueOf(resource.href);\n  callback = callback || noop;\n\n  // Remove from cache.\n  _this.cacheHandler.remove(href, utils.noop);\n\n  var request = {uri: href, method: 'DELETE'};\n\n  this.requestExecutor.execute(request, function onDeleteResourceRequestResult(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    return callback(null, null); // No body for the callback.\n  });\n};\n\n/**\n * @private\n *\n * @description\n\n * Private method to invalidate cache by HREF.\n *\n * @param {string} href\n * @param {function} callback\n */\nDataStore.prototype._evict = function _evict(href, callback){\n  this.cacheHandler.remove(href, callback);\n};\n\n\n/**\n * @typedef {Object} ExpansionOptions\n *\n * This object will pass the `expand` query parameter to the REST API when\n * making requests for individual resources.  The `expand` parameter allows you\n * to fetch linked resources in the same request, allowing you to make less\n * calls and warm your cache with the linked resources.\n *\n * @property {String} [expand]\n * A comma-separated list of linked resources that should be expanded on the\n * response from the REST API.\n *\n * @example\n *\n * client.getAccount({ expand: 'customData,groups' }, function(err, account){\n *\n *   // The custom data object is now populated on the account object:\n *\n *   console.log(account.customData)\n *\n *   // The first page of the groups collection is available as well:\n *\n *   console.log(account.groups.items)\n *\n *   // But if you need to all the groups, you should use the\n *   // the getter method and iterate through the collection:\n *\n *   account.getGroups(function(err, groupsCollection){\n *     groupsCollection.each(function(group){\n *       console.log(group);\n *     });\n *   });\n * });\n */\n\nmodule.exports = DataStore;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/ApiKey.js":"'use strict';\n\nvar crypto = require('crypto');\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class ApiKey\n *\n * @extends {InstanceResource}\n *\n * @description\n *\n * Encapsulates an Api Key resource of an {@link Account}. For full\n * documentation of this resource, please see\n * [REST API Reference: Account API Keys](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#account-api-keys).\n *\n * These keys can be used to authenticate requests to your web framework.\n * For a high-level overview of this feature, please read [Using Stormpath for\n * API Authentication](https://docs.stormpath.com/guides/api-key-management). If\n * you are using [Express-Stormath](http://docs.stormpath.com/nodejs/express/latest),\n * please read the [Authentication Section](http://docs.stormpath.com/nodejs/express/latest/authentication.html).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Account#getApiKeys Account.getApiKeys()}\n * - {@link Application#getApiKey Application.getApiKey()}\n *\n * @param {Object} apiKeyResource\n *\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction ApiKey() {\n  ApiKey.super_.apply(this, arguments);\n}\n\nutils.inherits(ApiKey, InstanceResource);\n\n\nApiKey.prototype._getDecryptedSecret = function _getDecryptedSecret(callback) {\n  var salt = this.apiKeyMetaData.encryptionKeySalt;\n  var iterations = this.apiKeyMetaData.encryptionKeyIterations;\n  var keyLengthBits = this.apiKeyMetaData.encryptionKeySize;\n  var password = new Buffer(this.dataStore.requestExecutor.options.client.apiKey.secret);\n  var encryptedSecret = new Buffer(this.secret,'base64');\n  var iv = encryptedSecret.slice(0,16);\n  var rawEncryptedValue = encryptedSecret.slice(16);\n  var saltBuf = new Buffer(salt,'base64');\n  var keyLength = keyLengthBits / 8;\n  var cryptoCallback = function(err, key){\n    if(err){\n      return callback(err);\n    }\n    var decrypted;\n    try{\n      var algo = keyLengthBits === 128 ? 'aes-128-cbc':'aes-256-cbc';\n      var decipher = crypto.createDecipheriv(algo, key, iv);\n      decrypted = decipher.update(rawEncryptedValue,'binary','utf8');\n      decrypted += decipher.final('utf8');\n    }catch(e){\n      return callback(e);\n    }\n    callback(null,decrypted);\n  };\n\n  try {\n    crypto.pbkdf2(password,saltBuf,iterations,keyLength,'sha1',cryptoCallback);\n  } catch (e) {\n    // Node 0.10.0 support - It does not take the digest parameter, and throws\n    crypto.pbkdf2(password,saltBuf,iterations,keyLength,cryptoCallback);\n  }\n};\n\nApiKey.prototype._setApiKeyMetaData = function _setApiKeyMetaData(obj){\n  this.apiKeyMetaData = obj && obj.encryptSecret ? obj : null;\n};\n\nApiKey.prototype._decrypt = function _decrypt(callback) {\n  var self = this;\n  if(self.apiKeyMetaData){\n    self._getDecryptedSecret(function(err,secret){\n      if(err){\n        return callback(err);\n      }\n      self.secret = secret;\n      delete self.apiKeyMetaData;\n      callback(null,self);\n    });\n  }else{\n    process.nextTick(callback.bind(null,null,self));\n  }\n};\n\n/**\n * Retrieves the account resource associated with the ApiKey.\n *\n * @param {ExpansionOptions} [options]\n * For retrieving linked resources of the {@link Account} during this request.\n *\n * @param {Function} Callback\n * Callback function, will be called with (err, {@link Account account}).\n */\nApiKey.prototype.getAccount = function () {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.account.href, args.options, require('./Account'), args.callback);\n};\n\nmodule.exports = ApiKey;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/InstanceResource.js":"'use strict';\n\nvar async = require('async');\n\nvar Resource = require('./Resource');\nvar SaveableMixin = require('./mixins/SaveableMixin');\nvar utils = require('../utils');\n\n/**\n * @class InstanceResource\n *\n * Low-level resource wrapper for Stormpath resource objects.\n */\nfunction InstanceResource() {\n  InstanceResource.super_.apply(this, arguments);\n}\n\nutils.inherits(InstanceResource, Resource);\nutils.applyMixin(InstanceResource, SaveableMixin);\n\n/**\n * @private\n *\n * @description\n *\n * Retrieves a linked resource by href or property reference.\n *\n * @param {Object|String} Resource reference. This should be a object literal\n * with a `href` property that identifies the resource to retrieve.\n *\n * @param {Object} query [optional=undefined]\n * Key/value pairs to use as query parameters to the resource.\n *\n * @param {Function} instanceCtor [optional=InstanceResource]\n * The constructor function to invoke for the resource returned by the server.\n *\n * @param {Function} callback\n * The callback function to invoke with the constructed Resource. `callback`'s\n * first argument is an `Error` object if an error occured, the second is the\n * constructed resource.\n */\nInstanceResource.prototype.get = function getResource() {\n  var args = Array.prototype.slice.call(arguments);\n\n  var propName = args[0];\n  var callback = args[args.length - 1];\n\n  var val = this[propName];\n\n  if (!val) {\n    var e1 = new Error('There is no field named \\'' + propName + '\\'.');\n    callback(e1, null);\n    return;\n  }\n  if (!val.href) {\n    var e2 = new Error('Field \\'' + propName + '\\' is not a reference property - it is not an object with an \\'href\\'' +\n      'property.  Do not call \\'get\\' for ' +\n      'non reference properties - access them normally, for example: resource.fieldName or resource[\\'fieldName\\']');\n    callback(e2, null);\n    return;\n  }\n\n  var query = null;\n  var ctor = null;\n\n  // Check if query params are supplied.\n  if (args[1] instanceof Object && !(args[1] instanceof Function)) {\n    query = args[1];\n  }\n\n  // Check if a constructor function was supplied to instantiate a returned resource.\n  var secondToLastArg = args[args.length - 2];\n  if (secondToLastArg instanceof Function && utils.isAssignableFrom(Resource, secondToLastArg)) {\n    ctor = secondToLastArg;\n  }\n\n  this.dataStore.getResource(val.href, query, ctor, callback);\n};\n\n/**\n * Deletes this resource from the API.\n *\n * @param {Function} callback\n * The function to call when the delete operation is complete. Will be called\n * with the parameter (err).\n */\nInstanceResource.prototype.delete = function deleteResource(callback) {\n  this.dataStore.deleteResource(this, callback);\n};\n\n/**\n * Removes this resource, and all of it's linked resources, e.g. Custom Data, from the local cache.\n *\n * @param {Function} callback\n * The function to call when the cache invalidation operation is complete.\n */\nInstanceResource.prototype.invalidate = function invalidateResource(callback) {\n  var self = this;\n\n  var tasks = [];\n  var visited = {};\n\n  function makeInvalidationTask(href) {\n    return function (itemCallback) {\n      // Swallow any errors. For cache invalidation those aren't that\n      // important and will also break the async.parallel() flow.\n      self.dataStore._evict(href, function () {\n        itemCallback();\n      });\n    };\n  }\n\n  function walkBuildInvalidationTasks(source) {\n    var rootHref = source.href;\n\n    if (rootHref in visited) {\n      return;\n    }\n\n    visited[rootHref] = null;\n    tasks.push(makeInvalidationTask(source.href));\n\n    for (var key in source) {\n      var item = source[key];\n\n      if (!item || !item.href) {\n        continue;\n      }\n\n      // Only walk child resources.\n      if (item.href.indexOf(rootHref) === 0) {\n        walkBuildInvalidationTasks(item);\n      }\n    }\n  }\n\n  if (this.href) {\n    walkBuildInvalidationTasks(this);\n  }\n\n  async.parallel(tasks, callback);\n};\n\nmodule.exports = InstanceResource;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Resource.js":"'use strict';\n\nvar utils = require('../utils');\n\nfunction Resource(data, dataStore) {\n  // require moved here intentionally because of\n  // issue related to\n  var DataStore = require('../ds/DataStore');\n  if (!dataStore && data instanceof DataStore){\n    dataStore = data;\n    data = null;\n  }\n  data = data || {};\n\n  for (var key in data) {\n    if (data.hasOwnProperty(key)) {\n      this[key] = data[key];\n    }\n  }\n\n  var ds = null; //private var, not enumerable\n  Object.defineProperty(this, 'dataStore', {\n    get: function getDataStore() {\n      return ds;\n    },\n    set: function setDataStore(dataStore) {\n      ds = dataStore;\n    }\n  });\n  if (dataStore) {\n    this.dataStore = dataStore;\n  }\n}\nutils.inherits(Resource, Object);\n\nmodule.exports = Resource;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/mixins/SaveableMixin.js":"function applyCustomDataUpdatesIfNecessary(cb){\n  if (!this.customData){\n    return cb();\n  }\n\n  if (this.customData._hasReservedFields()){\n    this.customData = this.customData._deleteReservedFields();\n  }\n\n  if (this.customData._hasRemovedProperties()){\n    return this.customData._deleteRemovedProperties(cb);\n  }\n\n  return cb();\n}\n\n/**\n * Save changes to this resource.\n *\n * @param {Function} callback\n * The function to call when the save operation is complete. Will be called\n * with the parameters (err, updatedResource).\n */\nfunction saveResource(callback) {\n  var self = this;\n  self._applyCustomDataUpdatesIfNecessary(function () {\n    self.dataStore.saveResource(self, callback);\n  });\n}\n\nvar SaveableMixin = {\n  _applyCustomDataUpdatesIfNecessary: applyCustomDataUpdatesIfNecessary,\n  save: saveResource\n};\n\nmodule.exports = SaveableMixin;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/ApiKeyEncryptedOptions.js":"'use strict';\n\nvar uuid = require('uuid');\n\nvar utils = require('../utils');\n\nfunction ApiKeyEncryptedOptions(options) {\n  options = typeof options === 'object' ? options : {};\n  this.expand = \"account\";\n\n  if(options.id){\n    this.id = options.id;\n  }\n\n  if(options.encryptSecret !== false){\n    this.encryptSecret = true;\n    this.encryptionKeySize = options.encryptionKeySize || 256;\n    this.encryptionKeyIterations = options.encryptionKeyIterations || 1024;\n    var salt = new Buffer(uuid().substr(0,16),'base64').toString('base64');\n    this.encryptionKeySalt = utils.base64.urlEncode(salt);\n  }\n}\nutils.inherits(ApiKeyEncryptedOptions, Object);\n\nmodule.exports = ApiKeyEncryptedOptions;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/CacheHandler.js":"'use strict';\n\nvar async = require('async');\nvar xtend = require('xtend');\n\nvar _ = require('../underscore');\nvar Cache = require('./Cache');\nvar CacheManager = require('./CacheManager');\nvar DisabledCache = require('./DisabledCache');\nvar utils = require('../utils');\n\nvar CACHE_REGIONS = ['applications', 'directories', 'accounts', 'groups',\n  'groupMemberships', 'tenants', 'accountStoreMappings','apiKeys','idSiteNonces',\n  'customData', 'organizations', 'authTokens', 'accessTokens'];\n\n// singleton of DisabledCache wrapped into Cache instance\nvar disabledCache = new Cache({store: DisabledCache});\n\n// private function\nfunction getCacheCtor(cache){\n  if (!cache){\n    return;\n  }\n\n  if (typeof cache === 'function'){\n    return cache;\n  }\n\n  function runtimeLoad(moduleRef){\n    return require(moduleRef);\n  }\n\n  var cacheCtors = {\n    disabled: runtimeLoad('./DisabledCache'),\n    memory: runtimeLoad('./MemoryStore'),\n    memcached: runtimeLoad('./MemcachedStore'),\n    redis: runtimeLoad('./RedisStore')\n  };\n\n  if (!(cache in cacheCtors)){\n    throw new Error('Unsupported cache provider: ' + cache);\n  }\n\n  return cacheCtors[cache];\n}\n\n// * Example of a object with all available options::\n//{\n//  store: 'redis',\n//  connection: {\n//    host: 'localhost',\n//    port: 6739,\n//  },\n//  options: {},\n//  ttl: 300,\n//  tti: 300\n//}\n\nfunction CacheHandler(config) {\n  var self = this;\n  config = config || {};\n  var options = config.cacheOptions || {};\n  options.store = getCacheCtor(options.store);\n\n  self.cacheManager = config.cacheManager || new CacheManager();\n  CACHE_REGIONS.map(function(region) {\n    self.cacheManager.createCache(region,options);\n  });\n\n}\n\n//private function:\nfunction getCacheByHref(cacheManager, href) {\n\n  var region = null;\n\n  //href is almost never null, but it is in the case of an AuthenticationResult (at the moment), so check for existence:\n  //see: https://github.com/stormpath/stormpath-sdk-node/issues/11\n  if (href) {\n    region = href.match(/customData/) ? 'customData' : (href.split('/').slice(-2)[0]);\n  }\n\n  if (!region || CACHE_REGIONS.indexOf(region) === -1) {\n    return disabledCache;\n  }\n\n  return cacheManager.getCache(region) || new DisabledCache();\n}\n\nCacheHandler.prototype.get = function getCachedResource(href, callback) {\n  var _this = this;\n  return getCacheByHref(_this.cacheManager, href).get(href, callback);\n};\n\n/*\n  Expect an object, which would be a JSON response from our API,\n  which is searched for resources which can be cached. To be cached\n  a resource must have an href and some other propeties.\n\n  It returns an array of objects which can be passed on to the\n  cache manager for caching in the appropriate regions\n\n*/\nfunction buildCacheableResourcesFromParentObject(object){\n  var resourcesToCache = [];\n  var parentResource = {};\n  if(utils.isCollectionData(object)){\n    object.items.forEach(function(resource) {\n      Array.prototype.push.apply(resourcesToCache, buildCacheableResourcesFromParentObject(resource));\n    });\n  }else{\n    _.pairs(object).forEach(function(pair) {\n      var prop = pair[0];\n      var val = pair[1];\n      if(val && val.href && _.keys(val).length>1){\n        Array.prototype.push.apply(resourcesToCache, buildCacheableResourcesFromParentObject(val));\n        parentResource[prop] = {\n          href: val.href\n        };\n      }else{\n        parentResource[prop] = val;\n      }\n    });\n    if(parentResource.href){\n      resourcesToCache.push(parentResource);\n    }\n\n    // This happens when a resource is a 302 direct from one to another,\n    // cache the returned data under the requestedUrl as well\n    if (object.requestData && object.requestData.originalHref !== object.href) {\n      resourcesToCache.push(xtend(object,{href: object.requestData.originalHref}));\n    }\n  }\n  return resourcesToCache;\n}\n\nCacheHandler.prototype.put = function cacheResource(href, data, _new, cb) {\n  var _this = this;\n\n  if (typeof _new === 'function') {\n    cb = _new;\n    _new = true;\n  }\n\n  async.each(\n    buildCacheableResourcesFromParentObject(data),\n    function(resource,next) {\n      getCacheByHref(_this.cacheManager, resource.href)\n        .put(resource.href, resource, _new, next);\n    },\n    cb\n  );\n\n};\n\nCacheHandler.prototype.remove = function removeCachedResource(href, callback) {\n  var _this = this;\n  return getCacheByHref(_this.cacheManager, href).delete(href, callback);\n};\n\nmodule.exports = CacheHandler;\nmodule.exports.CACHE_REGIONS = CACHE_REGIONS;\n\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/Cache.js":"'use strict';\n\nvar _ = require('underscore');\nvar CacheEntry = require('./CacheEntry');\nvar CacheStats = require('./CacheStats');\nvar MemoryStore = require('./MemoryStore');\n\nvar defaults = {\n  store: MemoryStore,\n  ttl: 5 * 60,\n  tti: 5 * 60\n};\n\n/**\n * @private\n *\n * @description\n *\n * Cache abstractions\n * A unified interface to different implementations of data caching.\n *\n * @param [store=MemoryStore]\n * @param {number=} [ttl=5*60] - time to live in seconds\n * @param {number=} [tti=5*60] - time to idle in seconds\n * @params {object} options - cache configuration options\n * @constructor\n */\nfunction Cache(options) {\n  options = options || {};\n\n  if (!(this instanceof Cache)) {\n    return new Cache(options);\n  }\n\n  if (typeof options === 'function'){\n    options = { store: options };\n  }\n\n  _.defaults(options, defaults);\n  var Store = options.store;\n\n  this.ttl = options.ttl;\n  this.tti = options.tti;\n  this.store = new Store(options);\n  this.stats = new CacheStats();\n}\n\nCache.prototype.get = function (key, cb) {\n\n  var self = this;\n\n  self.store.get(key, function (err, entry) {\n    if (err || !entry) {\n      return cb(err, null);\n    }\n\n    if (entry.isExpired(self.ttl, self.tti)) {\n      self.stats.miss(true);\n      return self.store.delete(key, function (err) {\n        return cb(err, null);\n      });\n    }\n\n    self.stats.hit();\n    // what point to touch entry if we not updating cache store\n    // will work for memory store but will not for redis store\n\n    if (self.ttl !== self.tti) {\n      entry.touch();\n      self.store.set(key, entry, function(){});\n    }\n\n    return cb(null, entry.value);\n  });\n};\n\n/**\n *\n * @param key\n * @param value\n * @param {boolean|function} [_new=true]\n * @param {function} cb\n */\nCache.prototype.put = function (key, value, _new, cb) {\n  if (typeof _new === 'function') {\n    cb = _new;\n    _new = true;\n  }\n  this.stats.put(_new);\n  this.store.set(key, new CacheEntry(value), cb);\n};\n\nCache.prototype.delete = function (key, cb) {\n  this.stats.delete();\n  this.store.delete(key, cb);\n};\n\nCache.prototype.clear = function (cb) {\n  this.stats.clear();\n  this.store.clear(cb);\n};\n\nCache.prototype.size = function (cb) {\n  this.store.size(cb);\n};\n\nmodule.exports = Cache;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/CacheEntry.js":"'use strict';\n\nvar moment = require('moment');\n\n/**\n * @private\n *\n * @description\n *\n * Cache entry abstraction\n * A single entry inside a cache\n *\n * It contains the data as originally returned by Stormpath along\n * with additional metadata like timestamps.\n * @param {object} value - value to store in cache\n * @param {Date=} createdAt - time when cache entry created\n * @param {Date=} lastAccessedAt - time when cache entry was last accessed\n * @constructor\n */\nfunction CacheEntry(value, createdAt, lastAccessedAt){\n  this.value = value;\n  this.createdAt = createdAt || Date.now();\n  this.lastAccessedAt = lastAccessedAt || this.createdAt;\n\n  if (typeof this.createdAt !== 'number' ||\n    typeof this.lastAccessedAt !== 'number'){\n    throw new Error('Expecting date in timestamp format or use CacheEntry.parse method instead');\n  }\n}\n\n// todo: what does it do in py: datetime.timedelta\nfunction timedelta(seconds){return seconds * 1000;}\n\n/**\n * Changes last accessed to current\n */\nCacheEntry.prototype.touch = function touch(){\n  this.lastAccessedAt = Date.now();\n};\n\n/**\n * Checks is entry expired due to overdue of live or idle timeouts\n * @param {number=} ttl - time to live\n * @param {number=} tti - time to idle\n * @returns {boolean}\n */\nCacheEntry.prototype.isExpired = function isExpired(ttl, tti){\n  var now = Date.now();\n  return (now >= (this.createdAt + timedelta(ttl))) ||\n    (now >= (this.lastAccessedAt + timedelta(tti)));\n};\n\nCacheEntry.prototype.toObject = function(){\n  function printDate(val){\n    return moment.utc(val).format('YYYY-MM-DD HH:mm:ss.SSS');\n  }\n  return {\n    createdAt: printDate(this.createdAt),\n    lastAccessedAt: printDate(this.lastAccessedAt),\n    value: this.value\n  };\n};\n\nCacheEntry.parse = function(data){\n  function parseDate(val){\n    return moment.utc(val).valueOf();\n  }\n  return new CacheEntry(data.value,\n    parseDate(data.createdAt),\n    parseDate(data.lastAccessedAt));\n};\n\nmodule.exports = CacheEntry;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/CacheStats.js":"'use strict';\n\n/**\n * @private\n *\n * @description\n *\n * Cache stats.\n * Represents cache statistic\n * @constructor\n */\nfunction CacheStats() {\n  this.puts = 0;\n  this.hits = 0;\n  this.misses = 0;\n  this.expirations = 0;\n  this.size = 0;\n}\n\n/**\n *\n * @param {boolean} [_new=true]\n */\nCacheStats.prototype.put = function (_new) {\n  _new = _new !== false;\n  this.puts++;\n  if (_new) {\n    this.size++;\n  }\n};\n\nCacheStats.prototype.hit = function () {\n  this.hits++;\n};\n\nCacheStats.prototype.miss = function (expired) {\n  this.misses++;\n  if (expired) {\n    this.expirations++;\n  }\n};\n\nCacheStats.prototype.delete = function () {\n  if (this.size > 0) {\n    this.size--;\n  }\n};\n\nCacheStats.prototype.clear = function () {\n  this.size = 0;\n};\n\nmodule.exports = CacheStats;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/MemoryStore.js":"'use strict';\n\nfunction MemoryStore() {\n\n  var store = {};\n\n  this.get = function get(key, cb) {\n    return cb(null, store[key]);\n  };\n\n  this.set = function set(key, val, cb) {\n    store[key] = val;\n    return cb(null, val);\n  };\n\n  this.delete = function del(key, cb) {\n    delete store[key];\n    return cb(null);\n  };\n\n  this.clear = function clear(cb) {\n    store = {};\n    cb(null);\n  };\n\n  this.size = function dbsize(cb) {\n    cb(null, Object.keys(store).length);\n  };\n}\n\nmodule.exports = MemoryStore;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/CacheManager.js":"'use strict';\n\nvar Cache = require('./Cache');\n\n/**\n * @private\n *\n * @description\n *\n * Cache manager abstraction.\n * Handles all the different caches used by the SDK\n * @constructor\n */\nfunction CacheManager() {\n  var self = this;\n  self.caches = {};\n\n  Object.defineProperty(self, 'stats', {\n    get: function () {\n      return Object.keys(self.caches).reduce(function(a,region){\n        a[region] = self.caches[region].stats;\n        return a;\n      },{});\n    }\n  });\n}\n\nCacheManager.prototype.createCache = function (region,options) {\n  this.caches[region] = new Cache(options);\n};\n\nCacheManager.prototype.getCache = function (region) {\n  return this.caches[region];\n};\n\nmodule.exports = CacheManager;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/DisabledCache.js":"'use strict';\n\nfunction DisabledCache() {\n}\n\nDisabledCache.prototype.get =\n  DisabledCache.prototype.set =\n    DisabledCache.prototype.delete =\n      DisabledCache.prototype.clear =\n        DisabledCache.prototype.size = function () {\n          return Array.prototype.slice.call(arguments, -1)[0](null, null);\n        };\n\nmodule.exports = DisabledCache;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/ds/NonceStore.js":"'use strict';\n\n/*\n* Deafult NonceStore - requires a data store instance which has a cache manager\n*/\nvar NonceStore = function NonceStore(dataStore){\n  this.cache = dataStore.cacheHandler.cacheManager.getCache('idSiteNonces');\n};\n\nNonceStore.prototype.getNonce = function getNonce(nonceValue,cb) {\n  this.cache.get(nonceValue,cb);\n};\n\nNonceStore.prototype.putNonce = function putNonce(nonceValue,cb) {\n  this.cache.put(nonceValue,nonceValue,cb);\n};\n\n\nmodule.exports = NonceStore;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/ds/RequestExecutor.js":"'use strict';\n\nvar os = require('os');\nvar url = require('url');\n\nvar request = require('request');\n\nvar ResourceError = require('../error/ResourceError');\nvar authc = require('../authc');\nvar packageJson = require('../../package.json');\nvar utils = require('../utils');\n\nvar USER_AGENT_VALUE = 'stormpath-sdk-node/' + packageJson.version + ' node/' + process.versions.node + ' ' + os.platform() + '/' + os.release();\n\n/**\n * @class\n *\n * @private\n *\n * @description\n *\n * An HTTP request abstraction.  The DataStore uses this to make HTTP requests.\n *\n * @param {Object} options Construction options\n * @param {String} [options.baseUrl=https://api.stormpath.com/v1]\n * @param {BasicRequestAuthenticator|Sauthc1RequestAuthenticator} options.requestAuthenticator\n * @param {Object} [options.headers] A map of headers to apply to all requets.\n */\nfunction RequestExecutor(options) {\n\n  options = options || {};\n\n  this.baseUrl = options.baseUrl || options.client && options.client.baseUrl || 'https://api.stormpath.com/v1';\n\n  this.requestAuthenticator = authc.getAuthenticator(options);\n\n  options.headers = options.headers || {};\n  options.json = true;\n\n  this.options = options;\n}\nutils.inherits(RequestExecutor, Object);\n\n/**\n * Executes an HTTP request based on the request object passed in. Request object properties:\n * @param {Object} request\n * @param {String} request.uri a fully qualified URL, e.g. `https://api.stormpath.com/v1/tenants/current`.\n * @param {String} [request.method=GET] E.g. 'GET', 'PUT', 'POST', or 'DELETE'\n * @param {Object} [request.query] JSON object to convert to a query string.\n * @param {Object} [request.body] JSON object to use as the request body.\n * @param {Function} callback The callback to invoke when the request returns.\n * Called with (networkErr, resourceResponseBody).\n */\nRequestExecutor.prototype.execute = function executeRequest(req, callback) {\n  if (!callback) {\n    throw new Error('Argument \\'callback\\' required. Unable to execute request.');\n  }\n\n  if (!req) {\n    return callback(new Error('Request argument is required.'));\n  }\n\n  if (!req.uri) {\n    return callback(new Error('request.uri field is required.'));\n  }\n\n  // Don't override the defaults: ensure that the options arg is request-specific.\n  var options = utils.shallowCopy(this.options, {});\n\n  req.method = req.method || 'GET';\n\n  options.method = req.method;\n  options.baseUrl = this.baseUrl;\n  options.uri = url.parse(req.uri.replace(options.baseUrl,'')).path;\n  options.headers['User-Agent'] = options.userAgent ? options.userAgent + ' ' + USER_AGENT_VALUE : USER_AGENT_VALUE;\n\n  if (req.query) {\n    options.qs = req.query;\n  }\n\n  if (req.body && req.body.form){\n    options.form = req.body.form;\n  } else if (req.body) {\n    options.body = req.body;\n    options.json = true; // All Stormpath resources are JSON\n  }\n\n  this.requestAuthenticator.authenticate(options);\n\n  request(options, function onRequestResult(err, response, body) {\n    var responseContext = this;\n\n    if (err) {\n      var wrapper = new Error('Unable to execute http request ' + req.method + ' ' + req.uri + ': ' + err.message);\n      wrapper.inner = err;\n      return callback(wrapper, null);\n    }\n\n    if (response.statusCode > 399) {\n      return callback(new ResourceError(body || {status:response.statusCode}, {url: responseContext.href, method: req.method}), null);\n    }\n\n    if (response.statusCode === 201){\n      Object.defineProperty(body, '_isNew', { value: true });\n    }\n\n    if (response.statusCode === 202 && !body){\n      callback(null, { accepted:true });\n    }else{\n      callback(null, body);\n    }\n  });\n};\n\nmodule.exports = RequestExecutor;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/error/ResourceError.js":"'use strict';\n\nvar utils = require('./../utils');\n\nfunction ResourceError(responseBody, requestData) {\n  Error.captureStackTrace(this, this.constructor);\n\n  requestData = requestData || {};\n\n  this.name = this.constructor.name;\n  this.status = responseBody.status;\n  this.code = responseBody.code;\n  this.userMessage = responseBody.message;\n  this.developerMessage = responseBody.developerMessage;\n  this.moreInfo = responseBody.moreInfo;\n  this.requestId = responseBody.requestId;\n  this.url = requestData.url;\n  this.method = requestData.method;\n  this.stack = '';\n\n  this.message = 'HTTP ' + this.status +\n    ', Stormpath ' + this.code + ' (' + this.moreInfo + '): ' +\n    this.developerMessage;\n\n  if (responseBody.error) {\n    this.error = responseBody.error;\n  }\n}\nutils.inherits(ResourceError, Error);\n\nmodule.exports = ResourceError;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/index.js":"'use strict';\n\nvar BasicRequestAuthenticator = require('./BasicRequestAuthenticator');\nvar Sauthc1RequestAuthenticator = require('./Sauthc1RequestAuthenticator');\n\n/**\n * @private\n *\n * @description\n *\n * A factory function that inspects any options and returns an appropriate {@link RequestAuthenticator} to use to\n * authenticate requests submitted to the API server.\n *\n * @param {object} options\n * @param {Sauthc1RequestAuthenticator|BasicRequestAuthenticator=} options.requestAuthenticator\n * @param {string} options.authenticationScheme - name of auth method that will instantiated\n * @returns {BasicRequestAuthenticator|Sauthc1RequestAuthenticator}\n */\nfunction getAuthenticator(options) {\n\n  if (options.requestAuthenticator) {\n    return options.requestAuthenticator;\n  }\n\n  var apiKey = options.client ? options.client.apiKey : options.apiKey;\n\n  if (!apiKey) {\n    throw new Error('If you do not specify a \\'requestAuthenticator\\' field, you must specify an ApiKey.');\n  }\n\n  var authc = new BasicRequestAuthenticator(apiKey); //default until Sauthc1 is working.\n\n  if (options.authenticationScheme) {\n    var scheme = options.authenticationScheme.toUpperCase();\n\n    if (scheme === 'SAUTHC1') {\n      authc = new Sauthc1RequestAuthenticator(apiKey);\n    } else if (scheme === 'BASIC') {\n      authc = new BasicRequestAuthenticator(apiKey);\n    } else {\n      throw new Error(\"Unrecognized authentication scheme: \" + options.authenticationScheme);\n    }\n  }\n\n  return authc;\n}\n\nmodule.exports = {\n  ApiKey: require('./ApiKey'),\n  loadApiKey: require('./ApiKeyLoader'),\n  getAuthenticator: getAuthenticator\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/BasicRequestAuthenticator.js":"'use strict';\n\nvar RequestAuthenticator = require('./RequestAuthenticator');\nvar utils = require('../utils');\n\nfunction BasicRequestAuthenticator() {\n  BasicRequestAuthenticator.super_.apply(this, arguments);\n}\nutils.inherits(BasicRequestAuthenticator, RequestAuthenticator);\n\nBasicRequestAuthenticator.prototype.authenticate = function basicAuthenticate(request) {\n  var concat = this.apiKey.id + ':' + this.apiKey.secret;\n  var base64 = utils.base64.encode(concat);\n  request.headers['Authorization'] = 'Basic ' + base64;\n};\n\nmodule.exports = BasicRequestAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/RequestAuthenticator.js":"'use strict';\n\nfunction RequestAuthenticator(apiKey) {\n  if (!apiKey) {\n    throw new Error('apiKey is required.');\n  }\n  if (!apiKey.id) {\n    throw new Error('apiKey.id is required.');\n  }\n  if (!apiKey.secret) {\n    throw new Error('apiKey.secret is required.');\n  }\n  this.apiKey = apiKey;\n}\n//All subclass types must have an 'authenticate' prototype function\n\nmodule.exports = RequestAuthenticator;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/Sauthc1RequestAuthenticator.js":"'use strict';\n\nvar moment = require('moment');\nvar url = require('url');\nvar uuid = require('uuid');\n\nvar _ = require('../underscore');\nvar RequestAuthenticator = require('./RequestAuthenticator');\nvar utils = require('../utils');\n\nvar HOST_HEADER = 'Host',\n  AUTHORIZATION_HEADER = 'Authorization',\n  STORMPATH_DATE_HEADER = 'X-Stormpath-Date',\n  ID_TERMINATOR = 'sauthc1_request',\n  ALGORITHM = 'HMAC-SHA-256',\n  AUTHENTICATION_SCHEME = 'SAuthc1',\n  SAUTHC1_ID = 'sauthc1Id',\n  SAUTHC1_SIGNED_HEADERS = 'sauthc1SignedHeaders',\n  SAUTHC1_SIGNATURE = 'sauthc1Signature',\n  NL = '\\n';\n\nfunction Sauthc1RequestAuthenticator() {\n  Sauthc1RequestAuthenticator.super_.apply(this, arguments);\n}\nutils.inherits(Sauthc1RequestAuthenticator, RequestAuthenticator);\n\n//TODO: finish this implementation:\nSauthc1RequestAuthenticator.prototype.authenticate = function sauthc1Authenticate(req) {\n  var apiKey = this.apiKey;\n\n  function isDefaultPort(parsedUrl) {\n    var protocol = parsedUrl.protocol;\n    var port = parsedUrl.port;\n    return !port || (port === 80 && protocol.test(/http/ig)) ||\n      (port === 443 && protocol.test(/https/ig));\n  }\n\n  function encodeUrl(path) {\n    return path\n      .replace('+', '%20')\n      .replace('*', '%2A')\n      .replace('%7E', '~')\n      .replace('%2F', '/');\n  }\n\n  var timeStamp = moment.utc().format('YYYYMMDDTHHmmss[Z]');\n  var dateStamp = moment.utc().format('YYYYMMDD');\n\n  var nonce = uuid.v4(); //correct UUIDs provide better entropy than using JS's (not-so-random) Random\n  var parsedUrl = url.parse(req.url);\n  var hostHeader = isDefaultPort(parsedUrl) ? parsedUrl.hostname : parsedUrl.host;\n\n  req.headers[HOST_HEADER] = hostHeader;\n  req.headers[STORMPATH_DATE_HEADER] = timeStamp;\n\n  var method = req.method;\n  var canonicalResourcePath = parsedUrl.path ? encodeUrl(parsedUrl.path) : '/';\n  var canonicalQueryString = parsedUrl.query ? encodeUrl(parsedUrl.query) : '';\n  var authHeaders = _.clone(req.headers);\n\n  // FIXME: REST API doesn't want this header in the signature\n  delete authHeaders['Content-Length'];\n\n  var sortedHeaderKeys = [];\n  _.each(Object.keys(authHeaders), function (key) {\n    sortedHeaderKeys.push(key);\n  });\n  sortedHeaderKeys = sortedHeaderKeys.sort();\n\n  var canonicalHeadersString = '';\n  _.each(sortedHeaderKeys, function (val) {\n    canonicalHeadersString += val.toLowerCase() + ':' + authHeaders[val] + NL;\n  });\n\n  var signedHeadersString = sortedHeaderKeys.join(';').toLowerCase();\n\n  var requestPayloadHashHex = utils.crypto.toHex(\n    utils.crypto.sha256(req.body || ''));\n\n  var canonicalRequest = [method, canonicalResourcePath, canonicalQueryString,\n    canonicalHeadersString, signedHeadersString, requestPayloadHashHex]\n    .join(NL);\n\n  var id = [apiKey.id, dateStamp, nonce, ID_TERMINATOR].join('/');\n\n  var canonicalRequestHashHex = utils.crypto.toHex(\n    utils.crypto.sha256(canonicalRequest));\n\n  var stringToSign = [ALGORITHM, timeStamp, id, canonicalRequestHashHex]\n    .join(NL);\n\n\n  function _sign(data, key) {\n    return utils.crypto.hmac(key, data);\n  }\n\n  // SAuthc1 uses a series of derived keys, formed by hashing different\n  // pieces of data\n\n  var kSecret = AUTHENTICATION_SCHEME + apiKey.secret;\n  var kDate = _sign(dateStamp, kSecret);\n  var kNonce = _sign(nonce, kDate);\n  var kSigning = _sign(ID_TERMINATOR, kNonce);\n\n  var signature = _sign(stringToSign, kSigning);\n  var signatureHex = utils.crypto.toHex(signature);\n\n  var authorizationHeader = [\n    AUTHENTICATION_SCHEME + ' ' + SAUTHC1_ID + '=' + id,\n    SAUTHC1_SIGNED_HEADERS + '=' + signedHeadersString,\n    SAUTHC1_SIGNATURE + '=' + signatureHex\n  ].join(', ');\n\n  req.headers[AUTHORIZATION_HEADER] = authorizationHeader;\n};\n\nmodule.exports = Sauthc1RequestAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/ResourceFactory.js":"'use strict';\n\n/* jshint -W003 */\nvar CollectionResource = require('./CollectionResource');\nvar CustomData = require('./CustomData');\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\nvar fs = require('fs');\nvar path = require('path');\n\n/**\n* @private\n*\n* @description\n*\n* Computes the path to a file by its resource name. Currently only does so by\n* transforming the resource name.\n*\n* @param resourceName The string representing the name of the expanded resource\n* @return Path to the resource file\n*/\nfunction getPathForResourceName(resourceName) {\n  var normalizedFieldName = resourceName.charAt(0).toUpperCase() +\n    resourceName.substr(1);\n\n  return path.join(__dirname , normalizedFieldName + '.js');\n}\n\n/**\n* @private\n*\n* @description\n* Given an instantiated resource or resource collection, turns all objects\n* that came from an `expand` query into resource object by instantiating them.\n* These transformations are done in-place (the original resource is modified,\n* not copied).\n*\n* @param expandedFields A list of resources that were demanded in an expand query\n* @param resource An instantiated parent resource or collection of resources\n* @param query any query that was provided to the server when acquiring the data\n* @param dataStore the dataStore used by the resource to communicate with the server. required for all resources.\n* @returns Resource with expanded fields transformed into instantied resources\n*\n*/\nfunction expandResource(expandedFields, resource, query, dataStore) {\n  if (resource instanceof CollectionResource) {\n    resource.items.forEach(function (instance) {\n      expandResource(expandedFields, instance, query, dataStore);\n    });\n\n    return resource;\n  }\n\n  expandedFields.forEach(function(fieldName) {\n    var path = getPathForResourceName(fieldName);\n    if (typeof resource[fieldName] !== 'undefined' && fs.existsSync(path) ) {\n      resource[fieldName] = instantiate(require(path), resource[fieldName], query, dataStore);\n    }\n  });\n\n  return resource;\n}\n\n/**\n * @private\n *\n * @description\n *\n * A factory function that creates and returns a new Resource instance. The server is not contacted in any way -\n * this function merely instantiates the object in memory and returns it. Callers are responsible for persisting\n * the returned instance's state to the server if desired.\n *\n * @param InstanceConstructor the specific Resource constructor to call when creating the instance.\n * @param data the data acquired from the server\n * @param query any query that was provided to the server when acquiring the data\n * @param dataStore the dataStore used by the resource to communicate with the server. required for all resources.\n * @returns a new Resource memory instance\n */\nfunction instantiate(InstanceConstructor, data, query, dataStore) {\n  var Ctor = utils.valueOf(InstanceConstructor, InstanceResource);\n\n  if (utils.isAssignableFrom(CollectionResource, Ctor)) {\n    throw new Error('InstanceConstructor argument cannot be a CollectionResource.');\n  }\n\n  if (!data) {\n    return null;\n  }\n\n  var resource = null;\n  var q = utils.valueOf(query);\n\n  if (utils.isCollectionData(data)) {\n    resource = new CollectionResource(data, q, Ctor, dataStore);\n  } else {\n    resource = new Ctor(data, dataStore);\n  }\n\n  // Wrap any explicitly expanded data into resources, if they can be required.\n  // Assumes that the expanded field name is matched by the resource file name.\n  if (q && q.expand) {\n    var fieldNames = q.expand.split(/\\s*,\\s*/);\n    resource = expandResource(fieldNames, resource, q, dataStore);\n  }\n\n  // Expand the custom data even if it is not explicitly required to maintain backwards compatibility\n  if (resource.customData && !(resource.customData instanceof CustomData)) {\n    resource.customData = instantiate(CustomData, resource.customData, q, dataStore);\n  }\n\n  return resource;\n}\n/* jshint +W003 */\n\nmodule.exports = {\n  instantiate: instantiate\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/CollectionResource.js":"'use strict';\n\nvar _ = require('underscore');\nvar async = require('async');\n\nvar InstanceResource = require('./InstanceResource');\nvar Resource = require('./Resource');\nvar utils = require('../utils');\n\n/**\n * @typedef {Object} CollectionQueryOptions\n *\n * This object allows you to add query parameters when requesting collections\n * from the Stormpath REST API. The query parameters allow you to sort, search,\n * and limit the results that are returned. For more information, please see:\n * {@link https://docs.stormpath.com/rest/product-guide/latest/reference.html#collection-resources REST API Reference: Collection Resources}.\n *\n * @property {String} [expand]\n * Comma-separated list of linked resources to expand on the returned resources.\n * Not all links are available for expansion. For more information, please see:\n * {@link https://docs.stormpath.com/rest/product-guide/latest/reference.html#links REST API Reference: Links}.\n *\n * Example: `'customData, directory'`\n *\n * @example\n * // Expand custom data and directory when getting all accounts.\n * client.getAccounts({ expand: 'customData, directory' });\n *\n * @property {Number} [limit]\n * The maximum number of collection items to return for a single request.\n * Minimum value is 1. Maximum value is 100. Default is 25.\n *\n * @property {Number} [offset]\n * The zero-based starting index in the entire collection of the first item to\n * return. Default is 0.\n *\n * @property {String} [orderBy]\n * URL-encoded comma-separated list of ordering statements. Each ordering\n * statement identifies a sortable attribute, and whether you would like the\n * sorting to be ascending or descending.\n *\n * Example: `'email,username asc'`\n *\n * @example\n * // Get all accounts, sorting by email, then username, ascending.\n * application.getAccounts({ orderBy: 'email,username asc' }, callbackFn);\n *\n * @property {String} [q]\n * Stormpath will perform a case-insensitive matching query on all viewable\n * attributes in all the resources in the Collection. Note that “viewable” means\n * that the attribute can be viewed by the current caller. For full\n * documentation of filter searching in the Stormpah API, please see:\n * {@link https://docs.stormpath.com/rest/product-guide/latest/reference.html#filter-search REST API Reference: Filter Search}.\n *\n * @example\n * // Find any account that has a searchable attribute containing the text “Joe”:\n * application.getAccounts({ q: 'Joe' }, callbackFn);\n *\n * @property {String} [attribute]\n * Find objects by a specific attribute match, such as an email address. Not\n * all attributes are available for matching on all resource types. Please\n * refer to the specific resource type in this documentation, or see\n * {@link https://docs.stormpath.com/rest/product-guide/latest/reference.html#attribute-search REST API Reference: Attribute Search}.\n *\n * @example\n * // Find all accounts with this email address.\n * application.getAccounts({ email: 'foo@bar.com'}, callbackFn);\n */\n\nfunction wrapAsyncCallToAllPages(coll, func, args, callbackWrapper){\n  var page = _.pick(coll, [\n    'href', 'query', 'offset', 'limit', 'items',\n    'dataStore', 'instanceConstructor']);\n\n  var callback = args.pop();\n\n  function getNextPage(page, callback) {\n    // There is no next page.\n    if (page.items.length < page.limit) {\n      return callback();\n    }\n\n    // We've fully exhausted the current page. There could be another one on the server, so\n    // we have to execute another query to continue to the next page if one exists.\n    var nextQuery = utils.shallowCopy(page.query, {});\n    nextQuery.offset = page.offset + page.items.length;\n    nextQuery.limit = 100;\n\n    page.dataStore.getResource(page.href, nextQuery, page.instanceConstructor,\n      function onNextPage(err, collectionResource) {\n        if (err) {\n          return callback(err);\n        }\n        (typeof setImmediate !== 'undefined' ?\n          setImmediate : process.nextTick)(function(){\n          callback(null, collectionResource);\n        });\n      });\n  }\n\n  function worker(task, cb){\n    if (!task.collection.items || !task.collection.items.length){\n      return cb();\n    }\n\n    async.parallel([\n      function(parallel_cb){\n        if (callbackWrapper.isDone){\n          return parallel_cb();\n        }\n\n        var callArgs = Array.prototype\n          .concat(\n            [task.collection.items],\n            !!callbackWrapper.wrapPageArgs ? callbackWrapper.wrapPageArgs(args) : args,\n            callbackWrapper.wrapPageCallback(parallel_cb.bind(this, null)));\n        func.apply(this, callArgs);\n      },\n      function(parallel_cb){\n        if (callbackWrapper.isDone){\n          return parallel_cb();\n        }\n\n        getNextPage(task.collection, function(err, nextPage){\n          if (err || !nextPage){\n            return parallel_cb(err);\n          }\n\n          q.push({collection: nextPage});\n          parallel_cb();\n        });\n      }\n    ], cb);\n\n  }\n\n  var q = async.queue(worker, 1);\n  q.drain = callbackWrapper.wrapCallback(callback);\n  q.push({ collection: page });\n}\n\nfunction ensureInstanceResources(items, InstanceConstructor, dataStore) {\n\n  var InstanceCtor = utils.valueOf(InstanceConstructor, InstanceResource);\n\n  if (!items || items.length === 0 || items[0] instanceof InstanceCtor /* already converted */) {\n    return items;\n  }\n\n  var convertedItems = [];\n\n  for (var i = 0; i < items.length; i++) {\n    var obj = items[i];\n    // We have to call instantiate via a require statement to avoid a circular dependency\n    // (instantiate references CollectionResource).\n    var converted = require('./ResourceFactory').instantiate(InstanceCtor, obj, null, dataStore);\n    convertedItems.push(converted);\n  }\n\n  return convertedItems;\n}\n\n/**\n * @class CollectionResource\n *\n * @description\n * Encapsulates a collection resource, such as an Application's Accounts\n * collection, making it possible to iterate through the collection in an\n * asynchronous manner. You do not need to manually construct a\n * CollectionResource. Rather, you will obtain a resource collection from a\n * getter method, such as {@link Application#getAccounts\n * Application.getAccounts()}.\n *\n * Every CollectionResource has the following iteration methods, modeled after\n * the [caolan/async library](https://github.com/caolan/async), for iterating\n * over the paginated collection in an asynchronous manner.\n *\n * The collection resource will make multiple attempts to the REST API, to\n * request each page in the collection. You can reduce\n * the number of REST API calls by increasing the page size when you get the\n * collection for the first time, using the `limit` option. See {@link\n * CollectionQueryOptions}.\n */\nfunction CollectionResource(/*data, query, InstanceCtor, dataStore*/) {\n\n  var args = Array.prototype.slice.call(arguments);\n\n  var data = args[0];\n  var dataStore = args[args.length - 1];\n  var query = null;\n  var InstanceCtor = InstanceResource; // Default for generic resource instances.\n\n  // Check if query params supplied.\n  if (args[1] instanceof Object && !(args[1] instanceof Function)) {\n    query = args[1];\n  }\n\n  // Check if a type-specific resource constructor function was supplied.\n  var secondToLastArg = args[args.length - 2];\n  if (secondToLastArg instanceof Function && utils.isAssignableFrom(Resource, secondToLastArg)) {\n    InstanceCtor = secondToLastArg;\n  }\n\n  // Convert raw items array (array of objects) to an array of Instance Resources.\n  if (data && data.hasOwnProperty('items') && data.items.length > 0) {\n    data.items = ensureInstanceResources(data.items, InstanceCtor, dataStore);\n  }\n\n  CollectionResource.super_.apply(this, [data, dataStore]);\n\n  Object.defineProperty(this, 'instanceConstructor', {\n    get: function getInstanceConstructor() {\n      return InstanceCtor;\n    },\n    set: function setInstanceConstructor(TheInstanceCtor) {\n      InstanceCtor = TheInstanceCtor;\n    }\n  });\n  this.instanceConstructor = InstanceCtor;\n\n  Object.defineProperty(this, 'query', {\n    get: function getQuery() {\n      return query;\n    },\n    set: function setQuery(aQuery) {\n      query = aQuery;\n    }\n  });\n  this.query = query;\n}\nutils.inherits(CollectionResource, Resource);\n\n/**\n * @name CollectionResource#concat\n *\n * @function\n *\n * @description\n * Visit each resource in the collection and concatenate the return values of\n * the `iterator`. Similar to {@link CollectionResource#map map}, but the\n * return values should be arrays, and all arrays will be concatendated before\n * being provied to the `doneCallback`.\n *\n * @param {Function} iterator\n * The function to call, for each resource in the collection. Will be called\n * with `(resource, next)`. The `next(err, results)` function must be called to\n * advance to the next resource. If an `err` value is passed to next, the\n * iteration will stop and the `doneCallback` will be called with the `err`\n * value.\n *\n * @param {Function} doneCallback\n * The function to call when iteration has ended. Will be called with `(err,\n * [concatenatedResults])`.\n *\n * @example\n * // Find all orders from all accounts, that are stored in your SQL database\n *\n * function iterator(account, next) {\n *   // Talk do your SQL databse, pseudo-code:\n *   sqlQuery('SELECT * FROM ORDERS WHERE userId=\\\"' + encodeURIComponent(account.customData.sqlId) + '\\\";', next);\n * }\n *\n * function doneCallback(err, orders) {\n *   if (!err) {\n *     console.log(orders);\n *   }\n * }\n *\n * application.getAccounts({ expand: 'customData' }, function (err, collection) {\n *   if (!err) {\n *     collection.concat(iterator, donCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#concatLimit\n *\n * @function\n *\n * @description\n * The same interface as `concat`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#concat concat}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#concat concat}.\n */\n\n/**\n * @name CollectionResource#concatSeries\n *\n * @function\n *\n * @description\n * The same interface as `concat`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#concat concat}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#concat concat}.\n */\n\n/**\n * @name CollectionResource#detect\n *\n * @function\n *\n * @description\n * Visit each resource in the collection and return the first resource that\n * passes a truth test in the iterator. The iterator is applied in parallel, and\n * the first iterator to return true will end the iteration.\n *\n * @param {Function} iterator\n * The function to call, for each resource in the collection. Will be called\n * with `(resource, next)`. The `next(err, test)` function must be called to\n * advance to the next resource. Iteration is ended as soon as a truthy value\n * is provided to either `err` or `test`.\n *\n * @param {Function} doneCallback\n * The function to call when iteration has ended. Will be called with `(err,\n * foundResource)`.\n *\n * @example\n * // Find the first account that likes pizza.\n *\n * function iterator(account, next) {\n *   next(null, account.customData.favoriteFood === 'pizza');\n * }\n *\n * function doneCallback(err, foundAccount) {\n *   if (!err) {\n *     console.log('Guess who likes pizza??').\n *     console.log(foundAccount.fullName);\n *   }\n * }\n *\n * application.getAccounts({ expand: 'customData' }, function (err, collection) {\n *   if (!err) {\n *     collection.detect(iterator, donCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#detectLimit\n *\n * @function\n *\n * @description\n * The same interface as `detect`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#detect detect}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#detect detect}.\n */\n\n/**\n * @name CollectionResource#detectSeries\n *\n * @function\n *\n * @description\n * The same interface as `detect`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#detect detect}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#detect detect}.\n */\n\n/**\n * @name CollectionResource#each\n *\n * @function\n *\n * @description\n * Visit each resource in the collection. The `iterator` will be called in\n * parallel.\n *\n * @param {Function} iterator\n * The function to call, for each resource in the collection. Will be called\n * with `(resource, next)`. The `next()` function must be called in order to\n * advance to the next resource. If an `err` value is passed to next, the\n * iteration will stop and the `doneCallback` will be called with the `err`\n * value.\n *\n * @param {Function} doneCallback\n * The function to call when all items have been visited. If `next(err)` has\n * been used, the `err` will be passed to this function.\n *\n * @example\n * function iterator(account, next) {\n *   console.log('Found account for ' + account.givenName + ' (' + account.email + ')');\n *   next();\n * }\n *\n * function doneCallback(err) {\n *   if (!err) {\n *     console.log('All accounts have been visited.').\n *   }\n * }\n *\n * application.getAccounts({ email: 'foo@example.com' }, function (err, collection) {\n *   if (!err) {\n *     collection.each(iterator, doneCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#eachLimit\n *\n * @function\n *\n * @description\n * The same interface as `each`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#each each}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#each each}.\n */\n\n/**\n * @name CollectionResource#eachSeries\n *\n * @function\n *\n * @description\n * The same interface as `each`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#each each}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#each each}.\n */\n\n/**\n * @name  CollectionResource#every\n *\n * @function\n *\n * @description\n * Visit each resource in the collection and return true if all resources pass\n * a truth test in the `iterator`. The `iterator` will be called in parallel.\n *\n * @param {Function} iterator\n * The function to call, for each resource in the collection. Will be called\n * with `(resource, next)`. The `next(err, test)` function must be called to\n * advance to the next resource. If an `err` value is passed to next, the\n * iteration will stop and the `doneCallback` will be called with the `err`\n * value.\n *\n * @param {Function} doneCallback\n * The function to call when iteration has ended. Will be called with `(err,\n * test)`.\n *\n * @example\n * // Does everyone like Brie cheese?\n *\n * function iterator(account, next) {\n *   next(null, account.customData.likesBrie === true);\n * }\n *\n * function doneCallback(err, test) {\n *   if (!err && test === true) {\n *     console.log('Everyone likes Brie??');\n *   }\n * }\n *\n * application.getAccounts({ expand: 'customData' }, function (err, collection) {\n *   if (!err) {\n *     collection.every(iterator, donCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#everyLimit\n *\n * @function\n *\n * @description\n * The same interface as `every`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#every every}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#every every}.\n */\n\n/**\n * @name CollectionResource#everySeries\n *\n * @function\n *\n * @description\n * The same interface as `every`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#every every}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#every every}.\n */\n\n/**\n * @name CollectionResource#filter\n *\n * @function\n *\n * @description\n * Visit each resource in the collection, and filter down to a new set of\n * resources, based on a truth test that is evaluated by the `iterator`.\n * The `iterator` will be called in parallel.\n *\n * @param {Function} iterator\n * The function to call for each resource in the collection. Will be called\n * with `(resource, next)`. The `next(err, test)` function must be called in order to\n * advance to the next resource. The `test` value should be a boolean value that\n * indicates if the resource should be included in the filtered collection.\n *\n * If an `err` value is passed to next, the iteration will stop and the\n * `doneCallback` will be called with the `err` value.\n *\n * @param {Function} doneCallback\n * The function to call when all items have been visited. Will be called with\n * `(err, [filteredResources])`.\n *\n * @example\n * // Find all accounts that have the 'paid' plan property, in custom data.\n *\n * function iterator(account, next) {\n *   next(null, account.customData.plan === 'paid');\n * }\n *\n * function doneCallback(err, paidAccounts) {\n *   if (!err) {\n *     console.log('All paid accounts:').\n *     console.log(paidAccounts);\n *   }\n * }\n *\n * application.getAccounts({ expand: 'customData' }, function (err, collection) {\n *   if (!err) {\n *     collection.filter(iterator, doneCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#filterLimit\n *\n * @function\n *\n * @description\n * The same interface as `filter`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#filter filter}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#filter filter}.\n */\n\n/**\n * @name CollectionResource#filterSeries\n *\n * @function\n *\n * @description\n * The same interface as `filter`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#filter filter}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#filter filter}.\n */\n\n/**\n * @name CollectionResource#map\n *\n * @function\n *\n * @description\n * Visit each resource in the collection and produce a new value for that\n * resource. The `iterator` will be called in parallel.\n *\n * @param {Function} iterator\n * The function to call for each resource in the collection. Will be called\n * with `(resource, next)`. The `next(err, value)` function must be called with\n * the new value in order to advance to the next resource. If an `err` value is\n * passed to next, the iteration will stop and the `doneCallback` will be called\n * with the `err` value.\n *\n * @param {Function} doneCallback\n * The function to call when all items have been visited. Will be called with\n * `(err, [transformedResources])`.\n *\n * @example\n * // Pluck the email address from all accounts.\n *\n * function iterator(account, next) {\n *   next(null, account.email);\n * }\n *\n * function doneCallback(err, emails) {\n *   if (!err) {\n *     console.log('All email addresses in this application:').\n *     console.log(emails);\n *   }\n * }\n *\n * application.getAccounts(function (err, collection) {\n *   if (!err) {\n *     collection.map(iterator, doneCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#mapLimit\n *\n * @function\n *\n * @description\n * The same interface as `map`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#map map}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#map map}.\n */\n\n/**\n * @name CollectionResource#mapSeries\n *\n * @function\n *\n * @description\n * The same interface as `map`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#map map}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#map map}.\n */\n\n/**\n * @name CollectionResource#reduce\n *\n * @function\n *\n * @description\n * Visit each resource in the collection and use the `iterator` to reduce down\n * to a new value. The `iterator` will be called in parallel.\n *\n * @param {*} initialValue\n * The initial value that will then be passed to the `iterator` as `result`,\n * this is the value that you will mutate over time as the iterator is called\n * with every resource in the collection.\n *\n * @param {Function} iterator\n * The function to call, for each resource in the collection. Will be called\n * with `(result, resource, next)`. The `next(err, result)` function must be\n * called to advance to the next resource. If an `err` value is passed to next,\n * the iteration will stop and the `doneCallback` will be called with the `err`\n * value.\n *\n * @param {Function} doneCallback\n * The function to call when iteration has ended. Will be called with `(err,\n * result)`.\n *\n * @example\n * // Find all the unique favorite colors, of all your accounts\n *\n * function iterator(result, account, next) {\n *   var color = account.customData.favoriteColor;\n *   if (result.indexOf(color) === -1) {\n *     result.push(color);\n *   }\n *   return result;\n * }\n *\n * function doneCallback(err, colors) {\n *   if (!err) {\n *     console.log(colors);\n *   }\n * }\n *\n * application.getAccounts({ expand: 'customData' }, function (err, collection) {\n *   if (!err) {\n *     collection.reduce([], iterator, donCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#reduceRight\n *\n * @function\n *\n * @description\n * The same interface as {@link CollectionResource#reduce reduce}, but operates\n * on the collection in reverse order.\n *\n * @param {*} initialValue\n * Same interface as {@link CollectionResource#reduce reduce}.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#reduce reduce}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#reduce reduce}.\n */\n\n/**\n * @name CollectionResource#reject\n *\n * @function\n *\n * @description\n * The opposite of {@link CollectionResource#filter filter}. Removes values that\n * pass an async truth test.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#filter filter}, but removes\n * values if they pass the truth test.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#filter filter}.\n */\n\n/**\n * @name CollectionResource#rejectLimit\n *\n * @function\n *\n * @description\n * The same interface as `reject`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#reject reject}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#reject reject}.\n */\n\n/**\n * @name CollectionResource#rejectSeries\n *\n * @function\n *\n * @description\n * The same interface as `reject`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#reject reject}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#reject reject}.\n */\n\n/**\n * @name CollectionResource#some\n *\n * @function\n *\n * @description\n * Visit each resource in the collection and return true if any of the resources\n * pass a truth test in the `iterator`. The `iterator` will be called in\n * parallel, but iteration stops once the test is true for any resource.\n *\n * @param {Function} iterator\n * The function to call for each resource in the collection. Will be called\n * with `(resource, next)`. The `next(err, test)` function must be called to\n * advance to the next resource. If an `err` value is passed to next, the\n * iteration will stop and the `doneCallback` will be called with the `err`\n * value.\n *\n * @param {Function} doneCallback\n * The function to call when iteration has ended. Will be called with `(err,\n * test)`.\n *\n * @example\n * // Does anyone like Brie cheese?\n *\n * function iterator(account, next) {\n *   next(null, account.customData.likesBrie === true);\n * }\n *\n * function doneCallback(err, test) {\n *   if (!err && test === true) {\n *     console.log('Some people like Brie.');\n *   }\n * }\n *\n * application.getAccounts({ expand: 'customData' }, function (err, collection) {\n *   if (!err) {\n *     collection.some(iterator, donCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#someLimit\n *\n * @function\n *\n * @description\n * The same interface as `some`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#some some}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#some some}.\n */\n\n/**\n * @name CollectionResource#someSeries\n *\n * @function\n *\n * @description\n * The same interface as `some`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#some some}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#some some}.\n */\n\n/**\n * @name  CollectionResource#sortBy\n *\n * @function\n *\n * @description\n * Visit each resource in the collection and return the resources in a sorted\n * array. The sort is determined by the sortable value that you your return in\n * the `iterator`.\n *\n * @param {Function} iterator\n * The function to call for each resource in the collection. Will be called\n * with `(resource, next)`. The `next(err, sortableValue)` function must be\n * called to advance to the next resource. If an `err` value is passed to next,\n * the iteration will stop and the `doneCallback` will be called with the `err`\n * value.\n *\n * @param {Function} doneCallback\n * The function to call when iteration has ended. Will be called with `(err,\n * test)`.\n *\n * @example\n * // Sort accounts by their birthday.\n *\n * function iterator(account, next) {\n *   next(null, account.customData.birthday);\n * }\n *\n * function doneCallback(err, sortedAccounts) {\n *   if (!err) {\n *     console.log(sortedAccounts);\n *   }\n * }\n *\n * application.getAccounts({ expand: 'customData' }, function (err, collection) {\n *   if (!err) {\n *     collection.sortBy(iterator, donCallback);\n *   }\n * });\n */\n\n/**\n * @name CollectionResource#sortByLimit\n *\n * @function\n *\n * @description\n * The same interface as `sortBy`, but with a 2nd parameter that can be used to\n * limit the number of parallel workers.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#sortBy sortBy}.\n *\n * @param {Number} limit\n * The maximum number of parallel iterator workers.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#sortBy sortBy}.\n */\n\n/**\n * @name CollectionResource#sortBySeries\n *\n * @function\n *\n * @description\n * The same interface as `sortBy`, but the `iterator` will be called in series,\n * not in parallel.\n *\n * @param {Function} iterator\n * Same interface as {@link CollectionResource#sortBy sortBy}.\n *\n * @param {Function} doneCallback\n * Same interface as {@link CollectionResource#sortBy sortBy}.\n */\n(function extendCollectionResourceWithAsyncMethods(){\n\n  function CallbackWrapper(argsLength){\n    var res = [];\n\n    this.wrapPageCallback = function wrapPageCallback(cb){\n      return function funcCallback(err, result){\n        if (argsLength === 1){\n          result = err;\n          err = null;\n        }\n\n        res = Array.prototype.concat.call(res, result);\n\n        cb(err, result);\n      };\n    };\n\n    this.wrapCallback = function(callback){\n      return function(err){\n        if (argsLength === 1){\n          return callback(res);\n        }\n        callback(err, res);\n      };\n    };\n  }\n\n  function Every(){\n    var res = true;\n    var that = this;\n    this.isDone = false;\n\n    this.wrapPageCallback = function wrapPageCallback(cb){\n      return function funcCallback(result){\n        that.isDone = !result;\n        res = res && result;\n        cb(result);\n      };\n    };\n\n    this.wrapCallback = function(callback ){\n      return function(){\n        callback(res);\n      };\n    };\n  }\n\n  function Some (){\n    var res = false;\n    this.isDone = false;\n    var that = this;\n    this.wrapPageCallback = function wrapPageCallback(cb){\n      return function funcCallback(result){\n        that.isDone = !!result;\n        res = res || result;\n        cb(result);\n      };\n    };\n\n    this.wrapCallback = function(callback ){\n      return function(){\n        callback(res);\n      };\n    };\n  }\n\n  function Detect(){\n    var res = null;\n    var that = this;\n    this.isDone = false;\n\n    this.wrapPageCallback = function wrapPageCallback(cb){\n      return function funcCallback(result){\n        that.isDone = !!result;\n        res = res || result;\n        cb(res);\n      };\n    };\n\n    this.wrapCallback = function(callback ){\n      return function(){\n        callback(res);\n      };\n    };\n  }\n\n  function Reduce(){\n    var res = null;\n    this.wrapPageCallback = function wrapPageCallback(cb){\n      return function funcCallback(err, result){\n        res = result;\n        cb(err, result);\n      };\n    };\n\n    this.wrapPageArgs = function(args){\n      var memo = args[0];\n      var iter = args[1];\n      res = res || memo;\n\n      // Should be memo.\n      return [res, iter];\n    };\n\n    this.wrapCallback = function(callback ){\n      return function(err, result){\n        res = res || result;\n        callback(err, res);\n      };\n    };\n  }\n\n  function ReduceRight(){\n    var memo = null;\n    var items = [];\n    var iterator, callback;\n\n    this.wrapPageCallback = function wrapPageCallback(cb){\n      return cb;\n    };\n\n    this.wrapArgs = function(args){\n      memo = args[0];\n      iterator = args[1];\n      callback = args[2];\n      return [\n        function(item, cb){\n          items.push(item);cb();\n        },\n        function(){\n          console.log(arguments);\n        }\n      ];\n    };\n\n    this.wrapCallback = function(){\n      return function(err){\n        if (err) {\n          return callback(err);\n        }\n\n        async.reduceRight(items, memo, iterator, callback);\n      };\n    };\n  }\n\n  function SortBy(){\n    var items = [];\n    var iterator, callback;\n\n    this.wrapPageCallback = function wrapPageCallback(cb){\n      return cb;\n    };\n\n    this.wrapArgs = function(args){\n      iterator = args[0];\n      callback = args[1];\n      return [\n        function(item, cb){\n          items.push(item);cb();\n        },\n        function(){\n        }\n      ];\n    };\n\n    this.wrapCallback = function(){\n      return function(err){\n        if (err) {\n          return callback(err);\n        }\n\n        async.sortBy(items, iterator, callback);\n      };\n    };\n  }\n\n  var W1 = function(){ return new CallbackWrapper(1);};\n  var W2 = function(){ return new CallbackWrapper(2);};\n\n  var methods = {\n    each: {wrapper: W2}, eachSeries: {wrapper: W2}, eachLimit: {wrapper: W2},\n    forEach: {wrapper: W2}, forEachSeries: {wrapper: W2}, forEachLimit: {wrapper: W2},\n    map: {wrapper: W2}, mapSeries: {wrapper: W2}, mapLimit:{wrapper: W2},\n    filter: {wrapper: W1}, filterSeries: {wrapper: W1},\n    select: {wrapper: W1}, selectSeries: {wrapper: W1},\n    reject: {wrapper: W1}, rejectSeries: {wrapper: W1},\n    reduce: {wrapper: Reduce}, inject: {wrapper: Reduce}, foldl: {wrapper: Reduce},\n    reduceRight: {wrapper: ReduceRight, method: 'eachSeries'},\n    foldr: {wrapper: ReduceRight, method: 'eachSeries'},\n    detect: {wrapper: Detect},detectSeries: {wrapper: Detect},\n    sortBy: {wrapper: SortBy, method: 'eachSeries'},\n    some: {wrapper: Some}, any: {wrapper: Some},\n    every: {wrapper: Every}, all: {wrapper: Every},\n    concat: {wrapper: W2},concatSeries: {wrapper: W2}\n  };\n\n  function wrap(func, Wrapper){\n    return function(){\n      var args = Array.prototype.slice.call(arguments);\n\n      if (typeof args[args.length - 1] !== 'function' && typeof args[args.length - 2] !== 'function'){\n        // No iterator function, no callback - ignore call.\n        return;\n      }\n\n      if (typeof args[args.length - 2] !== 'function'){\n        args.push(function(){});\n      }\n\n      var wrapper = new Wrapper();\n      if (wrapper.wrapArgs){\n        args = wrapper.wrapArgs(args);\n      }\n      wrapAsyncCallToAllPages(this, func, args, wrapper);\n    };\n  }\n\n  _.each(methods, function(opts, method){\n    CollectionResource.prototype[method] = wrap(async[opts.method || method], opts.wrapper);\n  });\n})();\n\nmodule.exports = CollectionResource;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/CustomData.js":"'use strict';\n\nvar _ = require('underscore');\nvar async = require('async');\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\nvar RESERVED_FIELDS_HREF = ['href','createdAt', 'modifiedAt',\n  'meta', 'spMeta', 'spmeta', 'ionmeta', 'ionMeta'];\nvar RESERVED_FIELDS = ['createdAt', 'modifiedAt',\n  'meta', 'spMeta', 'spmeta', 'ionmeta', 'ionMeta'];\n\n/**\n * @class CustomData\n *\n * @description\n *\n * Encapsulates a CustomData resource. For full documentation of this resource,\n * please see\n * [REST API Reference: Custom Data](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#custom-data).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Account#getCustomData Account.getCustomData()}\n * - {@link Application#getCustomData Application.getCustomData()}\n * - {@link Directory#getCustomData Directory.getCustomData()}\n * - {@link Group#getCustomData Group.getCustomData()}\n * - {@link Organization#getCustomData Organization.getCustomData()}\n * - {@link Tenant#getCustomData Tenant.getCustomData()}\n *\n * @param {Object} customDataResource\n *\n * The JSON representation of this resource.\n *\n * @example\n * account.getCustomData(function(err, customData){\n *   customData.favoriteColor = 'blue';\n *   customData.save(function(err){\n *     if(!err) {\n *       console.log('Favorite color was saved');\n *     }\n *   });\n * });\n */\n\nfunction CustomData() {\n  CustomData.super_.apply(this, arguments);\n\n  var _removedFields = null;\n  Object.defineProperty(this, '_removedFields', {\n    get: function getRemovedFields() {\n      return _removedFields;\n    },\n    set: function setRemovedFields(removedFields) {\n      _removedFields = removedFields;\n    }\n  });\n  this._removedFields = [];\n}\nutils.inherits(CustomData, InstanceResource);\n\nCustomData.prototype._hasRemovedProperties = function hasRemovedProperties(){\n  return 0 !== this._removedFields.length;\n};\n\nCustomData.prototype._deleteRemovedProperties = function deleteRemovedProperties(cb){\n  var self = this;\n\n  function removeField(fieldName, callback){\n    var href = self.href;\n    href += self.href[self.href.length-1] !== '/'?'/':'';\n    href += fieldName;\n    self.dataStore.deleteResource({href: href}, callback);\n  }\n\n  async.eachLimit(self._removedFields, 5, removeField, function (err){\n    if (err){\n      return cb(err);\n    }\n\n    self._removedFields.length = 0;\n    cb();\n  });\n};\n\nCustomData.prototype._hasReservedFields = function hasReservedFields(){\n  var self = this;\n  return RESERVED_FIELDS.filter(function(field){\n    return self.hasOwnProperty(field);\n  }).length > 0;\n};\n\n/**\n * CustomData only resource that has reserved fields and can not be saved directly\n * @returns {object} - return instance of CustomData resource without reserved properties\n * @private\n */\nCustomData.prototype._deleteReservedFields = function deleteReservedFields(){\n  var resource = require('../resource/ResourceFactory').instantiate(CustomData, _.omit(this, RESERVED_FIELDS), null, this.dataStore);\n  resource._removedFields = this._removedFields;\n  return resource;\n};\n\nCustomData.prototype.remove = function removeCustomDataField(fieldName){\n  if (fieldName in RESERVED_FIELDS_HREF){\n    return this;\n  }\n  delete this[fieldName];\n  this._removedFields.push(fieldName);\n  return this;\n};\n\n/**\n * Save changes to this custom data resource.\n *\n * @param {Function} callback\n * The function to call when the save operation is complete. Will be called\n * with the parameters (err, updatedCustomDataResource).\n */\nCustomData.prototype.save = function saveCustomData(cb){\n  var self = this;\n  var resource;\n\n  // If the user deleted any properties, then before we save() the new data,\n  // we'll remove any deleted properties.\n  self._deleteRemovedProperties(function(){\n\n    // At this point, we've finished deleting any properties the user has\n    // removed. So we are at an interesting point -- two things could be true\n    // here:\n    //\n    //   - Either there is still data left to actually save(), or\n    //   - There is no data to save, as the user ONLY deleted stuff.\n    //\n    // In the event of #2, we MUST ABORT the save(), otherwise we'll get an\n    // error (as Stormpath will fail the API call if we try to save nothing).\n    //\n    // So what I'm doing below is this: explicitly avoiding a call to save() if\n    // there is no data remaining.\n    resource = self._deleteReservedFields();\n\n    // We need to remove all of the non-data properties from the resource\n    // before attempting to save() it. Since this is a CustomData object, we\n    // have to remove all methods, as well as the href property.\n    Object.keys(resource).forEach(function(key) {\n      if (key === 'href' || typeof resource[key] === 'function') {\n        delete resource[key];\n      }\n    });\n\n    // Once we've finished *purging* the resource object, we can then either\n    // skip the save(), or process it and continue.\n    if (Object.keys(resource).length > 0) {\n      return self.dataStore.saveResource(self._deleteReservedFields(), cb);\n    }\n\n    cb();\n  });\n};\n\nmodule.exports = CustomData;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/FactorInstantiator.js":"'use strict';\n\nvar utils = require('../utils');\nvar Factor = require('./Factor');\nvar SmsFactor = require('./SmsFactor');\nvar GoogleAuthenticatorFactor = require('./GoogleAuthenticatorFactor');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n* Retrieves the constructor for a correct {@link Factor} instance ({@link SmsFactor} or\n* {@link GoogleAuthenticatorFactor}) for corresponding JSON data for the factor.\n*\n* @private\n*\n* @param {FactorData} factor\n* The data for the factor object\n*\n* @throws Error If the type is not defined or if it is not a valid type (SMS or google-authenticator)\n*/\nfunction getFactorConstructor(/* factor */) {\n  var data = arguments[0];\n\n  if (!data || (typeof data.type === 'undefined')) {\n    throw new Error('Factor instances must have a defined type');\n  }\n\n  var type = data.type.toLowerCase();\n\n  switch (type) {\n  case 'sms':\n    return SmsFactor;\n  case 'google-authenticator':\n    return GoogleAuthenticatorFactor;\n  default:\n    return Factor;\n  }\n}\n\n/**\n* @private\n*\n* @class FactorInstantiator\n*\n* @description\n* The constructor for {@link Factor} instances ({@link SmsFactor} or\n* {@link GoogleAuthenticatorFactor}). It parses the data to construct the\n* correct constructor, and calls it with the data. It is used for polymorphic\n* factor instantiation. It augments {@link InstanceResource} to adhere to the\n* interface used for instantiation in {@link ResourceFactory}.\n*\n* @augments InstanceResource\n*/\nfunction FactorInstantiator() {\n  var Ctor = getFactorConstructor.apply(this, arguments);\n  var argsWithContext = Array.prototype.slice.call(arguments);\n\n  // Adds an initial parameter. It will be the function context (this)\n  // for the bind call. It does not matter because `new` overwrites, it,\n  // however, so we're just setting it to null here for syntactic reasons.\n  argsWithContext.unshift(null);\n\n  return new (Ctor.bind.apply(Ctor, argsWithContext))();\n}\n\nutils.inherits(FactorInstantiator, InstanceResource);\n\nmodule.exports = {\n  Constructor: FactorInstantiator,\n  getConstructor: getFactorConstructor\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Factor.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class Factor\n *\n * @description\n *\n * Encapsulates a Factor resource, used for purposes of Multi-Factor Authentication.\n * For full documentation of this resource,\n * please see\n * [REST API Reference: Factor](https://docs.stormpath.com/rest/product-guide/latest/reference.html#ref-factor).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Account#createFactor Account.createFactor()}\n * - {@link Account#getFactors Account.getFactors()}\n * - {@link Challenge#getFactor Challenge.getFactor()}\n * - {@link Client#getFactor Client.getFactor()}\n *\n * Additionally, raw instances of Factor should never be used. Instead, it is extended\n * by concrete {@link SmsFactor} or {@link GoogleAuthenticatorFactor} resources, which\n * should be used instead, and will be passed to all callbacks.\n *\n * @augments {InstanceResource}\n *\n * @param {Object} factorResource\n *\n * The JSON representation of this resource.\n */\nfunction Factor() {\n  Factor.super_.apply(this, arguments);\n}\n\nutils.inherits(Factor, InstanceResource);\n\n/**\n* Retrieves the {@link Account} this factor belongs to.\n*\n* @param {ExpansionOptions} [expansionOptions]\n* For retrieving linked resources of the {@link Account} for this request.\n* This resource supports expansions for `customData`, `tenant`, `directory`,\n* `groups`, and `groupMemberships`. Groups and group memberships can also be\n* expanded and paginated.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called with\n* (err, {@link Account}).\n*/\nFactor.prototype.getAccount = function getFactorAccount(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.account.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n* Retrieves a list of challenges for this factor.\n*\n* @param {CollectionQueryOptions} options\n* Options for querying, filtering, sorting, paginating and expanding the query. It can be expanded\n* on `account` and `factor` fields.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called\n* with the parameters (err, {@link CollectionResource}). The collection will\n* be a list of {@link Challenge} objects.\n*\n*/\nFactor.prototype.getChallenges = function getFactorChallenges(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.challenges.href, args.options, require('./Challenge'), args.callback);\n};\n\n/**\n * Retrieves the most recent challenge for this factor, or null if none is defined.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Challenge} during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link Challenge}), or (err, null) if there is no most recent\n * challenge available.\n*/\nFactor.prototype.getMostRecentChallenge = function getMostRecentChallenge(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  if (!this.mostRecentChallenge || !this.mostRecentChallenge.href) {\n    return process.nextTick(args.callback.bind(null, null, null));\n  }\n\n  return this.dataStore.getResource(this.mostRecentChallenge.href, args.options, require('./Challenge'), args.callback);\n};\n\nmodule.exports = Factor;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/SmsFactor.js":"'use strict';\n\nvar Factor = require('./Factor');\nvar utils = require('../utils');\n\n/**\n * @class SmsFactor\n *\n * @description\n *\n * Encapsulates a Factor resource, used for purposes of Multi-Factor Authentication.\n * This type of Factor uses SMS as a multi-factor authentication method.\n * For full documentation of this resource,\n * please see\n * [REST API Reference: Creating a Factor](https://docs.stormpath.com/rest/product-guide/latest/reference.html#creating-a-factor).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Account#createFactor Account.createFactor()}\n * - {@link Account#getFactors Account.getFactors()}\n * - {@link Challenge#getFactor Challenge.getFactor()}\n * - {@link Client#getFactor Client.getFactor()}\n *\n * @augments {Factor}\n *\n * @param {Object} factorResource\n *\n * The JSON representation of this resource.\n */\nfunction SmsFactor() {\n  SmsFactor.super_.apply(this, arguments);\n}\n\nutils.inherits(SmsFactor, Factor);\n\n\n/**\n * Create a {@link Challenge} for this factor, which is used to start the multi-factor\n * authentication procedure.  This will send an SMS message to the user with the\n * code.  For more information about this process, See\n * {@link https://docs.stormpath.com/rest/product-guide/latest/auth_n.html#challenging-an-sms-factor Challenging an SMS Factor}.\n *\n * @param {Object} [challenge]\n * An object literal for configuring the challenge.  If this object is not provied,\n * a default challenge message will be sent.\n *\n * @param {String} challenge.message\n * The message to be sent to the user.\n *\n * @param {Object} [requestOptions]\n * Query parameters for this request. These can be any of the {@link ExpansionOptions},\n * e.g. to retrieve linked resources of the new {@link Challenge} during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link Challenge}).\n *\n * @example\n * var challenge = {\n *   message: 'Your verification code is: ${code}'\n * };\n *\n * smsFactor.createChallenge(challenge, function(err, createdChallenge) {\n *   if (err) {\n *     return console.log(err);\n *   }\n *   console.log(createdChallenge);\n * });\n*/\nSmsFactor.prototype.createChallenge = function createFactorChallenge(/* challenge, [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['challenge', 'options', 'callback'], true);\n  return this.dataStore.createResource(this.challenges.href, args.options, args.challenge, require('./Challenge'), args.callback);\n};\n\n\n/**\n * Retrieves the phone to which the multi-factor authentication SMS is sent to.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Phone} during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link Phone}).\n*/\nSmsFactor.prototype.getPhone = function getPhone(/* callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.phone.href, args.options, require('./Phone'), args.callback);\n};\n\nmodule.exports = SmsFactor;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/GoogleAuthenticatorFactor.js":"'use strict';\n\nvar Factor = require('./Factor');\nvar utils = require('../utils');\n\n/**\n * @class GoogleAuthenticatorFactor\n *\n * @description\n *\n * Encapsulates a Factor resource, used for purposes of Multi-Factor Authentication.\n * This type of Factor uses Google Authenticator as a multi-factor authentication method.\n * For full documentation of this resource,\n * please see\n * [REST API Reference: Creating a Factor](https://docs.stormpath.com/rest/product-guide/latest/reference.html#creating-a-factor).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Account#createFactor Account.createFactor()}\n * - {@link Account#getFactors Account.getFactors()}\n * - {@link Challenge#getFactor Challenge.getFactor()}\n * - {@link Client#getFactor Client.getFactor()}\n *\n * @augments {Factor}\n *\n * @param {Object} factorResource\n *\n * The JSON representation of this resource.\n */\nfunction GoogleAuthenticatorFactor() {\n  GoogleAuthenticatorFactor.super_.apply(this, arguments);\n}\n\nutils.inherits(GoogleAuthenticatorFactor, Factor);\n\n/**\n * Create a {@link Challenge} resource for this factor.  The new challenge resource\n * will have a status of `CREATED`.  Once the user provides a code from their Google\n * Authenticator application, you will verify it with `challenge.verifyCode()`\n *\n * @param {Object} [requestOptions]\n * Query parameters for this request. These can be any of the {@link ExpansionOptions},\n * e.g. to retrieve linked resources of the new {@link Challenge} during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link Challenge}).\n *\n * @example\n *\n * googleAuthenticatorFactor.createChallenge(function(err, createdChallenge) {\n *   if (err) {\n *     return console.log(err)\n *   }\n *\n *   console.log(createdChallenge);\n * });\n */\nGoogleAuthenticatorFactor.prototype.createChallenge = function createFactorChallenge(/* callback */) {\n  var args = utils.resolveArgs(arguments, ['options','callback'], true);\n  return this.dataStore.createResource(this.challenges.href, args.options, null, require('./Challenge'), args.callback);\n};\n\nmodule.exports = GoogleAuthenticatorFactor;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/error/invalid-href.js":"'use strict';\n\n/**\n * Produces an Erorr object with a message that indicates which resource type has\n * violated an href validation.\n *\n * @param      {string}  href          The href that was passed into a resource getter.\n * @param      {string}  resourceName  The human readable name of the expected resource type.\n * @return     {Error}   A simple error with the message\n */\nfunction InvalidHrefError(href, resourceName){\n  var message = 'Argument \\'href\\' (' + href + ') is not a valid ' + resourceName +' href.';\n  return new Error(message);\n}\n\nmodule.exports = InvalidHrefError;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/proxy/ObjectCallProxy.js":"/**\n * Create a new ObjectCallProxy.\n *\n * @class\n *\n * @private\n */\nfunction ObjectCallProxy (source) {\n  this.source = source;\n  this.attached = {};\n  this.pending = [];\n}\n\n/**\n * Restore all of the attached methods.\n *\n * @private\n */\nObjectCallProxy.prototype._restore = function () {\n  for (var name in this.attached) {\n    this.source[name] = this.attached[name];\n    delete this.attached[name];\n  }\n};\n\n/**\n * Release all of the pending callbacks.\n *\n * @private\n * @param {Error} [err] - Error to release all callbacks with (optional).\n */\nObjectCallProxy.prototype._release = function (err) {\n  var source = this.source;\n  var pending = this.pending;\n\n  this.pending = [];\n\n  pending.forEach(function (call) {\n    var fn = call.fn;\n    var args = call.args;\n    var callback = call.callback;\n\n    args[args.length - 1] = function () {\n      var subArgs = err ? [err] : Array.prototype.slice.call(arguments);\n      callback.apply(null, subArgs);\n    };\n\n    fn.apply(source, args);\n  });\n};\n\n/**\n * Attach onto the source object and intercept all calling\n * methods with callbacks (where last argument is function).\n *\n * @param fn [predicateFn] - Predicate to filter methods by (optional).\n */\nObjectCallProxy.prototype.attach = function (predicateFn) {\n  var source = this.source;\n  var pending = this.pending;\n  var attached = this.attached;\n\n  if (!predicateFn) {\n    predicateFn = function () {\n      return true;\n    };\n  }\n\n  function _attach (name) {\n    if (!(name in attached)) {\n      var originalFn = source[name];\n\n      attached[name] = originalFn;\n\n      source[name] = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var lastArgumentOffset = args.length - 1;\n\n        if (args.length && typeof args[lastArgumentOffset] === 'function') {\n          pending.push({\n            args: args,\n            callback: args[lastArgumentOffset],\n            fn: originalFn\n          });\n        } else {\n          return originalFn.apply(source, args);\n        }\n      };\n    }\n  }\n\n  // Proxy all methods on source object.\n  for (var name in source) {\n    var value = source[name];\n\n    // If a predicate is provided, then filter accordingly.\n    if (!predicateFn(name)) {\n      continue;\n    }\n\n    if (typeof value === 'function') {\n      _attach(name);\n    }\n  }\n};\n\n/**\n * Detach all attached methods and release any pending calls.\n *\n * @param {Error} [err] - Error to release all callbacks with (optional).\n */\nObjectCallProxy.prototype.detach = function (err) {\n  this._restore();\n  this._release(err);\n};\n\nmodule.exports = ObjectCallProxy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Tenant.js":"'use strict';\n\nvar _ = require('underscore');\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class Tenant\n *\n * @description\n * Encapsulates a Stormpath Tenant resource, which is the root node of all the\n * resources for a given tenant. For full documentation of this resource, please see\n * [REST API Reference: Tenant](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#tenant).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Client#getCurrentTenant Client.getCurrentTenant()}\n * - {@link AccountLinkingPolicy#getTenant AccountLinkingPolicy.getTenant()}\n *\n * For convenience, some of these methods also exist on an instance of {@link Client},\n * where they are bound to the current tenant, as identified by the API Key Pair\n * that was passed to the Client constructor.\n *\n * @param {Object} tenantResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction Tenant() {\n  Tenant.super_.apply(this, arguments);\n}\n\nutils.inherits(Tenant, InstanceResource);\n\n/**\n * Get the collection of {@link Account accounts} for this tenant.\n *\n * @param {CollectionQueryOptions} [options]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Account} objects.\n */\nTenant.prototype.getAccounts = function getTenantAccounts(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accounts.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n * Get the collection of {@link Group groups} for this tenant.\n *\n * @param {CollectionQueryOptions} [options]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Group} objects.\n */\nTenant.prototype.getGroups = function getTenantGroups(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.groups.href, args.options, require('./Group'), args.callback);\n};\n\n/**\n * Get the collection of {@link Application applications} for this tenant.\n *\n * @param {CollectionQueryOptions} [options]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Application} objects.\n */\nTenant.prototype.getApplications = function getTenantApplications(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.applications.href, args.options, require('./Application'), args.callback);\n};\n\n/**\n * Get the collection of {@link Organization organizations} for this tenant.\n *\n * @param {CollectionQueryOptions} [options]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Organization} objects.\n */\nTenant.prototype.getOrganizations = function getTenantOrganizations(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.organizations.href, args.options, require('./Organization'), args.callback);\n};\n\n/**\n * Creates a new Application resource.\n *\n * @param {Object} application\n * The {@link Application} resource to create.\n *\n * @param {Object} [requestOptions]\n * Query parameters for this request. These can be any of the {@link ExpansionOptions},\n * e.g. to retrieve linked resources of the {@link Application} during this request, or one\n * of the other options listed below.\n *\n * @param {Boolean|String} [requestOptions.createDirectory]\n * Set this to `true` to have a a new {@link Directory} automatically created along with the Application.\n * The generated Directory’s name will reflect the new Application’s name as best as is possible,\n * guaranteeing that it is unique compared to any of your existing Directories. If you would like\n * a different name, simply put the value you would like instead of `true`.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Application}).\n */\nTenant.prototype.createApplication = function createTenantApplication(/* app, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['app', 'options', 'callback']);\n  this.dataStore.createResource('/applications', args.options, args.app, require('./Application'), args.callback);\n};\n\n/**\n * Creates a new {@link Organization} resource. After creating a organization, you will\n * likely want to map it to an {@link Application} using\n * {@link Application#createAccountStoreMapping Application.createAccountStoreMapping()}.\n *\n * @param {Object} organization\n * The {@link Organization} resource to create.\n *\n * @param {ExpansionOptions} [options]\n * Options to expand linked resources on the returned {@link Organization}.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Organization}).\n */\nTenant.prototype.createOrganization = function createTenantOrganization(/* app, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['app', 'options', 'callback']);\n  this.dataStore.createResource('/organizations', args.options, args.app, require('./Organization'), args.callback);\n};\n\n/**\n * Get the collection of {@link Directory directories} for this tenant.\n *\n * @param {CollectionQueryOptions} [options]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Directory} objects.\n */\nTenant.prototype.getDirectories = function getTenantDirectories(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.directories.href, args.options, require('./Directory'), args.callback);\n};\n\n/*\n * Creates a new {@link Directory} resource. After creating a directory, you will\n * likely want to map it to an {@link Application} using\n * {@link Application#createAccountStoreMapping Application.createAccountStoreMapping()}.\n *\n * @param {Object} directory\n * The {@link Directory} resource to create.\n *\n * @param {ExpansionOptions} [options]\n * Options to expand linked resources on the returned {@link Directory}.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Directory}).\n *\n */\nTenant.prototype.createDirectory = function createTenantDirectory(/* dir, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['dir', 'options', 'callback']);\n\n  if (args.dir.provider){\n    args.options = _.extend(args.options || {}, {expand:'provider'});\n  }\n\n  this.dataStore.createResource('/directories', args.options, args.dir, require('./Directory'), args.callback);\n};\n\n/**\n * Creates a new SmtpServer resource.\n *\n * @param {Object} server\n * The {@link SmtpServer} resource to create.\n *\n * @param {ExpansionOptions} [options]\n * Options to expand linked resources on the returned {@link SmtpServer}.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link SmtpServer}).\n */\nTenant.prototype.createSmtpServer = function createSmtpServer(/* server, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['server', 'options', 'callback']);\n  this.dataStore.createResource('/smtpServers', args.options, args.server, require('./SmtpServer'), args.callback);\n};\n\n/**\n * Verifies an account-specific email verification token, obtaining the verified\n * Account and providing it to the specified callback.  This is the token that\n * is sent to the user by email, so they need to click on the link and arrive on\n * your site with this query parameter in the URL.  Once you fetch the parameter\n * from the URL you will call this function.\n *\n * @param {String} token\n * The token that was sent to the user.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link Account}).\n *\n * @example\n * var token = '2QTr9Gzzq444ojxq3H9NQX';\n *\n * tenant.verifyAccountEmail(token, function (err, account) {\n *   console.log(account);\n * });\n */\nTenant.prototype.verifyAccountEmail = function verifyAccountEmail(token, callback) {\n  var dataStore = this.dataStore;\n  var href = \"/accounts/emailVerificationTokens/\" + token;\n\n  return dataStore.createResource(href, null, null, function(err,result){\n    if(err){\n      callback(err);\n    }else{\n      dataStore._evict(result.href, function (err) {\n        if(err){\n          callback(err);\n        }else{\n          dataStore.getResource(result.href,{nocache:true},require('./Account'),callback);\n        }\n      });\n    }\n  });\n};\n\n/**\n * Gets the {@link CustomData} object for this resource.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link CustomData}).\n */\nTenant.prototype.getCustomData = function getCustomData(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.customData.href, args.options, require('./CustomData'), args.callback);\n};\n\n/**\n * Retrieves all the {@link IdSiteModel} resources for this resource.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link IdSiteModel} objects.\n *\n */\nTenant.prototype.getIdSites = function getTenantIdSites(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.idSites.href, args.options, require('./IdSiteModel'), args.callback);\n};\n\n/**\n * Retrieves all the {@link SmtpServer} resources for this resource.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link SmtpServer} objects.\n *\n */\nTenant.prototype.getSmtpServers = function getSmtpServers(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.smtpServers.href, args.options, require('./SmtpServer'), args.callback);\n};\n\n/**\n * Creates a link between two given accounts. If the two accounts are already\n * linked, this will error. The designations \"left\" and \"right\" are purely\n * arbitrary and imply no hierarchy or ordering between the accounts.\n *\n * @param {Account} leftAccount\n * One of the accounts to create a link between.\n *\n * @param {Account} rightAccount\n * Other one of the accounts to create a link between.\n *\n * @param {ExpansionOptions} [options]\n * Options to expand the returned {@link AccountLink} resource.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link AccountLink}).\n *\n * @example\n *\n * var leftAccount = {\n *  href: 'https://api.stormpath.com/v1/accounts/1oS9pRJ8we097h882rhWyb'\n * };\n *\n * var rightAccount = {\n *  href: 'https://api.stormpath.com/v1/accounts/xbohsiHoGq0qRGW4c0hqd'\n * };\n *\n * tenant.createAccountLink(leftAccount, rightAccount, function (err, accountLink) {\n *   if (!err) {\n *     console.log('Account Link Created', accountLink);\n *   }\n * });\n */\nTenant.prototype.createAccountLink = function createAccountLink(/* leftAccount, rightAccount, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['leftAccount', 'rightAccount', 'options', 'callback']);\n\n  var accountLink = {\n    leftAccount: {\n      href: args.leftAccount.href\n    },\n    rightAccount: {\n      href: args.rightAccount.href\n    }\n  };\n\n  return this.dataStore.createResource('/accountLinks', args.options, accountLink, require('./AccountLink'), args.callback);\n};\n\nmodule.exports = Tenant;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/saml/SamlIdpUrlBuilder.js":"'use strict';\n\nvar njwt = require('njwt');\nvar uuid = require('uuid');\nvar querystring = require('querystring');\n\nvar utils = require('../utils');\n\n/**\n * Creates a URL builder that can build SAML IDP redirect URLs.  This is done\n * when Stormpath is initiating a redirect to a SAML IDP.\n * For more information, please see\n * [Authenticating Against a SAML Directory](http://docs.stormpath.com/rest/product-guide/latest/auth_n.html#authenticating-against-a-saml-directory).\n *\n * This authenticator is bound to the application that you pass to the constructor.\n *\n * @class\n *\n * @param {Application} application\n *\n * The Stormpath Application that will issue the redirect. This application must\n * be mapped to the relevant SAML Directories.\n *\n * @example\n *\n * var builder = new stormpath.SamlIdpUrlBuilder(application);\n */\nfunction SamlIdpUrlBuilder(application) {\n  this.application = application;\n  this.apiKey = application.dataStore.requestExecutor.options.client.apiKey;\n}\n\nSamlIdpUrlBuilder.prototype._getServiceProvider = function _getServiceProvider(callback) {\n  this.application.getSamlPolicy(function (err, samlPolicy) {\n    if (err) {\n      return callback(err);\n    }\n\n    samlPolicy.getServiceProvider(callback);\n  });\n};\n\nSamlIdpUrlBuilder.prototype._buildInitializationUrl = function _buildInitializationUrl(initEndpointUrl, parameters) {\n  return initEndpointUrl + '?' + querystring.stringify(parameters);\n};\n\n/**\n * Builds a SAML IDP Redirect URL and provides it to the specified callback.\n *\n * @param {Object} options\n * Optional claims for the [SAML Authentication JWT](http://docs.stormpath.com/rest/product-guide/latest/auth_n.html#saml-authentication-jwt).\n * Use these claims to control the callback url (`cb_url`), token state (`state`),\n * and account store target (`ash` or `onk`). The other required claims will be\n * set automatically by the builder.\n *\n * @paarm {Function} callback\n * The callback to call with the URL string that was built.  Will be called with\n * (err, urlString).\n *\n * @example\n * builder.build(function(err, url) {\n *   if (err) {\n *     console.error(err);\n *     return;\n *   }\n *   console.log(url);\n * });\n */\nSamlIdpUrlBuilder.prototype.build = function (/* [options,] callback */) {\n  var self = this;\n\n  var apiKey = this.apiKey;\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  this._getServiceProvider(function (err, serviceProvider) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    var claims = {\n      jti: uuid(),\n      iss: self.application.href,\n      iat: new Date().getTime() / 1000\n    };\n\n    var options = args.options || {};\n\n    if (options.cb_uri) {\n      claims.cb_uri = options.cb_uri;\n    }\n\n    if (options.ash) {\n      claims.ash = options.ash;\n    }\n\n    if (options.onk) {\n      claims.onk = options.onk;\n    }\n\n    if (options.state) {\n      claims.state = options.state;\n    }\n\n    var accessToken = njwt.create(claims, apiKey.secret);\n\n    accessToken.header.kid = apiKey.id;\n\n    var parameters = {\n      accessToken: accessToken.compact()\n    };\n\n    var ssoInitiationEndpoint = serviceProvider.ssoInitiationEndpoint.href;\n    var initializationUrl = self._buildInitializationUrl(ssoInitiationEndpoint, parameters);\n\n    args.callback(null, initializationUrl);\n  });\n};\n\nmodule.exports = SamlIdpUrlBuilder;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/AssertionAuthenticationResult.js":"'use strict';\n\nvar Account = require('../resource/Account');\n\n/**\n * Encapsulates the authentication result from an instance of {@link StormpathAssertionAuthenticator}.\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n *\n * - {@link StormpathAssertionAuthenticator#authenticate StormpathAssertionAuthenticator.authenticate()}.\n *\n * @class\n */\nfunction AssertionAuthenticationResult(dataStore, data) {\n  Object.defineProperty(this, 'dataStore', {\n    enumerable:false,\n    value: dataStore\n  });\n\n  // Copy data properties.\n  if (data) {\n    for (var key in data) {\n      if (key in this) {\n        continue;\n      }\n      this[key] = data[key];\n    }\n  }\n}\n\n/**\n * @function\n *\n * @description Get the account resource of the account that has authenticated.\n *\n * @param  {Function} callback\n *\n * The callback to call with the parameters (err, {@link Account}).\n */\nAssertionAuthenticationResult.prototype.getAccount = function getAccount(callback) {\n  if (!this.account || !this.account.href) {\n    return callback(new Error('Unable to get account. Account HREF not specified.'));\n  }\n\n  this.dataStore.getResource(this.account.href, Account, callback);\n};\n\nmodule.exports = AssertionAuthenticationResult;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Account.js":"'use strict';\n\nvar _ = require('underscore');\nvar DirectoryChildResource = require('./DirectoryChildResource');\nvar FactorInstantiator = require('./FactorInstantiator');\nvar getFactorConstructor = FactorInstantiator.getConstructor;\nvar FactorInstanceCtor = FactorInstantiator.Constructor;\nvar utils = require('../utils');\n\n/**\n * @class Account\n *\n * @description\n *\n * Encapsulates a Account resource. For full documentation of this resource,\n * please see\n * [REST API Reference: Account](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#account).\n *\n * For more information about managing your accounts with Stormpath, please see\n * {@link https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt Account Management}.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Application#getAccount Application.getAccount()}\n * - {@link Application#getAccounts Application.getAccounts()}\n * - {@link Client#getAccount Client.getAccount()}\n * - {@link Directory#getAccounts Directory.getAccounts()}\n * - {@link Group#getAccounts Group.getAccounts()}\n * - {@link Organization#getAccounts Organization.getAccounts()}\n * - {@link Phone#getAccount Phone.getAccount()}\n * - {@link Factor#getAccount Factor.getAccount()}\n *\n * @augments {DirectoryChildResource}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} accountResource\n *\n * The JSON representation of this resource.\n */\nfunction Account(data) {\n  Account.super_.apply(this, arguments);\n\n  Object.defineProperty(this, '_isNew', {value: !!data._isNew, configurable: true});\n}\nutils.inherits(Account, DirectoryChildResource);\n\n/**\n * @typedef {Object} AccountData\n *\n * @description\n *\n * This object represents that data that can be provided when creating a new\n * account with one of these methods:\n *\n * - {@link Application#createAccount Application.createAccount()}\n * - {@link Directory#createAccount Directory.createAccount()}\n * - {@link Organization#createAccount Organization.createAccount()}\n *\n * @property {Object} [customData={}]\n * Custom key/value data that you wish to store in this account's custom data\n * resource.\n *\n * @property {String} email\n * User's email address.\n *\n * @property {String} givenName\n * User's first name.\n *\n * @property {String} [middleName]\n * User's middle name.\n *\n * @property {String} password\n * User's desired password, must meet password strength requirements of the\n * default account store.\n *\n * @property {String} surname\n * User's last name.\n *\n * @property {String} [status=UNVERIFIED|ENABLED]\n * Sets the status flag of the account, one of `ENABLED`, `DISABLED`,\n * `UNVERIFIED`. If not specified, will default to `UNVERIFIED` if email\n * verification is enabled on the default account store. Otherwise the default\n * is `ENABLED`.\n *\n * @property {String} [username]\n * User's desired username.\n */\n\n/**\n * Retrieves the collection of access tokens that have been issued to this\n * account.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * does not support attribute or filter searches.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link AccessToken} objects.\n */\nAccount.prototype.getAccessTokens = function getAccessTokens(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accessTokens.href, args.options, require('./AccessToken'), args.callback);\n};\n\n/**\n * Retrieves the collection of refresh tokens that have been issued to this\n * account.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * does not support attribute or filter searches.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link RefreshToken} objects.\n */\nAccount.prototype.getRefreshTokens = function getRefreshTokens(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.refreshTokens.href, args.options, require('./RefreshToken'), args.callback);\n};\n\n/**\n * Retrieves the collection of groups that this account is a member of.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `name`, `description`, `status`, `createdAt`, `modifiedAt`.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Group} objects.\n */\nAccount.prototype.getGroups = function getAccountGroups(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.groups.href, args.options, require('./Group'), args.callback);\n};\n\n/**\n * Retrieves the collection of group memberships for this account. Group\n * memberships are a resource that represent the link between an account and\n * group.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * does not support attribute or filter searches.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link GroupMembership} objects.\n */\nAccount.prototype.getGroupMemberships = function getGroupMemberships(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.groupMemberships.href, args.options, require('./GroupMembership'), args.callback);\n};\n\n/**\n * Adds the account to the given group.\n *\n * @param {Object|String} group\n * If this parameter is a string, it should be the HREF of the group that the\n * account will be added to.\n *\n * If it is an object, it should have an href property which is the group href.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link GroupMembership}).\n *\n * @example\n *\n * var groupHref = 'https://api.stormpath.com/v1/groups/xxx';\n * account.addToGroup(groupHref, callbackFn);\n *\n * @example\n *\n * var group = {\n *   href: 'https://api.stormpath.com/v1/groups/xxx';\n * };\n *\n * account.addToGroup(group, callbackFn);\n *\n * @example\n *\n * var groupHref = 'https://api.stormpath.com/v1/groups/xxx';\n * client.getGroup(groupHref, function(err, group) {\n *   account.addToGroup(group, callbackFn);\n * });\n */\nAccount.prototype.addToGroup = function addAccountToGroup(/* groupOrGroupHref, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['group', 'options', 'callback'], true);\n\n  if (typeof args.group === 'string') {\n    args.group = {\n      href: args.group\n    };\n  }\n\n  return this._createGroupMembership(this, args.group, args.options, args.callback);\n};\n\n/**\n * Get the account's provider data resource. The provider data resource\n * contains information about this account's link to a third-party provider,\n * such as Google.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link ProviderData}).\n */\nAccount.prototype.getProviderData = function getProviderData(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  if (!this.providerData) {\n    return args.callback();\n  }\n\n  return this.dataStore.getResource(this.providerData.href, args.options, require('./ProviderData'), args.callback);\n};\n\n/**\n * Creates an {@link ApiKey} for this account, which can be used to\n * authenticate a request to your service. For more information please read\n * {@link http://docs.stormpath.com/guides/api-key-management/ Using Stormpath for API Authentication}.\n *\n * @param  {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link ApiKey}).\n */\nAccount.prototype.createApiKey = function createApiKey(options, callback) {\n  var cb = typeof options === 'function' ? options : callback;\n  var opts = _.extend({}, this.dataStore.apiKeyEncryptionOptions, typeof options === 'object' ? options : {});\n\n  return this.dataStore.createResource(this.apiKeys.href, opts, null, require('./ApiKey'), cb);\n};\n\n/**\n* Create a {@link SmsFactor} or {@link GoogleAuthenticatorFactor} for this account,\n* which can be challenged for multi-factor authentication.  For more information on\n* this feature, please read [Using Multi-Factor Authentication](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html#using-multi-factor-authentication).\n*\n* @param {Object} factor\n* An object literal that describes the factor to create, the type must be\n* specified.  If this is an SMS factor, you can optionally describe the challenge,\n* which will be automatically created and sent to the phone number.\n*\n* @param {Object} [factor.challenge]\n* An object literal that describes the {@link Challenge} object to automatically\n* create.\n*\n* @param {String} factor.challenge.message\n* The message for the challenge, which must include the placeholder `${code}`.\n*\n* @param {Object} [factor.phone]\n* For SMS factors, an object literal that describes the {@link Phone} resource\n* that will be created.\n*\n* @param {String} factor.phone.number\n* The phone number to send challenge codes to.\n*\n* @param {String} factor.type\n* Must be `sms` or `google-authenticator`.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called with the\n* parameters (err, {@link SmsFactor}) or (err, {@link GoogleAuthenticatorFactor}),\n* depending on the specified type.\n*\n* @example <caption>Creating an SMS Factor.</caption>\n* var factor = {\n*   type: 'sms',\n*   phone: {\n*     number: '+14151231234'\n*   }\n* };\n*\n* account.createFactor(factor, function(err, smsFactor) {\n*   if (err) {\n*     return console.log(err);\n*   }\n*\n*   console.log(smsFactor);\n* });\n*\n* @example <caption>Creating a Google Authenticator factor.</caption>\n* var factor = {\n*   type: 'google-authenticator'\n* };\n*\n* account.createFactor(factor, function(err, googleAuthenticatorFactor) {\n*   if (err) {\n*     return console.log(err);\n*   }\n*\n*   console.log(googleAuthenticatorFactor);\n* });\n*/\nAccount.prototype.createFactor = function createFactor(/* factor, callback */) {\n  var args = utils.resolveArgs(arguments, ['factor', 'options', 'callback']);\n  var FactorCtor = getFactorConstructor.call(this, args.factor);\n\n  return this.dataStore.createResource(this.factors.href, args.options, args.factor, FactorCtor, args.callback);\n};\n\n/**\n* Retrieves a list of factors for this account.\n*\n* @param {CollectionQueryOptions} collectionQueryOptions\n* Options for querying, paginating, and expanding the collection. This collection\n* supports filter on the `type` field.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called\n* with the parameters (err, {@link CollectionResource}). The collection will\n* be a list of {@link SmsFactor} and {@link GoogleAuthenticatorFactor} objects,\n* automatically instantiated to their correct type.\n*/\nAccount.prototype.getFactors = function getAccountFactors(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.factors.href, args.options, FactorInstanceCtor, args.callback);\n};\n\n/**\n* Retrieves a list of phone entries belonging to this account.\n*\n* @param {CollectionQueryOptions} collectionQueryOptions\n* Additional query options for querying, filtering, sorting and paginating the {@link Phone}\n* collection. It can be filtered via the `number`, `status`, `verificationStatus`, `name`,\n* and `description` fields.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called\n* with the parameters (err, {@link CollectionResource}). The collection will be\n* a list of {@link Phone} objects.\n*/\nAccount.prototype.getPhones = function getAccountPhones(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.phones.href, args.options, require('./Phone'), args.callback);\n};\n\n/**\n * Retrieves a collection of the account's API Keys.\n *\n * The `secret` property of each resource is encrypted with the tenant API Key\n * Secret that was used to configure the current {@link Client} instance. We do\n * this to ensure that the secret is encrypted at rest, as it may be cached in\n * your caching database.\n *\n * Password-based AES 256 encryption is used. The PBKDF2 implementation will use\n * 1024 iterations by default to derive the AES 256 key.\n *\n * At the risk of potentially decreased security, you can use the\n * `encryptionKeySize` option to specify a smaller encryption key size. You can\n * also request a lower number of key iterations with the `encryptionKeyIterations`\n * option. This can reduce the CPU time required to decrypt the key after transit\n * or when retrieving from cache. It is not recommended to go much lower than\n * 1024 (if at all) in security sensitive environments.\n *\n * @param {CollectionQueryOptions} options\n * Options for querying, paginating, and expanding the collection. This collection does not\n * support filter searches. The following options can also be used with this\n * request:\n *\n * @param {String} [options.id=null]\n * Search for a specific key by key id.\n *\n * @param {Number} [options.encryptionKeySize=256]\n * Set to 128 or 192 to change the AES key encryption size.\n *\n * @param {Number} [options.encryptionKeyIterations=1024]\n * Number of encryption iterations.\n */\nAccount.prototype.getApiKeys = function getApiKeys(options, callback) {\n  var cb = typeof options === 'function' ? options : callback;\n  var opts = _.extend({}, this.dataStore.apiKeyEncryptionOptions, typeof options === 'object' ? options : {});\n\n  return this.dataStore.getResource(this.apiKeys.href, opts, require('./ApiKey'), cb);\n};\n\n/**\n * Retrieves the collection of accounts that this account is linked to.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `createdAt`, `email`, `givenName`, `middleName`, `modifiedAt`, `surname`,\n * `status`, `username`.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Account} objects.\n */\nAccount.prototype.getLinkedAccounts = function getLinkedAccounts(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.linkedAccounts.href, args.options, Account, args.callback);\n};\n\n/**\n* Retrieves the collection of account links that are associated with the current\n* account.\n*\n* @param {CollectionQueryOptions} CollectionQueryOptions\n* Options for querying, paginating and expanding the collection. This collection\n* does not support filter searches, but it does support attribute searches by\n* `createdAt`. It allows expansion of the `leftAccount` and `rightAccount` attributes.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called with\n* the parameters (err, {@link CollectionResource}). The collection will be a\n* list of {@link AccountLink} objects.\n*/\nAccount.prototype.getAccountLinks = function getAccountLinks(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.accountLinks.href, args.options, require('./AccountLink'), args.callback);\n};\n\n/**\n * Creates a link between this account and a given account. If the two accounts\n * are already linked, this will error.\n *\n * @param {Account} linkedAccount Account to link this account to.\n *\n * @param {ExpansionOptions} [options]\n * Options to expand the returned {@link AccountLink} resource.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link AccountLink}).\n *\n * @example\n *\n * var otherAccount = {\n *   href: 'https://api.stormpath.com/v1/accounts/1oS9pRJ8we097h882rhWyb'\n * };\n *\n * account.createAccountLink(otherAccount, function (err, accountLink) {\n *   if (!err) {\n *     console.log('Account Link Created', accountLink);\n *   }\n * });\n */\nAccount.prototype.createAccountLink = function linkToAccount(/* linkedAccount, callback */) {\n  var args = utils.resolveArgs(arguments, ['linkedAccount', 'options', 'callback']);\n  var accountLink = {\n    leftAccount: {\n      href: this.href\n    },\n    rightAccount: {\n      href: args.linkedAccount.href\n    }\n  };\n\n  return this.dataStore.createResource('/accountLinks', args.options, accountLink, require('./AccountLink'), args.callback);\n};\n\n/**\n * Save changes to this account.\n *\n * @param  {Function} callback\n * The function to call when the save operation is complete. Will be called\n * with the parameters (err,updatedAccount).\n */\nAccount.prototype.save = function saveAccount() {\n  var self = this;\n\n  var args = Array.prototype.slice.call(arguments);\n\n  // If customData, then inject our own callback and invalidate the\n  // customData resource cache when the account finishes saving.\n  if (self.customData) {\n    var lastArg = args.length > 0 ? args[args.length - 1] : null;\n    var originalCallback = typeof lastArg === 'function' ? args.pop() : function nop() {};\n\n    args.push(function newCallback(err) {\n      var newCallbackArgs = arguments;\n\n      if (err) {\n        return originalCallback(err);\n      }\n\n      self.dataStore._evict(self.customData.href, function(err) {\n        if (err) {\n          return originalCallback(err);\n        }\n\n        originalCallback.apply(null, newCallbackArgs);\n      });\n    });\n  }\n\n  Account.super_.prototype.save.apply(self, args);\n};\n\nmodule.exports = Account;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/DirectoryChildResource.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class DirectoryChildResource\n */\nfunction DirectoryChildResource() {\n  DirectoryChildResource.super_.apply(this, arguments);\n}\nutils.inherits(DirectoryChildResource, InstanceResource);\n\n/**\n * Creates a group membership for a specific account.\n *\n * @private\n *\n * @param {Account|Object} account\n * An existing instance of {@link Account}, or an object literal with\n * an `href` property that identifies the account to add.\n *\n * @param {Group|Object} group\n * An existing instance of the group to create membership in, or an object literal with\n * an `href` property that identifies the group to use.\n *\n * @param {Object} options\n * Group membership options.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link GroupMembership}).\n */\nDirectoryChildResource.prototype._createGroupMembership = function createGroupMembership(account, group, options, callback) {\n  var href = '/groupMemberships';\n\n  var membership = {\n    account: {\n      href: account.href\n    },\n    group: {\n      href: group.href\n    }\n  };\n\n  return this.dataStore.createResource(href, options, membership, require('./GroupMembership'), callback);\n};\n\n/**\n * Gets the directory resource that is a parent of resource.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Directory} during this request.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link Directory}).\n */\nDirectoryChildResource.prototype.getDirectory = function getDirectoryChildResourceDirectory(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.directory.href, args.options, require('./Directory'), args.callback);\n};\n\n/**\n * Gets the Stormpath tenant resource that owns this resource.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Tenant} during this request.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link Tenant}).\n */\nDirectoryChildResource.prototype.getTenant = function getDirectoryChildResourceTenant(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.tenant.href, args.options, require('./Tenant'), args.callback);\n};\n\n/**\n * Gets the {@link CustomData} object for this resource.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link CustomData}).\n */\nDirectoryChildResource.prototype.getCustomData = function getCustomData(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.customData.href, args.options, require('./CustomData'), args.callback);\n};\n\nmodule.exports = DirectoryChildResource;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/stormpath-access-token-authenticator.js":"var nJwt = require('njwt');\nvar Client = require('../Client');\nvar StormpathAccessTokenAuthenticationResult = require('./stormpath-access-token-authentication-result');\n\nfunction tenantAdminKeyResolver(client, kid, callback) {\n  client.getApiKeyById(kid, function(err, apiKey) {\n    if (err) {\n      return callback(err);\n    }\n\n    apiKey.getAccount(function(err, account) {\n      if (err) {\n        return callback(err);\n      }\n\n      account.getDirectory(function(err, directory) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (directory.name === 'Stormpath Administrators') {\n          return callback(null, apiKey.secret);\n        }\n\n        callback(new Error('Invalid kid'));\n      });\n    });\n  });\n}\n\n/**\n * @class\n *\n * @constructor\n *\n * @description\n *\n * Creates an authenticator that can be used to validate access tokens that have\n * been issued by a Stormpath Tenant, using API Keys created for accounts in that\n * tenant's  \"Stormpath Administrators\" directory.  Access tokens can be issued\n * with one of the following methods:\n *\n * - {@link OAuthClientCredentialsAuthenticator#authenticate OAuthClientCredentialsAuthenticator.authenticate()}\n * - {@link OAuthPasswordGrantRequestAuthenticator#authenticate OAuthPasswordGrantRequestAuthenticator.authenticate()}\n * - {@link OAuthStormpathTokenAuthenticator#authenticate OAuthStormpathTokenAuthenticator.authenticate()}\n *\n * @param {Client} client A constructed {@link Client} instance, which will be bound to\n * the Stormpath Tenant in which access token tokens will be validated.\n *\n * @example\n * var client = new stormpath.Client();\n *\n * var authenticator = new stormpath.StormpathAccessTokenAuthenticator(client);\n *\n */\nfunction StormpathAccessTokenAuthenticator(client) {\n  if (!(this instanceof StormpathAccessTokenAuthenticator)) {\n    return new StormpathAccessTokenAuthenticator(client);\n  }\n\n  if (!(client instanceof Client)) {\n    throw new Error('StormpathAccessTokenAuthenticator must be given a Stormpath client instance');\n  }\n\n  this.client = client;\n  this.verifier = nJwt.createVerifier().withKeyResolver(tenantAdminKeyResolver.bind(null, client));\n}\n\nStormpathAccessTokenAuthenticator.prototype.localValidation = false;\n\n/**\n * Calling this method will convert this authenticator to \"local validation\" mode.\n * In this mode, the authenticator will cache the related access token resource,\n * and subsequent authentication attempts will skip the REST API request for the\n * access token resource, until that resource expires from the local cache, as\n * configured by your caching rules (see {@link Client}). This can speed up your\n * authentication layer, as the authentication is now done locally without a\n * network request.\n *\n * **Warning.  This mode has a security tradeoff.** Because of the caching nature\n * of this mode, access tokens will be considred valid until the expire, and your\n * local application will not know if another process as deleted this resource from\n * the Stormpath REST API.  When using local validation, we suggest shorter\n * expiration times, as configured by the issuing application's {@link OAuthPolicy}.\n *\n * @example\n *\n * var authenticator = new stormpath.StormpathAccessTokenAuthenticator(client);\n *\n * authenticator.withLocalValidation();\n */\nStormpathAccessTokenAuthenticator.prototype.withLocalValidation = function withLocalValidation() {\n  this.localValidation = true;\n  return this;\n};\n\n/**\n * Indicate a specific Stormpath Application as an additional authorization check.\n * If an application is specified, the authentication attempt will fail if the\n * access token was not issued by the specified application.\n *\n * @param {Application|Object} application An {@link Application} instance, or object\n * literal with an href property that indicates the desired application.\n *\n * @example\n *\n * var client = new stormpath.Client();\n *\n * var authenticator = new stormpath.StormpathAccessTokenAuthenticator(client);\n *\n * var applicationHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * authenticator.forApplication({\n *   href: applicationHref\n * });\n */\nStormpathAccessTokenAuthenticator.prototype.forApplication = function forApplication(application) {\n  this.forApplicationHref = application.href;\n  return this;\n};\n\n/**\n * Authenticates an access token, in the form of compact JWT string.\n *\n * @param {String} jwtAccessTokenString The compact JWT string\n * @param {Function} callback Will be called with (err, {@link StormpathAccessTokenAuthenticationResult}).\n *\n * @example\n * var jwtAccessTokenString = 'eyJraWQiOiI2NldURFJVM1paSkNZVFJVVlZTUUw3WEJOIiwic3R0IjoiYWNjZXNzIiwiYWxnIjoiSFMyNTYifQ.eyJqdGkiOiIzV0llS3N1SmR6YWR5YzN4U1ltc1l6IiwiaWF0IjoxNDY5ODMzNzQ3LCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8yNGs3SG5ET3o0dFE5QVJzQnRQVU42Iiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy8yRWRHb3htbGpuODBlRHZjM0JzS05EIiwiZXhwIjoxNDY5ODM0MzQ3LCJydGkiOiIzV0llS3BhRWpQSGZMbXk2R0l2Ynd2In0.9J7HvhgJZxvxuE-0PiarTDTFPCVVLR_nvRByULNA01Q';\n *\n * authenticator.authenticate(jwtAccessTokenString, function(err, authenticationResult) {\n *   if (err) {\n *     console.log(err);\n *   } else {\n *     authenticationResult.getAccount(function(err, account){\n *       console.log('Authenticated Account', account);\n *     });\n *   }\n * });\n */\nStormpathAccessTokenAuthenticator.prototype.authenticate = function authenticate(jwtAccessTokenString, callback) {\n  var self = this;\n\n  self.verifier.verify(jwtAccessTokenString, function(err, jwt) {\n    if (err) {\n      return callback(err);\n    }\n\n    var resourceHref;\n\n    // Validate against the provided application, if configured.\n    // Otherwise, validate directly against the access token resource\n    if (self.forApplicationHref) {\n      resourceHref = self.forApplicationHref + '/authTokens/' + jwtAccessTokenString;\n    } else {\n      resourceHref = self.client.config.client.baseUrl + '/accessTokens/' + jwt.body.jti;\n    }\n\n    // Bypass the cache if local validation is disabled.\n    var query = self.localValidation ? null : {\n      nocache: true\n    };\n\n    self.client.getResource(resourceHref, query, function(err, authTokenResponse) {\n      if (err) {\n        return callback(err);\n      }\n\n      // If the incoming token has scope, preserve that for the developer.\n      if (jwt.body.scope) {\n        authTokenResponse.expandedJwt.claims.scope = jwt.claims.scope;\n      }\n\n      return callback(null, new StormpathAccessTokenAuthenticationResult(self.client, authTokenResponse));\n    });\n  });\n};\n\nmodule.exports = StormpathAccessTokenAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/stormpath-access-token-authentication-result.js":"'use strict';\n\nvar utils = require('../utils');\n\n/**\n * @constructor\n *\n * @description\n *\n * Encapsulates the access token resource response, obtained from the `/accessTokens` collection.\n *\n * @param {Client} client\n * An initialized Stormpath Client for the tenant the issued the token.\n *\n * @param {AccessTokenResponse} accessTokenResponse\n * The access token response from the Stormpath REST API.\n */\nfunction StormpathAccessTokenAuthenticationResult(client, data) {\n  if (!(this instanceof StormpathAccessTokenAuthenticationResult)) {\n    return new StormpathAccessTokenAuthenticationResult(client, data);\n  }\n\n  Object.defineProperty(this, 'client', {\n    enumerable: false,\n    value: client\n  });\n\n  for (var key in data) {\n    if (data.hasOwnProperty(key)) {\n      this[key] = data[key];\n    }\n  }\n}\n\n/**\n * @name StormpathAccessTokenAuthenticationResult#account\n *\n * @description\n *\n * An object literal with an href pointer to the account that has authenticated.\n * Use {@link StormpathAccessTokenAuthenticationResult#getAccount StormpathAccessTokenAuthenticationResult.getAccount()}\n * to fetch the full {@link Account} resource.\n *\n * @type {Object}\n */\nStormpathAccessTokenAuthenticationResult.prototype.account = null;\n\n/**\n * An object literal with an href pointer to the application that issued this\n * token. Use {@link StormpathAccessTokenAuthenticationResult#getApplication StormpathAccessTokenAuthenticationResult.getApplication()}\n * to fetch the full {@link Application} resource.\n *\n * @type {Object}\n */\nStormpathAccessTokenAuthenticationResult.prototype.application = null;\n\n/**\n * @name StormpathAccessTokenAuthenticationResult#jwt\n *\n * @description\n *\n * The JWT access token string that was provided for authentication.\n *\n * @type {String}\n */\nStormpathAccessTokenAuthenticationResult.prototype.jwt = null;\n\n/**\n * @name StormpathAccessTokenAuthenticationResult#expandedJwt\n *\n * @description\n *\n * An object that allows you to inspect the body, claims, and header of the\n * access token.\n *\n * @type {Object}\n */\nStormpathAccessTokenAuthenticationResult.prototype.expandedJwt = null;\n\n/**\n * @function\n *\n * @description Get the account resource of the account that has authenticated.\n *\n * @param {ExpansionOptions} options\n * Options for expanding the fetched {@link Account} resource.\n *\n * @param  {Function} callback\n * The callback to call with the parameters (err, {@link Account}).\n */\nStormpathAccessTokenAuthenticationResult.prototype.getAccount = function getAccount( /* [options,] callback */ ) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  this.client.getAccount(this.account.href, args.options, require('../resource/Account'), args.callback);\n};\n\nStormpathAccessTokenAuthenticationResult.prototype.getApplication = function getApplication( /* [options,] callback */ ) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  this.client.getApplication(this.application.href, args.options, require('../resource/Application'), args.callback);\n};\n\nmodule.exports = StormpathAccessTokenAuthenticationResult;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/StormpathAssertionAuthenticator.js":"'use strict';\n\nvar njwt = require('njwt');\nvar AssertionAuthenticationResult = require('./AssertionAuthenticationResult');\n\n/**\n * @class\n *\n * @description\n *\n * Creates an authenticator that can be used to verify a Stormpath Token that was\n * provided when the user returned from ID Site, or a SAML callback.  This method\n * only verifies the token and provides you with any errors.  After using this\n * authenticator you will likely want to use the {@link OAuthStormpathTokenAuthenticator}\n * to generate an Access + Refresh token pair for the user.\n *\n * Note: this authenticator is bound to the API Key Pair of the client that\n * fetched the application resource that you pass to the constructor.\n *\n * @param {Application} application The Stormpath Application to authenticate against.\n *\n * @example\n * var appHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * client.getApplication(appHref, function(err, application) {\n *   var authenticator = new stormpath.StormpathAssertionAuthenticator(application);\n * });\n */\nfunction StormpathAssertionAuthenticator(application) {\n  Object.defineProperty(this, 'dataStore', {\n    enumerable:false,\n    value: application.dataStore\n  });\n\n  this.secret = this.dataStore.requestExecutor.options.client.apiKey.secret;\n}\n\n/**\n * Exchange the Stormpath Token for an Access and Refresh token.\n *\n * @param {Object} tokenRequest\n * An object to encapsulate the request.\n *\n * @param {String} tokenRequest.stormpath_token\n * The Stormpath Token, from the ID Site or SAML callback.  This is a compacted JWT string.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link AssertionAuthenticationResult}).\n *\n * @example\n *\n * var stormpathToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIzRHZNZ2JOVFEwZkhuS3BHd1VHUlB4IiwiaWF0IjoxNDcwMjU4MDc0LCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8yNGs3SG5ET3o0dFE5QVJzbVZ6YUNJIiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy8xdWxlM3dKbkxZVUw3VVE2OGFBdlJaOWwiLCJleHAiOjE0NzAyNjk0MTJ9.i4OWcqczU-us71zT2XIiL69s2srJ7YPH5mAzrw8rNE8';\n *\n * authenticator.authenticate(stormpathToken, function(err, assertionAuthenticationResult) {\n *   assertionAuthenticationResult.getAccount(function(err, account){\n *     if (err) {\n *       // an error occured on ID Site or during the SAML authentication flow\n *       console.error(err);\n *       return;\n *     }\n *     console.log(account.email + ' has authenticated');\n *   });\n * });\n */\nStormpathAssertionAuthenticator.prototype.authenticate = function authenticate(stormpathToken, callback) {\n  var dataStore = this.dataStore;\n  njwt.verify(stormpathToken, this.secret, function (err, jwt) {\n    if (err) {\n      err.statusCode = 401;\n      return callback(err);\n    }\n\n    if (jwt.body.err){\n      return callback(jwt.body.err);\n    }\n\n    var account = null;\n\n    // For Stormpath mapped JWT fields, see:\n    // https://docs.stormpath.com/rest/product-guide/latest/005_auth_n.html#step-5-stormpath-response-with-jwt\n    if (jwt.body.sub) {\n      account = {\n        href: jwt.body.sub\n      };\n    }\n\n    callback(null, new AssertionAuthenticationResult(\n      dataStore, {\n        stormpath_token: stormpathToken,\n        expandedJwt: jwt,\n        account: account\n      }\n    ));\n  });\n\n  return this;\n};\n\nmodule.exports = StormpathAssertionAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/jwt/jwt-authenticator.js":"'use strict';\n\nvar njwt = require('njwt');\nvar util = require('util');\n\nvar OauthAccessTokenAuthenticator = require('../authc/OauthAccessTokenAuthenticator');\nvar ApiAuthRequestError = require('../error/ApiAuthRequestError');\nvar JwtAuthenticationResult = require('./jwt-authentication-result');\n\n/**\n * @class\n *\n * @constructor\n *\n * @deprecated Please use {@link StormpathAccessTokenAuthenticator} instead.\n *\n * @description\n *\n * Creates an authenticator that can be used to validate JWTs that have been\n * issued to users.  JWTs can be issued with one of the following methods:\n *\n * - {@link OAuthPasswordGrantRequestAuthenticator#authenticate OAuthPasswordGrantRequestAuthenticator.authenticate()}\n * - {@link OAuthStormpathTokenAuthenticator#authenticate OAuthStormpathTokenAuthenticator.authenticate()}\n *\n * @param {Application} application The Stormpath Application to authenticate against.\n *\n * @example\n * var appHref = 'https://api.stormpath.com/v1/applications/3WIeKpaEjPHfLmy6GIvbwv';\n *\n * client.getApplication(appHref, function (err, application) {\n *   var authenticator = new stormpath.JwtAuthenticator(application);\n * });\n */\nfunction JwtAuthenticator(application) {\n  if (!(this instanceof JwtAuthenticator)) {\n    return new JwtAuthenticator(application);\n  }\n\n  this.application = application;\n}\n\nJwtAuthenticator.prototype.defaultCookieName = 'access_token';\n\nJwtAuthenticator.prototype.localValidation = false;\n\n/**\n * Calling this method will convert this authenticator to \"local validation\" mode.\n * In this mode, the authenticator will skip the REST API call which determines\n * if the {@link AccessToken} resource has been revoked. Tokens will be considered\n * valid if they are signed by the original signing key (one of your Tenant API Keys)\n * and are not expired.  **Please be aware of this security tradeoff.** When using\n * local validation, we suggest shorter expiration times, as configured by the\n * application's {@link OAuthPolicy}.\n *\n * @example\n *\n * var authenticator = new stormpath.JwtAuthenticator(application);\n *\n * authenticator.withLocalValidation();\n */\nJwtAuthenticator.prototype.withLocalValidation = function withLocalValidation() {\n  this.localValidation = true;\n  return this;\n};\n\nJwtAuthenticator.prototype.withCookie = function withCookie(cookieName) {\n  this.configuredCookieName = cookieName;\n  return this;\n};\n\nJwtAuthenticator.prototype.unauthenticated = function unauthenticated() {\n  return new ApiAuthRequestError({\n    userMessage: 'Unauthorized',\n    statusCode: 401\n  });\n};\n\n/**\n * Authenticates a JWT, in the form of an access token string.\n *\n * @param {String} accessToken The compact JWT string\n * @param {Function} callback Will be called with (err, {@link JwtAuthenticationResult JwtAuthenticationResult}).\n *\n * @example\n * var accessToken = 'eyJraWQiOiI2NldURFJVM1paSkNZVFJVVlZTUUw3WEJOIiwic3R0IjoiYWNjZXNzIiwiYWxnIjoiSFMyNTYifQ.eyJqdGkiOiIzV0llS3N1SmR6YWR5YzN4U1ltc1l6IiwiaWF0IjoxNDY5ODMzNzQ3LCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8yNGs3SG5ET3o0dFE5QVJzQnRQVU42Iiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy8yRWRHb3htbGpuODBlRHZjM0JzS05EIiwiZXhwIjoxNDY5ODM0MzQ3LCJydGkiOiIzV0llS3BhRWpQSGZMbXk2R0l2Ynd2In0.9J7HvhgJZxvxuE-0PiarTDTFPCVVLR_nvRByULNA01Q';\n *\n * authenticator.authenticate(accessToken, function(err, authenticationResult) {\n *   if (err) {\n *     console.log(err);\n *   } else {\n *     authenticationResult.getAccount(function(err, account){\n *       console.log(account);\n *     });\n *   }\n * });\n *\n */\nJwtAuthenticator.prototype.authenticate = util.deprecate(function authenticate(token, cb) {\n  var self = this;\n  var secret = self.application.dataStore.requestExecutor.options.client.apiKey.secret;\n\n  try {\n    njwt.verify(token, secret, function(err, jwt) {\n      if (err) {\n        err.statusCode = 401;\n        return cb(err);\n      }\n\n      // If there is no KID, this means it was issued by the SDK (not the\n      // API) from a client credentials grant so we have to do remote\n      // validation in a different way.\n      if (!jwt.header.kid) {\n        var authenticator = new OauthAccessTokenAuthenticator(self.application, token);\n        return authenticator.authenticate(cb);\n      }\n\n      // If the KID exists, this was issued by our API from a password grant\n      if (self.localValidation) {\n        // Transfers all body fields to `claims` to maintain consistency\n        // with remote results. Does not remove the body as to preserve\n        // backwards compatibility.\n        jwt.claims = {};\n\n        Object.keys(jwt.body).forEach(function(key) {\n          if (jwt.body.hasOwnProperty(key)) {\n            jwt.claims[key] = jwt.body[key];\n          }\n        });\n\n        return cb(null, new JwtAuthenticationResult(self.application, {\n          jwt: token,\n          expandedJwt: jwt,\n          localValidation: true,\n          account: {\n            href: jwt.body.sub\n          }\n        }));\n      }\n\n      var href = self.application.href + '/authTokens/' + token;\n\n      self.application.dataStore.getResource(href, function(err, response) {\n        if (err) {\n          return cb(err);\n        }\n\n        // Preserve scope\n        if (jwt.body.scope) {\n          return njwt.verify(response.jwt, secret, function(err, newJwt) {\n            if (err) {\n              cb(err);\n            }\n\n            // Copy the scope on the authorized token\n            newJwt.body.scope = jwt.body.scope;\n            newJwt.setSigningKey(secret);\n            response.jwt = newJwt.compact();\n            response.expandedJwt.claims.scope = jwt.body.scope;\n\n            cb(null, new JwtAuthenticationResult(self.application, response));\n          });\n        }\n\n        cb(null, new JwtAuthenticationResult(self.application, response));\n      });\n    });\n  } catch (err) {\n    cb(err);\n  }\n\n  return this;\n}, 'JwtAuthenticator is deprecated, please use StormpathAccessTokenAuthenticator instead.');\n\nmodule.exports = JwtAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/OauthAccessTokenAuthenticator.js":"'use strict';\n\nvar jwt = require('jwt-simple');\n\nvar ApiAuthRequestError = require('../error/ApiAuthRequestError');\nvar AuthenticationResult = require('../resource/AuthenticationResult');\nvar utils = require('../utils');\n\nvar nowEpochSeconds = utils.nowEpochSeconds;\n\nfunction getJwt(token, secret){\n  var jwtObject;\n  try{\n    jwtObject = jwt.decode(token, secret);\n  }\n  catch(e){\n    return new ApiAuthRequestError({userMessage: 'access_token is invalid',statusCode: 401});\n  }\n  return jwtObject;\n}\n\nfunction validateJwt(jwtObject){\n  var requiredFields = [['iat',Number],['exp',Number],['sub',String]];\n  for(var i=0,m=requiredFields.length;i<m;i++){\n    if(!jwtObject[requiredFields[i][0]]||jwtObject[requiredFields[i][0]].constructor!==requiredFields[i][1]){\n      return new ApiAuthRequestError({userMessage: 'Missing or invalid jwt parameter: ' + requiredFields[i][0]});\n    }\n  }\n  if(nowEpochSeconds()>jwtObject.exp){\n    return new ApiAuthRequestError({userMessage: 'Token has expired', statusCode: 401});\n  }\n  if(jwtObject.scope && typeof jwtObject.scope !== 'string'){\n    return new ApiAuthRequestError({userMessage: 'scope must be a string'});\n  }\n  return null;\n}\n\n\nfunction OauthAccessTokenAuthenticator(application, token, ttl){\n  var jwtObject = getJwt(token, application.dataStore.requestExecutor.options.client.apiKey.secret);\n\n  if(jwtObject instanceof Error){\n    return jwtObject;\n  }\n\n  var jwtValidationResult = validateJwt(jwtObject);\n\n  if(jwtValidationResult instanceof Error){\n    return jwtValidationResult;\n  }\n\n  var scopes;\n\n  if(jwtObject.scope){\n    scopes = jwtObject.scope.split(' ');\n  }else{\n    scopes = [];\n  }\n\n  this.scopes = scopes;\n  this.apiKey = jwtObject.sub;\n  this.application = application;\n  this.token = token;\n  this.jwtObject = jwtObject;\n  this.ttl = ttl || 3600;\n}\n\nOauthAccessTokenAuthenticator.prototype.authenticate = function authenticate(callback) {\n  var self = this;\n  var subject = this.jwtObject.sub;\n  if(subject.match(/accounts/)){\n    self.application.dataStore.getResource(subject,null,require('../resource/Account'),function(err,account){\n      if(err){\n        callback(err.status===404 ? new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client', statusCode: 401}) : err);\n      }else if(account.status==='ENABLED'){\n        var data = {\n          token: self.token,\n          jwtObject: self.jwtObject,\n          account: account\n        };\n\n        if(self.scopes){\n          data.grantedScopes = self.scopes;\n        }\n\n        var result = new AuthenticationResult(data,self.application.dataStore);\n\n        result.ttl = self.ttl;\n\n        callback(null, result);\n      }else{\n        callback(new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client', statusCode: 401}));\n      }\n    });\n  }else{\n    self.application.getApiKey(self.apiKey,function(err,apiKey){\n      if(err){\n        callback(err.status===404 ? new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client', statusCode: 401}) : err);\n      }else if(\n        (apiKey.status==='ENABLED') &&\n        (apiKey.account.status==='ENABLED')\n      ){\n        var data = apiKey;\n        data.token = self.token;\n        data.jwtObject = self.jwtObject;\n        if(self.scopes){\n          data.grantedScopes = self.scopes;\n        }\n\n        callback(null,new AuthenticationResult(apiKey,self.application.dataStore));\n      }else{\n        callback(new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client', statusCode: 401 }));\n      }\n    });\n  }\n};\n\nmodule.exports = OauthAccessTokenAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/error/ApiAuthRequestError.js":"'use strict';\n\nvar utils  = require('../utils');\n\nfunction ApiAuthRequestError(errorData){\n  Error.captureStackTrace(this, this.constructor);\n\n  this.name = this.constructor.name;\n  this.userMessage = this.message = errorData.userMessage;\n  this.statusCode = errorData.statusCode || 400;\n  this.error = errorData.error;\n}\nutils.inherits(ApiAuthRequestError, Error);\n\nmodule.exports = ApiAuthRequestError;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/AuthenticationResult.js":"'use strict';\n\nvar nJwt = require('njwt');\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class AuthenticationResult\n *\n * @description\n * Encapsulates an authentication result, and provides a method for getting the\n * account that was authenticated. An Authentication Result is not constructed\n * manually, instead it is returned from one of these methods:\n *\n * - {@link Application#authenticateAccount Application.authenticateAccount()}\n * - {@link Application#authenticateApiRequest Application.authenticateApiRequest()}\n *\n * @param {Object} authenticationResult\n * The raw JSON data of the Application resource, as retrieved from the\n * Stormpath REST API.\n */\nfunction AuthenticationResult() {\n  AuthenticationResult.super_.apply(this, arguments);\n  Object.defineProperty(this, 'application', { enumerable:false, writable:true });\n  Object.defineProperty(this, 'forApiKey', { enumerable:false, writable:true });\n  Object.defineProperty(this, 'ttl', { enumerable:false, writable:true, value: 3600 });\n}\n\nutils.inherits(AuthenticationResult, InstanceResource);\n\n/**\n * Retrieves the account resource of the user that has been authenticated.\n *\n * @param {ExpansionOptions} [options]\n * For retrieving linked resources of the {@link Account} during this request.\n *\n * @param {Function} Callback\n * Callback function, will be called with (err, {@link Account account}).\n */\nAuthenticationResult.prototype.getAccount = function getAuthenticationResultAccount(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.account.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n * Create a signed JWT that can be used to authenticate this account in the\n * future with one of these methods:\n *\n * - {@link JwtAuthenticator#authenticate JwtAuthenticator.authenticate()}\n * - {@link Application#authenticateApiRequest Application.authenticateApiRequest()}\n *\n * The token is tied to the application which generated the authentication\n * result, the `iss` field will the the HREF of the application and the `sub`\n * field will be the ID of the {@link ApiKey} of the {@link Account} that\n * authenticated.\n *\n * **Warning**: Tokens created through this method are not managed by the\n * Stormpath REST API (they are stateless).  If you need Stormpath to track\n * the tokens, please use the {@link OAuthPasswordGrantRequestAuthenticator}\n * to obtain an access token and refresh token for the user.\n *\n * @example\n *\n * var jwt = authenticationResult.getJwt();\n *\n * jwt.setExpiration(new Date('2015-07-01')); // A specific date\n * jwt.setExpiration(new Date().getTime() + (60*60*1000)); // One hour from now\n *\n * // Compact the JWT to a Base64-URL encoded token.\n * var accessToken = jwt.compact();\n *\n * @returns {Jwt}\n */\nAuthenticationResult.prototype.getJwt = function getJwt() {\n  var secret = this.application.dataStore.requestExecutor\n    .options.client.apiKey.secret;\n\n  var jwt = nJwt.create({\n    iss: this.application.href,\n    sub: this.forApiKey ? this.forApiKey.id : this.account.href,\n    jti: utils.uuid()\n  }, secret);\n\n  jwt.setExpiration(new Date().getTime() + (this.ttl * 1000));\n\n  return jwt;\n};\n\n/**\n * This method calls {@link AuthenticationResult#getJwt getJwt()} to create a\n * JWT for account, and returns it as a Base64-URL encoded token.\n *\n * @example <caption>Get a compacted JWT access token for this account</caption>\n * var accessToken = authenticationResult.getAccessTokenResponse();\n *\n * @example <caption>Access token format</caption>\n * eyJraWQiOiI2NldURFJVM1paSkNZVFJVVlZTUUw3WEJOIiwic3R0IjoiYWNjZXNzIiwiYWxnIjoiSFMyNTYifQ.eyJqdGkiOiIzV0llS3N1SmR6YWR5YzN4U1ltc1l6IiwiaWF0IjoxNDY5ODMzNzQ3LCJpc3MiOiJodHRwczovL2FwaS5zdG9ybXBhdGguY29tL3YxL2FwcGxpY2F0aW9ucy8yNGs3SG5ET3o0dFE5QVJzQnRQVU42Iiwic3ViIjoiaHR0cHM6Ly9hcGkuc3Rvcm1wYXRoLmNvbS92MS9hY2NvdW50cy8yRWRHb3htbGpuODBlRHZjM0JzS05EIiwiZXhwIjoxNDY5ODM0MzQ3LCJydGkiOiIzV0llS3BhRWpQSGZMbXk2R0l2Ynd2In0.9J7HvhgJZxvxuE-0PiarTDTFPCVVLR_nvRByULNA01Q\n */\n\nAuthenticationResult.prototype.getAccessToken = function getAccessToken(jwt) {\n  return (jwt || this.getJwt()).compact();\n};\n\n\n/**\n * This method calls {@link AuthenticationResult#getJwt getJwt()} to create a\n * JWT for account, and returns as an an OAuth-compatible response body.\n *\n * @example <caption>Get an access token response body for this account.</caption>\n * var responseBody = authenticationResult.getAccessTokenResponse();\n *\n * @example <caption>Response body format</caption>\n * {\n *  \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGc ...\",\n *  \"expires_in\": 3600,\n *  \"token_type\": \"bearer\",\n *  \"scope\": \"given-scope\"\n * }\n */\nAuthenticationResult.prototype.getAccessTokenResponse = function getAccessTokenResponse(jwt) {\n  jwt = jwt || this.getJwt();\n\n  var resp = {\n    'access_token': jwt.compact(),\n    'token_type': 'Bearer',\n    'expires_in': this.ttl\n  };\n\n  if(jwt.body.scope){\n    resp.scope = jwt.body.scope;\n  }\n\n  return resp;\n};\n\n/**\n * @name  AuthenticationResult.grantedScopes\n *\n * @type {Array}\n *\n * @description\n *\n * Exists if the authentication result was created from a previously issued\n * OAuth Access Token which has granted scopes, it will be an array of strings\n * which are the granted scopes.\n *\n * @example\n *\n * ['scope-a', 'scope-b']\n */\n\n\nmodule.exports = AuthenticationResult;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/oauth/authenticator.js":"'use strict';\n\nvar ApiAuthRequestError = require('../error/ApiAuthRequestError');\nvar JwtAuthenticator = require('../jwt/jwt-authenticator');\nvar OAuthPasswordGrantRequestAuthenticator = require('../oauth/password-grant').authenticator;\nvar OAuthRefreshTokenGrantRequestAuthenticator = require('../oauth/refresh-grant').authenticator;\nvar OAuthIdSiteTokenGrantAuthenticator = require('../oauth/id-site-grant').authenticator;\nvar OAuthStormpathTokenAuthenticator = require('../oauth/stormpath-token').authenticator;\nvar OAuthClientCredentialsAuthenticator = require('./client-credentials').authenticator;\nvar OAuthStormpathSocialAuthenticator = require('../oauth/stormpath-social').authenticator;\n\nfunction retrieveAuthTokenFromRequest(req) {\n  var authHeader = req && req.headers && req.headers.authorization;\n\n  if (!authHeader || !authHeader.match(/Bearer/i)) {\n    return false;\n  }\n\n  return authHeader.split(' ').pop();\n}\n\n/**\n * Intentionally not documented for the time being.  This is essentially middleware\n * for Express, so I'm not sure it belongs in this library.\n *\n * @private\n */\nfunction OAuthAuthenticator(application) {\n  if (!(this instanceof OAuthAuthenticator)) {\n    return new OAuthAuthenticator(application);\n  }\n\n  this.application = application;\n}\n\nOAuthAuthenticator.prototype.localValidation = false;\n\nOAuthAuthenticator.prototype.withLocalValidation = function withLocalValidation() {\n  this.localValidation = true;\n  return this;\n};\n\nOAuthAuthenticator.prototype.authenticate = function authenticate(req, callback){\n  if (typeof req !== 'object' || typeof callback !== 'function') {\n    throw new Error('authenticate must be called with a request object and callback function');\n  }\n\n  var authenticator = null;\n  var token = retrieveAuthTokenFromRequest(req);\n\n  if (token) {\n    authenticator = new JwtAuthenticator(this.application);\n\n    if (this.localValidation) {\n      authenticator.withLocalValidation();\n    }\n  } else if (req.body) {\n    token = req.body;\n    switch (req.body.grant_type) {\n      case 'password':\n        authenticator = new OAuthPasswordGrantRequestAuthenticator(this.application);\n        break;\n      case 'refresh_token':\n        authenticator = new OAuthRefreshTokenGrantRequestAuthenticator(this.application);\n        break;\n      case 'id_site_token':\n        authenticator = new OAuthIdSiteTokenGrantAuthenticator(this.application);\n        break;\n      case 'stormpath_token':\n        authenticator = new OAuthStormpathTokenAuthenticator(this.application);\n        break;\n      case 'client_credentials':\n        authenticator = new OAuthClientCredentialsAuthenticator(this.application);\n        break;\n      case 'stormpath_social':\n        authenticator = new OAuthStormpathSocialAuthenticator(this.application);\n    }\n  }\n\n  if (authenticator) {\n    authenticator.authenticate(token, callback);\n  } else {\n    callback(this.unauthenticated());\n  }\n\n  return this;\n};\n\nOAuthAuthenticator.prototype.unauthenticated = function unauthenticated(){\n  return new ApiAuthRequestError({userMessage: 'Unauthorized', statusCode: 401});\n};\n\nmodule.exports = OAuthAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/Gruntfile.js":"'use strict';\n\nmodule.exports = function (grunt) {\n\n  // Show elapsed time at the end\n  require('time-grunt')(grunt);\n  // Load all grunt tasks\n  require('load-grunt-tasks')(grunt);\n\n  // Project configuration.\n  grunt.initConfig({\n    mochaTest: {\n      test: {\n        src: ['test/**/*_test.js'],\n        options: {\n          timeout: 30000\n        }\n\n      },\n      live: {\n        src: ['test/**/*_live.js']\n      }\n    },\n    mocha_istanbul: {\n      test: {\n        src: ['test/it/*_it.js', 'test/**/*_test.js'],\n        options: {\n          coverage: true,\n          require: ['test/common.js'],\n          timeout: 30000\n        }\n      },\n      coverage: {\n        src: 'test', // the folder, not the files,\n        options: {\n          mask: '**/*_test.js',\n          require: ['test/common.js'],\n          timeout: 30000\n        }\n      },\n      it: {\n        src: 'test', // the folder, not the files,\n        options: {\n          mask: '**/*_it.js',\n          require: ['test/common.js'],\n          timeout: 30000\n        }\n      }\n    },\n    jshint: {\n      options: {\n        jshintrc: '.jshintrc',\n        reporter: require('jshint-stylish')\n      },\n      gruntfile: {\n        src: 'Gruntfile.js'\n      },\n      lib: {\n        src: ['lib/**/*.js']\n      },\n      test: {\n        src: ['test/**/*.js']\n      }\n    },\n    watch: {\n      gruntfile: {\n        files: '<%= jshint.gruntfile.src %>',\n        tasks: ['jshint:gruntfile']\n      },\n      lib: {\n        files: '<%= jshint.lib.src %>',\n        tasks: ['jshint:lib', 'mochaTest']\n      },\n      test: {\n        files: '<%= jshint.test.src %>',\n        tasks: ['jshint:test', 'mochaTest']\n      }\n    }\n  });\n\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n  grunt.loadNpmTasks('grunt-contrib-watch');\n  grunt.loadNpmTasks('grunt-mocha-istanbul');\n  grunt.loadNpmTasks('grunt-mocha-test');\n\n  // Default task.\n  grunt.registerTask('test', ['mochaTest:test']);\n  grunt.registerTask('it', ['jshint','mocha_istanbul:it']);\n  grunt.registerTask('live', ['mochaTest:live']);\n  grunt.registerTask('coverage', ['mocha_istanbul:coverage']);\n  grunt.registerTask('default', ['jshint', 'mocha_istanbul:test']);\n\n  // Once our coverage reports have been generated, fire off coverage reports to\n  // coveralls.io so our coverage is made public.\n  grunt.event.on('coverage', function(lcov, done) {\n    require('coveralls').handleInput(lcov, function(err) {\n      done(err);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/quickstart.js":"'use strict';\n\n// ==================================================\n// This file is intended to reflect the Stormpath\n// Node.js Quickstart documented here:\n//\n//     http://docs.stormpath.com/nodejs/api/\n//\n// Enjoy!\n// ==================================================\n\nvar stormpath = require('stormpath');\n\n//helper function to prevent any data collisions in the tenant while running the quickstart:\nfunction unique(aString) {\n  return aString + '-' + require('uuid').v4().toString();\n}\n\n//populated during the quickstart steps\nvar client, application, account, group = null;\n\nvar accountEmail = unique('jlpicard') + '@mailinator.com';\n\n// ==================================================\n// Step 1 - Create a client and wait for it to ready\n// ==================================================\nvar client = new stormpath.Client();\n\nclient.on('ready', createApplication);\n\n// ==================================================\n// Step 2 - Register an application with Stormpath\n// ==================================================\nfunction createApplication() {\n\n  var app = {\n    name: unique('My Awesome Application'),\n    description: ('No, Srsly. It\\'s Awesome')\n  };\n\n  return client.createApplication(app, {createDirectory: true}, function(err, app) {\n    if (err) throw err;\n    application = app;\n    console.log('Created application:');\n    console.log(application);\n    return createAccount(); //next quickstart step\n  });\n}\n\n// ==================================================\n// Step 3 - Create a new application account\n// ==================================================\nfunction createAccount() {\n\n  var acct = {\n    givenName: 'Jean-Luc',\n    surname: 'Picard',\n    username: unique('jlpicard'),\n    email: accountEmail,\n    password: 'Changeme1!'\n  };\n\n  return application.createAccount(acct, function(err, createdAccount) {\n    if (err) throw err;\n    account = createdAccount;\n    console.log('Created account:');\n    console.log(account);\n    return updateAccount(); //next quickstart step\n  });\n}\n\n// ==================================================\n// Step 3 - Update an account\n// ==================================================\nfunction updateAccount() {\n\n  account.middleName = 'Make it so.';\n\n  return account.save(function(err, savedAccount) {\n    if (err) throw err;\n    account = savedAccount;\n    console.log('Updated account:');\n    console.log(account);\n    return authenticateAccount(); //next quickstart step\n  });\n\n}\n\n// ==================================================\n// Step 4 - Authenticate an account\n// ==================================================\nfunction authenticateAccount() {\n\n  var authcRequest = {\n    username: accountEmail, //we could've entered the username instead\n    password: 'Changeme1!'\n  };\n\n  return application.authenticateAccount(authcRequest, function(err, result) {\n    if (err) throw err;\n\n    return result.getAccount(function(err2, theAccount) { //this is cached and will execute immediately (no server request):\n      if(err2) throw err2;\n\n      account = theAccount;\n\n      console.log('Authenticated account:');\n      console.log(account);\n\n      //authentication was successful, so we ordinarily have no need to send a\n      //password reset email right now, but hey - this is a quickstart and we're\n      //trying to show stuff!  So kick off the password reset workflow just for fun:\n      return sendPasswordResetEmail(); //next quickstart step\n    });\n  });\n}\n\n// ==================================================\n// Step 5 - Send the account a password reset email\n// ==================================================\nfunction sendPasswordResetEmail() {\n\n  return application.sendPasswordResetEmail(accountEmail, function(err, token) {\n    if (err) throw err;\n\n    console.log(\"Sent email that included a link with password reset token: \" + token.toString());\n    console.log(\"If you like, go to mailinator.com and use this email address to view the email: \" + accountEmail);\n\n    //ok, moving on with the quickstart:\n    return createGroup();\n  });\n}\n\n// ==================================================\n// Step 6 - Create a group\n// ==================================================\nfunction createGroup() {\n\n  var aGroup = {\n    name: unique('Administrators')\n  };\n\n  return application.createGroup(aGroup, function(err, createdGroup) {\n    if (err) throw err;\n    group = createdGroup;\n\n    return addAccountToGroup(); //next quickstart step\n  });\n}\n\n// ==================================================\n// Step 7 - Add an Account to a Group\n// ==================================================\nfunction addAccountToGroup() {\n\n  return account.addToGroup(group, function(err, membership) {\n    if (err) throw err;\n    console.log(membership);\n\n    return retrieveAccountGroups(); //next quickstart step\n  });\n\n}\n\n// ==================================================\n// Step 8 - Retrieve an Account's Groups\n// ==================================================\nfunction retrieveAccountGroups() {\n  account.getGroups(function(err, groups) {\n    groups.each(function(err, group) {\n      console.log(group);\n    })\n  });\n\n  //finish quickstart:\n  cleanup();\n}\n\n// ==================================================\n// End of quickstart - cleanup quickstart data\n// ==================================================\n//deletes the objects we created during the quickstart so we don't pollute the tenant\nfunction cleanup() {\n\n  var ds = application.dataStore;\n\n  //delete the application's directory.  This will auto-delete any contained accounts and groups:\n  ds.getResource(application.defaultAccountStoreMapping.href, function(err, mapping) {\n    if (err) throw err;\n\n    console.log('Retrieved application accountStoreMapping for deletion:');\n    console.log(mapping);\n\n    ds.deleteResource(mapping.accountStore, function(err) {\n      if(err) throw err;\n\n      console.log('Deleted application directory.');\n\n      application.delete(function(err) {\n        if (err) throw err;\n        console.log('Deleted application.');\n      });\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/benchmark/api-key-encryption.js":"var stormpath = require('../');\nvar uuid = require('uuid');\nvar base64 = require('../lib/utils').base64;\nvar Benchmark = require('benchmark');\nvar async = require('async');\n\nfunction invoke(app,apiKey,cb){\n  app.authenticateApiRequest({\n    request:{\n      method: 'GET',\n      url: '/',\n      headers:{\n        'authorization': 'Basic '+ base64.encode(apiKey.id+':'+apiKey.secret)\n      }\n    }\n  },cb);\n}\n\nfunction addTestRunner(apiKey,test,suite,done){\n  var client = new stormpath.Client({\n    apiKey: new stormpath.ApiKey(\n      process.env['STORMPATH_API_KEY_ID'],\n      process.env['STORMPATH_API_KEY_SECRET']\n    ),\n    apiKeyEncryptionOptions: test.apiKeyEncryptionOptions\n  });\n\n  client.getApplication(process.env['STORMPATH_APP_HREF'],function(err,app) {\n\n    if(err){ throw err; }\n\n    // Make an initial invocation to warm the cache\n\n    invoke(app,apiKey,function(err){\n      if(err){ throw err; }\n      suite.add(test.title, {\n        defer: true,\n        fn: function(deferred){\n          invoke(app,apiKey,function(err){\n            if(err){\n              throw err;\n            }else{\n              deferred.resolve();\n            }\n          });\n        }\n      });\n      done();\n    });\n  });\n}\n\n\n\nvar tests = [\n  {\n    title: 'With encryption DISABLED (encryptSecret: false)  ',\n    apiKeyEncryptionOptions: {\n      encryptSecret: false\n    }\n  },\n  {\n    title: 'With encryption ENABLED (default options)        '\n  },\n  {\n    title: 'With light encryption (128 key size, iterations) ',\n    apiKeyEncryptionOptions: {\n      encryptionKeySize: 128,\n      encryptionKeyIterations: 128\n    }\n  },\n  {\n    title: 'With medium encryption (128 key size, iterations)',\n    apiKeyEncryptionOptions: {\n      encryptionKeySize: 256,\n      encryptionKeyIterations: 512\n    }\n  }\n];\n\n\nconsole.log('Construct Client');\n\n// First client is used to create our dummy account\n\nvar client1 = new stormpath.Client({\n  apiKey: new stormpath.ApiKey(\n    process.env['STORMPATH_API_KEY_ID'],\n    process.env['STORMPATH_API_KEY_SECRET']\n  )\n});\n\n\nvar account;\n\n\nvar suite = new Benchmark.Suite('api auth')\n  .on('start', function() {\n    console.log('Begin benchmarks');\n  })\n  .on('cycle', function(event) {\n    console.log(String(event.target));\n  })\n  .on('complete', function() {\n    console.log('\\nFastest is: ' + this.filter('fastest').pluck('name')+'\\n');\n    account.delete(function(err){\n      if(err){ throw err; }\n      console.log('Deleted account');\n    });\n  });\n\n\nclient1.getApplication(process.env['STORMPATH_APP_HREF'],function(err,app1) {\n\n  if(err){ throw err; }\n\n  console.log('Create test account');\n\n  app1.createAccount({\n    email: uuid()+'@stormpath.com',\n    password: uuid() + 'ABC1',\n    givenName: uuid(),\n    surname: uuid()\n  },function(err,result){\n\n    if(err){ throw err; }\n\n    account = result;\n\n    account.createApiKey(function(err,apiKey){\n\n      if(err){ throw err; }\n\n        async.parallel(tests.map(function(test){\n          return addTestRunner.bind(null,apiKey,test,suite);\n        }),function(err){\n          if(err){ throw err; }\n          suite.run({async:true});\n        });\n\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/index.js":"'use strict';\n\nmodule.exports = require('./stormpath');\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/AuthRequestParser.js":"'use strict';\n\nvar url = require('url');\n\nvar ApiAuthRequestError = require('../error/ApiAuthRequestError');\n\nfunction AuthRequestParser(request,locationsToSearch){\n\n  if(typeof request !=='object'){\n    throw new ApiAuthRequestError({userMessage: 'request must be an object'});\n  }\n  if(typeof request.url !== 'string'){\n    throw new ApiAuthRequestError({userMessage: 'request must have a url string'});\n  }\n  if(typeof request.headers !== 'object'){\n    throw new ApiAuthRequestError({userMessage: 'request must have a headers object'});\n  }\n  if(typeof request.method !== 'string'){\n    throw new ApiAuthRequestError({userMessage: 'request must have a method property'});\n  }\n  if(typeof locationsToSearch !== 'object') {\n    throw new ApiAuthRequestError({userMessage: 'locationsToSearch must be an array'});\n  }\n\n  var req = request;\n  var searchBody = locationsToSearch.indexOf('body') > -1;\n  var searchHeader = locationsToSearch.indexOf('header') > -1;\n  var searchUrl = locationsToSearch.indexOf('url') > -1;\n\n  var urlParams = url.parse(req.url,true).query;\n\n  this.body = (searchBody && (typeof req.body === 'object') && (req.body !== null)) ? req.body : {};\n  this.headers = searchHeader ? req.headers : {};\n\n  this.grantType = this.body.grant_type || urlParams.grant_type || '';\n  this.authorizationValue = searchHeader ?\n    (this.headers['authorization'] || this.headers['Authorization'] || '') : '';\n  this.accessToken = searchUrl ?\n    (urlParams.access_token || this.body.access_token || this.authorizationValue) :\n      (this.body.access_token || this.authorizationValue);\n\n  this.requestedScope = (this.body.scope || urlParams.scope || '').split(' ');\n}\n\nmodule.exports = AuthRequestParser;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/BasicApiAuthenticator.js":"'use strict';\n\nvar ApiAuthRequestError = require('../error/ApiAuthRequestError');\nvar AuthenticationResult = require('../resource/AuthenticationResult');\n\nfunction BasicApiAuthenticator(application,authHeaderValue, ttl){\n  var parts = new Buffer(authHeaderValue.replace(/Basic /i,''),'base64').toString('utf8').split(':');\n\n  if(parts.length !== 2){\n    return new ApiAuthRequestError({userMessage: 'Invalid Authorization value', statusCode: 400});\n  }\n\n  this.application = application;\n  this.id = parts[0];\n  this.secret = parts[1];\n\n  this.ttl = ttl || 3600;\n}\n\nBasicApiAuthenticator.prototype.authenticate = function authenticate(callback) {\n  var self = this;\n\n  self.application.getApiKey(self.id,function(err,apiKey){\n    if(err){\n      callback(err.status===404 ? new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client',  statusCode: 401}) : err);\n    }else{\n      if(\n        (apiKey.secret===self.secret) &&\n        (apiKey.status==='ENABLED') &&\n        (apiKey.account.status==='ENABLED')\n      ){\n        var authenticationResult = new AuthenticationResult(apiKey,self.application.dataStore);\n\n        authenticationResult.application = self.application;\n        authenticationResult.ttl = self.ttl;\n\n        callback(null,authenticationResult);\n      }else{\n        callback(new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client',  statusCode: 401}));\n      }\n    }\n  });\n};\n\nmodule.exports = BasicApiAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/ClientCredentialGrantAuthenticator.js":"'use strict';\n\nfunction OAuthClientCredentialGrantRequestAuthenticator(application) {\n  if (!(this instanceof OAuthClientCredentialGrantRequestAuthenticator)) {\n    return new OAuthClientCredentialGrantRequestAuthenticator(application);\n  }\n  this.application = application;\n}\nOAuthClientCredentialGrantRequestAuthenticator.prototype.authenticate = function authenticate() {\n  // TODO\n};\n\nmodule.exports = OAuthClientCredentialGrantRequestAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/authc/OAuthBasicExchangeAuthenticator.js":"'use strict';\n\nvar jwt = require('jwt-simple');\n\nvar ApiAuthRequestError = require('../error/ApiAuthRequestError');\nvar AuthenticationResult = require('../resource/AuthenticationResult');\nvar utils = require('../utils');\n\nvar nowEpochSeconds = utils.nowEpochSeconds;\n\nfunction OAuthBasicExchangeAuthenticator(application,request,ttl,scopeFactory, requestedScope){\n  var authValue = request.headers.authorization.replace(/Basic /i,'');\n  var parts = new Buffer(authValue,'base64').toString('utf8').split(':');\n\n  if(parts.length!==2){\n    return new ApiAuthRequestError({userMessage: 'Invalid Authorization value', statusCode: 400});\n  }\n\n  if(request.method!=='POST'){\n    return new ApiAuthRequestError({userMessage: 'Must use POST for token exchange, see http://tools.ietf.org/html/rfc6749#section-3.2'});\n  }\n\n  this.id = parts[0];\n  this.secret = parts[1];\n  this.application = application;\n  this.ttl = ttl || 3600;\n  this.scopeFactory = scopeFactory || this.defaultScopeFactory;\n  this.requestedScope = requestedScope;\n}\n\nOAuthBasicExchangeAuthenticator.prototype.defaultScopeFactory = function defaultScopeFactory(account, requestedScope, callback) {\n  callback(null, '');\n};\n\nOAuthBasicExchangeAuthenticator.prototype.authenticate = function authenticate(callback) {\n  var self = this;\n  self.application.getApiKey(self.id,function(err,apiKey){\n    if(err){\n      callback(err.status===404 ? new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client', statusCode: 401}) : err);\n    }else{\n      if(\n        (apiKey.secret===self.secret) &&\n        (apiKey.status==='ENABLED') &&\n        (apiKey.account.status==='ENABLED')\n      ){\n        var result = new AuthenticationResult(apiKey,self.application.dataStore);\n\n        result.forApiKey = apiKey;\n        result.application = self.application;\n        result.ttl = self.ttl;\n\n        self.buildTokenResponse(apiKey, function onTokenResponse(err, tokenResponse) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          result.tokenResponse = tokenResponse;\n\n          callback(null, result);\n        });\n      }else{\n        callback(new ApiAuthRequestError({userMessage: 'Invalid Client Credentials', error: 'invalid_client', statusCode: 401}));\n      }\n    }\n  });\n};\n\nOAuthBasicExchangeAuthenticator.prototype.buildTokenResponse = function buildTokenResponse(apiKey, callback) {\n  var self = this;\n\n  var account = apiKey.account;\n  var requestedScope = self.requestedScope;\n\n  function retrieveScopeFactoryResult(callback) {\n    var hasBeenCalled = false;\n\n    function callbackWithResult(err, scope) {\n      if (hasBeenCalled) {\n        throw new Error('Callback has already been called once. Assert that your scopeFactory doesn\\'t return a result while also calling the callback.');\n      }\n\n      hasBeenCalled = true;\n\n      callback(err, scope);\n    }\n\n    var optionalResult = self.scopeFactory(account, requestedScope, callbackWithResult);\n\n    // For backward-compatibility: If we have a result then call the callback immediately,\n    // else expect it to be handled by the scopeFactory function.\n    if (optionalResult || optionalResult === '') {\n      callbackWithResult(null, optionalResult);\n    }\n  }\n\n  retrieveScopeFactoryResult(function onScopeResolved(err, scopeResult) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    // TODO v1.0.0 - remove array option for tokens, should be string\n    callback(null, {\n      access_token: self.buildAccessToken(account, scopeResult),\n      token_type: 'bearer',\n      expires_in: self.ttl,\n      scope: Array.isArray(scopeResult) ? scopeResult.join(' ') : scopeResult\n    });\n  });\n};\n\nOAuthBasicExchangeAuthenticator.prototype.buildAccessToken = function buildAccessToken(account, scope) {\n  var now = nowEpochSeconds();\n\n  var _jwt = {\n    sub: this.id,\n    iss: this.application.href,\n    iat: now,\n    exp: now + this.ttl\n  };\n\n  if(scope){\n    // TODO v1.0.0 - remove string option, should be array only\n    _jwt.scope = Array.isArray(scope) ? scope.join(' ') : scope;\n  }\n\n  return this._token = jwt.encode(_jwt, this.application.dataStore.requestExecutor.options.client.apiKey.secret, 'HS256');\n};\n\nmodule.exports = OAuthBasicExchangeAuthenticator;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/MemcachedStore.js":"'use strict';\n\nvar Memcached = require('memcached');\n\n// todo: create store provider and register redis store only for node.js version\nvar CacheEntry = require('./CacheEntry');\n\n/**\n * @class\n *\n * @private\n *\n * @description\n *\n * Caching implementation that uses Redis as data storage.  If an existing\n * client instance is not provided, this constructor will create one.  Utilizes\n * the [memcached library](https://github.com/3rd-Eden/memcached).\n *\n * @param {Object} [options]\n * @param {Object} [options.client] A memcached client instance\n * @param {Object|String|Array} [options.connection] Memcached client constructor\n * connection string parameter.\n * @param {*} [options.*] Other options to pass to the Memcached client constructor.\n */\nfunction MemcachedStore(opt){\n  this._options = opt || {};\n  this.memcached = opt.client || MemcachedStore._createClient(opt);\n}\n\nMemcachedStore._createClient = function creteMemcachedClient(opt){\n  return new Memcached(opt.connection, opt.options);\n};\n\nMemcachedStore.prototype.get = function (key, cb){\n  this.memcached.get(key, function(err, entry){\n    return cb(err, !entry ? null : CacheEntry.parse(entry));\n  });\n};\n\nMemcachedStore.prototype.set = function (key, val, cb){\n  this.memcached.set(key, val, this._options.ttl, cb);\n};\n\nMemcachedStore.prototype.delete = function (key, cb){\n  this.memcached.del(key, cb);\n};\n\nMemcachedStore.prototype.clear = function (cb){\n  this.memcached.flush(cb);\n};\n\nMemcachedStore.prototype.size = function (cb){\n  this.memcached.stats(function(err, stats){\n    var size = stats && stats.length ? stats[0].curr_items : -1;\n    cb(err, size);\n  });\n};\n\nmodule.exports = MemcachedStore;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/cache/RedisStore.js":"'use strict';\n\nvar redis = require('redis');\n\nvar CacheEntry = require('./CacheEntry');\n\n/**\n * @class\n *\n * @private\n *\n * @description\n *\n * Caching implementation that uses Redis as data storage.  If an existing\n * client instance is not provided, this constructor will create one. Utilizes\n * the [node-redis](https://github.com/NodeRedis/node_redis) library.\n *\n * @param {Object} [options]\n * @param {Object} [options.client] A redis client instance\n * @param {Object} [options.connection] Redis client constructor connection options\n * @param {Number} [options.connection.port] DB port number\n * @param {String} [options.connection.host] DB host name\n * @param {*} [options.*] Other options to pass to the Redis client constructor.\n */\nfunction RedisStore(opt){\n  this._options = opt || {};\n  this.redis = opt.client || RedisStore._createClient(opt);\n  this.redis.debug_mode = /redis/i.test(process.env.DEBUG);\n}\n\nRedisStore._createClient = function createRedisClient(opt){\n  var conn = (opt && opt.connection) || {port:'6379',host:'127.0.0.1'};\n  return redis.createClient(conn.port, conn.host, opt.options);\n};\n\nRedisStore.prototype.get = function (key, cb){\n  this.redis.get(key, function(err, entry){\n    return cb(err, !entry ? null : CacheEntry.parse(JSON.parse(entry)));\n  });\n};\n\nRedisStore.prototype.set = function (key, val, cb){\n  var entry = JSON.stringify(val);\n  this.redis.set(key, entry, cb);\n  if (this._options.ttl){\n    this.redis.expire(key, this._options.ttl);\n  }\n};\n\nRedisStore.prototype.delete = function (key, cb){\n  this.redis.del(key, cb);\n};\n\nRedisStore.prototype.clear = function (cb){\n  this.redis.flushdb(cb);\n};\n\nRedisStore.prototype.size = function (cb){\n  this.redis.dbsize(cb);\n};\n\nmodule.exports = RedisStore;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/error/messages.js":"module.exports = {\n  ID_SITE_INVALID_CB_URI: \"cb_uri URI must be provided and must be in your ID Site whitelist\",\n  ID_SITE_JWT_INVALID_AUD: \"The client used to sign the jwtResponse is different than the one used in this datasore.\",\n  ID_SITE_JWT_HAS_EXPIRED: \"Token has expired\",\n  ID_SITE_JWT_ALREADY_USED: \"Token has already been used.\"\n};","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/AccessToken.js":"'use strict';\n\nvar utils = require('../utils');\n\n/**\n * @class AccessToken\n *\n * @description\n *\n * Encapsulates a Stormpath OAuth Access Token Resource. For full\n * documentation of this resource, please see\n * [REST API Reference: Access tokens](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#access-tokens).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - From the client, using the access token stormpath href {@link Client#getAccessToken Client.getAccessToken()}\n * - From the account, {@link Account#getAccessTokens Account.getAccessTokens()}\n * - From a JWT authentication, {@link JwtAuthenticator#authenticate JwtAuthenticator}\n * - From an OAuth 2.0 password grant authentication, {@link OAuthPasswordGrantRequestAuthenticator#authenticate OAuthPasswordGrantRequestAuthenticator}\n *\n * For a high-level overview of token management, please see\n * {@link https://docs.stormpath.com/rest/product-guide/latest/auth_n.html#introduction-to-token-based-authentication Introduction to Token-Based Authentication}.\n *\n * To revoke a access token, invoke the `delete()` method on an instance of\n * this class.\n *\n * @param {Object} accessTokenResource\n *\n * The JSON representation of this resource, retrieved from the Stormpath REST API.\n */\nfunction AccessToken() {\n  AccessToken.super_.apply(this, arguments);\n}\n\n// TODO: implement getAccount(), getRefreshToken()\n\nutils.inherits(AccessToken, require('./InstanceResource'));\n\nmodule.exports = AccessToken;\n\n/**\n * Deletes this resource from the API.\n *\n * @method AccessToken.delete\n *\n * @param {Function} callback\n * The function to call when the delete operation is complete. Will be called\n * with the parameter (err).\n */\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/AccountCreationPolicy.js":"var InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class AccountCreationPolicy\n *\n * @description\n * Encapsulates the account creation policy of a {@link Directory}. For full documentation of the this resource, please see\n * [REST API Reference: Account Creation Policy](https://docs.stormpath.com/rest/product-guide/latest/reference.html#account-creation-policy).\n *\n * For a high-level overview account verification workflows, please see:\n * - [How to Verify an Account’s Email](https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt.html#how-to-verify-an-account-s-email).\n * - [Customizing Stormpath Emails via REST](https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt.html#customizing-stormpath-emails-via-rest).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Directory#getAccountCreationPolicy Directory.getAccountCreationPolicy()}\n *\n * @param {Object} accountCreationPolicyResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\n\n/**\n * @method AccountCreationPolicy.save\n *\n * @description\n *\n * Save changes to this resource.\n *\n * @param {Function} callback\n * The function to call when the save operation is complete. Will be called\n * with the parameters (err, updatedResource).\n */\n\n\nfunction AccountCreationPolicy() {\n  AccountCreationPolicy.super_.apply(this, arguments);\n}\n\nutils.inherits(AccountCreationPolicy, InstanceResource);\n\nmodule.exports = AccountCreationPolicy;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/AccountLinkingPolicy.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class AccountLinkingPolicy\n *\n * @description\n *\n * Encapsulates an AccountLinkingPolicy resource. For full documentation of this resource,\n * please see\n * [REST API Reference: Account LinkingPolicy](https://docs.stormpath.com/rest/product-guide/latest/reference.html#account-linking-policy).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Application#getAccountLinkingPolicy Application.getAccountLinkingPolicy()}\n * - {@link Organization#getAccountLinkingPolicy Organization.getAccountLinkingPolicy()}\n *\n * Furthermore, an Account Linking Policy cannot be created or deleted from the SDK. Instead, it is\n * automatically created for all {@link Application} and {@link Organization} resources,\n * but can then be modified.\n *\n * @augments {InstanceResource}\n *\n * @param {Object} AccountLinkingPolicyResource\n *\n * The JSON representation of this resource.\n *\n */\nfunction AccountLinkingPolicy() {\n  AccountLinkingPolicy.super_.apply(this, arguments);\n}\n\nutils.inherits(AccountLinkingPolicy, InstanceResource);\n\n/**\n* Retrieves this account linking policy's associated tenant.\n*\n* @param {ExpansionOptions} options\n* Options for retrieving linked resources of the {@link Tenant} during this request.\n*\n* @param {Function} callback\n* The callback that will be called with the parameters (err, {@link Tenant}).\n*/\nAccountLinkingPolicy.prototype.getTenant = function getTenant(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.tenant.href, args.options, require('./Tenant'), args.callback);\n};\n\n// Removes the inherited delete method. This resource cannot be deleted manually!\nAccountLinkingPolicy.prototype.delete = undefined;\n\nmodule.exports = AccountLinkingPolicy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/AccountLink.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class AccountLink\n *\n * @description\n *\n * Encapsulates an AccountLink resource. For full documentation of this resource,\n * please see\n * [REST API Reference: AccountLink](https://docs.stormpath.com/rest/product-guide/latest/reference.html#account-link).\n *\n * For information about automatically generating account links, please see\n * {@link https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt.html#account-linking-automatic Automatic Account Linking}.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Account#getAccountLinks Account.getAccountLinks()}\n * - {@link Account#createAccountLink Account.createAccountLink()}\n * - {@link Tenant#createAccountLink Tenant.createAccountLink()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} accountLinkResource\n *\n * The JSON representation of this resource.\n */\nfunction AccountLink() {\n  AccountLink.super_.apply(this, arguments);\n}\n\nutils.inherits(AccountLink, InstanceResource);\n\n/**\n* Retrieves the \"left\" account of this account link. The \"left\" and \"right\"\n* designations are purely arbitrary and imply no hierarchy or priority between\n* the two.\n*\n* @param {ExpansionOptions} [options]\n* For retrieving linked resources of the query result.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called with\n* the parameters (err, {@link Account}).\n*/\nAccountLink.prototype.getLeftAccount = function getLeftAccount(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.leftAccount.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n* Retrieves the \"right\" account of this account link. The \"left\" and \"right\"\n* designations are purely arbitrary and imply no hierarchy or priority between\n* the two.\n*\n* @param {ExpansionOptions} [options]\n* For retrieving linked resources of the query result.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called with\n* the parameters (err, {@link Account}).\n*/\nAccountLink.prototype.getRightAccount = function getRightAccount(/* [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.rightAccount.href, args.options, require('./Account'), args.callback);\n};\n\nmodule.exports = AccountLink;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/AccountStoreMapping.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class AccountStoreMapping\n *\n * @description\n *\n * Encapsulates an Account Store Mapping Resource, and is a base class for\n * {@link ApplicationAccountStoreMapping} and {@link OrganizationAccountStoreMapping}.\n * For full documentation of the PasswordPolicy resource, please see\n * [REST API Reference: Account Store Mapping](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#account-store-mapping).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Application#getAccountStoreMappings Application.getAccountStoreMappings()}\n * - {@link Organization#getAccountStoreMappings Organization.getAccountStoreMappings()}\n *\n * An account store mapping can exist in two ways:\n *\n * - Between an {@link Application} and a {@link Directory}, {@link Group}, or\n *   {@link Organization}.\n *\n * - Between an {@link Organization} and a {@link Directory} or {@link Group}.\n *\n * For more information about account store mappings, please see\n * [Modeling Your User Base](https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt.html#modeling-your-user-base).\n *\n * @param {object} accountStoreMappingResource\n *\n * The JSON representation of this resource.\n *\n */\nfunction AccountStoreMapping() {\n  AccountStoreMapping.super_.apply(this, arguments);\n}\n\nutils.inherits(AccountStoreMapping, InstanceResource);\n\nfunction AccountStoreClassFactory(data, dataStore) {\n  var Class = null;\n  if (!data || !data.href) {\n    Class = InstanceResource;\n  }\n\n  if (/\\/groups/.test(data.href)) {\n    Class = require('./Group');\n  }\n\n  if (/\\/directories/.test(data.href)) {\n    Class = require('./Directory');\n  }\n\n  if (/\\/organizations/.test(data.href)) {\n    Class = require('./Organization');\n  }\n\n  if (!Class) {\n    throw new Error('Unknown resource type of Account Store in Account Store Mapping, href:' + data.href);\n  }\n\n  return require('./ResourceFactory').instantiate(Class, data, null, dataStore);\n}\n\nAccountStoreClassFactory.super_ = InstanceResource;\n\nAccountStoreMapping.prototype.getApplication = function getApplication(/* [options,] callback */) {\n  /*\n    This has been moved to ApplicationAccountStoreMapping, should be removed.\n    @TODO Version 1.0\n  */\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.application.href, args.options, require('./Application'), args.callback);\n};\n\n/**\n * @description\n *\n * Get the Account Store of this mapping. For an\n * {@link ApplicationAccountStoreMapping} this will be a {@link Directory},\n * {@link Group}, or {@link Organization}. For an\n * {@link OrganizationAccountStoreMapping} this will be a {@link Directory} or\n * {@link Group}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link AccountStoreMapping} during this request.\n *\n * @param {Function} callback\n * The callback to call when the operation is complete. Will be called with\n * (err, <{@link Directory}|{@link Group}>).\n *\n */\nAccountStoreMapping.prototype.getAccountStore = function getAccountStore(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accountStore.href, args.options, AccountStoreClassFactory, args.callback);\n};\n\n/**\n * This is not necessary, application can be passed to createAccountStoreMapping().  Remove in 1.0\n *\n * @private\n */\nAccountStoreMapping.prototype.setApplication = function setAccountStoreMappingApplication(application) {\n  this.application = { href: application.href };\n};\n\n/**\n * This is not necessary, accountStore can be passed to createAccountStoreMapping().  Remove in 1.0\n *\n * @private\n */\nAccountStoreMapping.prototype.setAccountStore = function setAccountStoreMappingAccountStore(accountStore) {\n  this.accountStore = { href: accountStore.href };\n  return this;\n};\n\nmodule.exports = AccountStoreMapping;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/ApplicationAccountStoreMapping.js":"'use strict';\n\nvar utils = require('../utils');\nvar AccountStoreMapping = require('./AccountStoreMapping');\n\n/**\n * @class\n *\n * @augments {AccountStoreMapping}\n *\n * @description\n *\n * This object encapsulates an Application Account Store Mapping, which\n * represents the link between an {@link Application} and an Account Store, such\n * as a {@link Directory}, {@link Group}, or {@link Organization}.  For full\n * documentation of this resource, please see\n * [REST API Reference: Account Store Mapping](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#account-store-mapping).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Application#createAccountStoreMapping Application.createAccountStoreMapping()}\n * - {@link Application#getAccountStoreMappings Application.getAccountStoreMappings()}\n *\n * For more information about account store mappings, please see\n * [Modeling Your User Base](https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt.html#modeling-your-user-base).\n *\n * @param {object} accountStoreMappingResource\n *\n * The JSON representation of this resource.\n */\nfunction ApplicationAccountStoreMapping() {\n  ApplicationAccountStoreMapping.super_.apply(this, arguments);\n}\n\nutils.inherits(ApplicationAccountStoreMapping, AccountStoreMapping);\n\n/**\n * @description\n *\n * Gets the {@link Application} that is associated with this account store mapping.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Application} during this request.\n *\n * @param {Function} callback\n * The callback to call when the operation is complete. Will be called with\n * (err, {@link Application}).\n */\nApplicationAccountStoreMapping.prototype.getApplication = function getApplication(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.application.href, args.options, require('./Application'), args.callback);\n};\n\n/**\n * This is not necessary, application can be passed to createAccountStoreMapping().  Remove in 1.0\n *\n * @private\n */\nApplicationAccountStoreMapping.prototype.setApplication = function setApplication(application) {\n  this.application = { href: application.href };\n  return this;\n};\n\nmodule.exports = ApplicationAccountStoreMapping;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Application.js":"'use strict';\n\nvar async = require('async');\nvar _ = require('underscore');\nvar njwt = require('njwt');\nvar url = require('url');\nvar uuid = require('uuid');\n\nvar Account = require('./Account');\nvar ApiAuthRequestError = require('../error/ApiAuthRequestError');\nvar ApplicationAccountStoreMapping = require('./ApplicationAccountStoreMapping');\nvar AuthenticationResult = require('./AuthenticationResult');\nvar AuthRequestParser = require('../authc/AuthRequestParser');\nvar BasicApiAuthenticator = require('../authc/BasicApiAuthenticator');\nvar InstanceResource = require('./InstanceResource');\nvar OauthAccessTokenAuthenticator = require('../authc/OauthAccessTokenAuthenticator');\nvar OAuthBasicExchangeAuthenticator = require('../authc/OAuthBasicExchangeAuthenticator');\nvar PasswordResetToken = require('./PasswordResetToken');\nvar errorMessages = require('../error/messages');\nvar utils = require('../utils');\n\n/**\n * @class Application\n *\n * @augments {InstanceResource}\n *\n * @description\n *\n * Encapsulates an Application resource. For full documentation of this resource,\n * please see\n * [REST API Reference: Application](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#application).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Client#getApplication Client.getApplication()}.\n *\n * @param {Object} applicationResource\n *\n * The JSON representation of this resource.\n */\nfunction Application() {\n  Application.super_.apply(this, arguments);\n}\nutils.inherits(Application, InstanceResource);\n\n/**\n * Creates a URL which will redirect a user to your ID Site. The URL will look\n * like `https://api.stormpath.com/v1/sso?jwtRequest=<token>`. Once the URL\n * is created, you should issue a 302 redirect to this URL. The `/sso`\n * endpoint will consume the request, and then redirect the user to your ID\n * Site application. This entire process happens over HTTPS and all the JWTs\n * are signed with secret keys for security.\n *\n * After the user authenticates on your ID Site, they will be redirected back to\n * the specified `callbackUri`.  You will need to parse that response with\n * {@link Application#handleIdSiteCallback Application.handleIdSiteCallback()}\n * to retrieve the account of the user that has authenticated.\n *\n * For more information on our ID Site feature, please see\n * [Using ID Site](https://docs.stormpath.com/rest/product-guide/latest/idsite.html).\n *\n * @param {Object} options ID Site redirect options.\n *\n * @param {String} options.callbackUri\n * **REQUIRED**. The full URL where the user should be sent after they authenticate\n * on your ID Site, e.g. `https://www.example.com/dashboard`. For security reasons,\n * this URL must be registered as an authorized callback URI in your ID Site configuration. This\n * can be managed via the REST API or the Stormpath Admin Console.  This response\n * should be parsed with {@link Application#handleIdSiteCallback Application.handleIdSiteCallback()}.\n *\n * @param {Boolean} options.logout=false\n * If `true`, the user will be logged out of their session and immediately\n * redirected to the specified `callbackUri`.\n *\n * @return {String} The URL to redirect the user to.\n *\n * @param {String} options.organizationNameKey=null\n * *Multi-tenancy option.*\n *\n * The organization name key to auto-fill in the Organization field on ID Site.\n * This value will be fixed and the user cannot change it. Use this if you already\n * know which Organization the user will be logging into.  If you don't know\n * which Organization the user should log in to, and you want the user to specify\n * it, you should set `showOrganizationField` to `true`, and they will be shown\n * a field where they can specify the Organization.\n *\n * If there is no organization with that name key, or the organization is not\n * mapped to the current Stormpath Application, an error will be returned to the\n * callback URI.\n *\n * @param {Boolean} options.showOrganizationField=null\n * *Multi-tenancy option.*\n *\n * If `true`, show the organization field on ID Site, so that the user must\n * provide the name key of the organization that they wish to log into.  If the\n * Application does not have any Organizations mapped to it, this option has no\n * effect.\n *\n * If `true`, and `organizationNameKey` is defined, then the `organizationNameKey`\n * will be placed in the field, but the field will not be editable.\n *\n * If `false`, and `organizationNameKey` is defined, then the Organization field\n * will be hidden but the authentication attempt will still be targeted at the\n * specified organization.\n *\n * @param {String} options.state=null\n * Custom string that can be used to carry state through the request. This\n * state property will be available in the JWT payload on ID Site, and in the\n * JWT that is provided to your callback URI.\n *\n * @param {Boolean} options.useSubDomain\n * *Multi-tenancy option.*\n *\n * Use the provided `organizationNameKey` as the domain prefix for the ID Site\n * URL. For example, if `organizationNameKey` is `org-a` and your ID Site URL\n * is `https://id.example.com` then the user will be redirected to\n * `https://org-a.id.example.com`.\n *\n * @example <caption>Manually redirect the user to ID Site, if using Express, but not using {@link http://docs.stormpath.com/nodejs/express/latest/ Express-Stormpath}</caption>\n *\n * var application; // An existing reference to an Application resource\n *\n * app.get('/login', function (req, res) {\n *   var url = application.createIdSiteUrl({\n *     callbackUri: 'http://localhost:3000/idSiteCallback'\n *   });\n *   res.redirect(url);\n * });\n *\n * app.get('/idSiteCallback', function (req, res) {\n *   application.handleIdSiteCallback(req.url, function (err, idSiteAuthenticationResult) {\n *     if (err) {\n *       console.error(err);\n *       res.end(500);\n *     } else {\n *       res.json(idSiteAuthenticationResult.account);\n *     }\n *   });\n * });\n *\n * @example <caption> Configuring automatic redirection to ID Site, if using {@link http://docs.stormpath.com/nodejs/express/latest/ Express-Stormpath}</caption>\n *\n * app.use(stormpath.init(app, {\n *   web: {\n *     idSite: {\n *       enabled: true\n *     }\n *   }\n * }));\n */\nApplication.prototype.createIdSiteUrl = function createIdSiteUrl(_options) {\n  var options = typeof _options === \"object\" ? _options : {};\n  var p = url.parse(this.href);\n  var base = p.protocol + '//' + p.host;\n  var apiKey = this.dataStore.requestExecutor.options.client.apiKey;\n  var nonce = uuid();\n  var state = options.state || '';\n\n  if(!options.callbackUri){\n    throw new Error(errorMessages.ID_SITE_INVALID_CB_URI);\n  }\n\n  var payload = {\n    jti: nonce,\n    iat: new Date().getTime()/1000,\n    iss: apiKey.id,\n    sub: this.href,\n    state: encodeURIComponent(state),\n    path: options.path || '/',\n    cb_uri: options.callbackUri\n  };\n\n  if(typeof options.showOrganizationField === 'boolean'){\n    payload.sof = options.showOrganizationField;\n  }\n\n  if(options.organizationNameKey){\n    payload.onk = options.organizationNameKey;\n  }\n\n  if(typeof options.useSubDomain === 'boolean'){\n    payload.usd = options.useSubDomain;\n  }\n\n  if(Array.isArray(options.require_mfa)){\n    payload.require_mfa = options.require_mfa;\n  }\n\n  if(Array.isArray(options.challenge)){\n    payload.challenge = options.challenge;\n  }\n\n  var token = njwt.create(payload,apiKey.secret,'HS256');\n\n  var redirectUrl = base + '/sso'+(options.logout?'/logout':'')+'?jwtRequest=' + token;\n\n  return redirectUrl;\n};\n\nApplication.prototype._decodeJwt = function _decodeJwt(str,secret){\n  var jwtObject;\n  try{\n    jwtObject = njwt.verify(str, secret);\n    return jwtObject;\n  }\n  catch(e){\n    return e;\n  }\n};\n\n/**\n * This method will parse the JWT result from an ID Site Callback, and give you\n * an {@link IdSiteAuthenticationResult}, which contains the  {@link Account}\n * object of the account that was authenticated.\n *\n * @param {String} responseUri\n * The URL that the user has arrived on your site with.\n * For example, `http://example.com/idSiteCallback?jwtResponse=<token>`.\n *\n * @param {Function} callback\n * Will be called with (err, {@link IdSiteAuthenticationResult idSiteAuthenticationResult}).\n *\n * @example <caption>Manually handling an ID Site Callback, if using Express.</caption>\n *\n * app.get('/idSiteCallback', function (req, res) {\n *   application.handleIdSiteCallback(req.url, function (err, idSiteAuthenticationResult) {\n *     if (err) {\n *       console.error(err);\n *       res.end(500);\n *     } else {\n *       res.json(idSiteAuthenticationResult.account);\n *     }\n *   });\n * });\n */\nApplication.prototype.handleIdSiteCallback = function handleIdSiteCallback(responseUri,callback) {\n  if(typeof responseUri !== 'string'){\n    throw new Error('handleIdSiteCallback must be called with an uri string');\n  }\n\n  var cb = typeof callback === 'function' ? callback : utils.noop;\n\n  var params = (url.parse(responseUri,true).query) || {};\n  var token = params.jwtResponse || '';\n\n  var dataStore = this.dataStore;\n  var secret = dataStore.requestExecutor.options.client.apiKey.secret;\n  var apiKeyId = dataStore.requestExecutor.options.client.apiKey.id;\n\n  var responseJwt = this._decodeJwt(token,secret);\n\n  if(responseJwt instanceof Error){\n    return cb(responseJwt);\n  }\n\n  if(responseJwt.body && responseJwt.body.err){\n    return cb(responseJwt.body.err);\n  }\n\n  if(responseJwt.body.aud !== apiKeyId){\n    return cb(new Error(errorMessages.ID_SITE_JWT_INVALID_AUD));\n  }\n\n  if(!utils.isNumber(responseJwt.body.exp) || (utils.nowEpochSeconds() > responseJwt.body.exp)){\n    return cb(new Error(errorMessages.ID_SITE_JWT_HAS_EXPIRED));\n  }\n\n  var nonce = responseJwt.body.irt;\n  var accountHref = responseJwt.body.sub;\n\n  dataStore.nonceStore.getNonce(nonce,function(err,value){\n    if(err){\n      cb(err);\n    }else if(value){\n      cb(new Error(errorMessages.ID_SITE_JWT_ALREADY_USED));\n    }else{\n      dataStore.nonceStore.putNonce(nonce,utils.noop);\n\n      dataStore.getResource(accountHref,Account,function(err,account){\n        if(err){\n          cb(err);\n        }else{\n          /**\n           * @typedef {Object} IdSiteAuthenticationResult\n           *\n           * @property {Object} account\n           * The {@link Account account} that was authenticated on ID Site.\n           *\n           * @property {String} state\n           * Custom state that was passed to ID Site, via the original request\n           * from\n           * {@link Application#createIdSiteUrl Application.createIdSiteUrl()}.\n           *\n           * @property {String} isNew\n           * Indicates that this account is a new account, and the registration\n           * was completed on ID Site.\n           *\n           * @property {String} status\n           * Indicates the action that the user completed on ID Site, which will\n           * be one of the following:\n           *\n           * - `AUTHENTICATED` - The user already had an account and they\n           *   successfully authenticated (\"logged in\").\n           * - `REGISTERED` - The user created a new account on ID Site.\n           * - `LOGOUT` - The user has logged out.\n           */\n          cb(null,{\n            account: account,\n            state: decodeURIComponent(responseJwt.body.state),\n            isNew: responseJwt.body.isNewSub,\n            status: responseJwt.body.status\n          });\n        }\n      });\n    }\n  });\n};\n/**\n * Attempt to authenticate an account, using username/email and password. Use\n * this method to assert that the supplied password is the correct password for\n * an account.\n *\n * @param {Object} authenticationRequest\n * Authentication request object, can only be used for username and password authentication.\n *\n * @param {Object} authenticationRequest.username\n * The username or email address of an {@link Account} that exists in a {@link Directory}.\n *\n * @param {Object} authenticationRequest.password\n * The password for the Account.\n *\n * @param {Object} [authenticationRequest.accountStore]\n * An optional parameter that can specify the name key of an Organization to\n * authenticate the Account against.\n *\n * @param {String} authenticationRequest.accountStore.nameKey\n * An Organization's name key.\n *\n * @param {Function} callback\n * Callback function called with (err, {@link AuthenticationResult authenticationResult}).\n *\n * @example\n *\n * var authenticationRequest = {\n *   username: 'user@example.com', // Can be username or email address of account.\n *   password: 'RawPassw0rd!',\n *   // Optional parameter accountStore can specify the name key of the Organization to authenticate against\n *   accountStore: {\n *     nameKey: 'app1'\n *   }\n * };\n *\n * application.authenticateAccount(authenticationRequest, function(err, result) {\n *   // If no error, the user's credentials were valid.  Now fetch the account:\n *   result.getAccount(function(err, account) {\n *     console.log(account);\n *   });\n * };\n */\nApplication.prototype.authenticateAccount = function authenticateApplicationAccount(authenticationRequest, callback) {\n  var _this = this,\n    username = authenticationRequest.username,\n    password = authenticationRequest.password,\n    type = authenticationRequest.type || 'basic';\n  var accountStore = ('string' === typeof authenticationRequest.accountStore) ?\n    {href: authenticationRequest.accountStore} :\n    authenticationRequest.accountStore;\n\n  var loginAttempt = {\n    type: type,\n    value: utils.base64.encode(username + ':' + password)\n  };\n\n  if (authenticationRequest.accountStore){\n    loginAttempt.accountStore = accountStore;\n  }\n\n  _this.dataStore.createResource(\n    _this.loginAttempts.href,\n    {expand: 'account'},\n    loginAttempt,\n    AuthenticationResult,\n    function(err,authenticationResult){\n      if(err){\n        callback(err);\n      }\n      else{\n        authenticationResult.application = _this;\n        callback(null,authenticationResult);\n      }\n  });\n};\n\n/**\n * Sends a password reset email to the account holder. This email will contain\n * a link with a password reset token. The format of the link is controlled by\n * the Password Policy of the {@link Directory} that the account is in. For\n * more information on the email, please see\n * {@link https://docs.stormpath.com/rest/product-guide/latest/004_accnt_mgmt.html#manage-password-reset-emails Manage Password Reset Emails}.\n *\n * If you want the raw token (e.g. to manually send your own email with\n * the token) you can do so by working with the {@link PasswordResetToken}\n * instance that is provided to the callback.\n *\n * @param {Object} passwordResetRequest\n * The password reset request object.\n *\n * @param {String} passwordResetRequest.email\n * The email address of the account that you wish to send a password reset email\n * to.\n *\n * @param {Object} [passwordResetRequest.accountStore]\n * An object that allows you to define an account store for this request.\n *\n * @param {Object} passwordResetRequest.accountStore.href\n * The HREF of the account store that you wish to target, for locating the\n * the account object.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link PasswordResetToken passwordResetToken}).\n *\n * @example\n *\n * var passwordResetRequest = {\n *   email: 'foo@example.com'\n * };\n *\n * application.sendPasswordResetEmail(passwordResetRequest, function(err, passwordResetToken) {\n *   // The token is the last part of the HREF.\n *   console.log(passwordResetToken.href.split('/').pop());\n *\n *   // The account can be retrieved by using the account href on the result.\n *   client.getAccount(passwordResetToken.account.href, function(err, account) {\n *     console.log(account);\n *   });\n * });\n */\nApplication.prototype.sendPasswordResetEmail = function sendApplicationPasswordResetEmail(passwordResetRequest, callback) {\n  // @TODO - deprecate the string-only version\n  var data = typeof passwordResetRequest === 'string' ? {\n    email: passwordResetRequest\n  } : passwordResetRequest;\n  return this.dataStore.createResource(this.passwordResetTokens.href, null, data, PasswordResetToken, callback);\n};\n\n/**\n * Re-sends the account verification email to the specified account.  The email\n * will contain a token that can be verified with {@link Tenant#verifyAccountEmail Tenant.verifyAccountEmail()}.\n *\n * @param {Object} resendVerificationEmailRequest\n *\n * @param {String} resendVerificationEmailRequest.login\n * The username or email address of the account that you wish to re-send the\n * verification email to.\n *\n * @param {Object} [resendVerificationEmailRequest.accountStore]\n * An object that allows you to define an account store for this request.\n *\n * @param {Object} resendVerificationEmailRequest.accountStore.href\n * The HREF of the account store that you wish to target, for locating the\n * the account object.\n *\n * @param {Function} callback\n * Callback function, will be called with (err).\n *\n * @example\n *\n * var resendVerificationEmailRequest = {\n *   login: 'foo@example.com'\n * };\n *\n * application.resendVerificationEmail(resendVerificationEmailRequest, function(err) {\n *   if (!err) {\n *     console.log('Email re-sent to ' + resendVerificationEmailRequest.login);\n *   }\n * });\n */\nApplication.prototype.resendVerificationEmail = function resendVerificationEmail(resendVerificationEmailRequest, callback) {\n  return this.dataStore.createResource(this.verificationEmails.href, resendVerificationEmailRequest, callback);\n};\n\n/**\n * Verifies that the given password reset token is valid and can be used for a\n * password change request (via {@link Application#resetPassword Application.resetPassword()}).\n * The token is invalid if it has expired, has already been used, or was not\n * issued by a Stormpath Application.\n *\n * @param {String} passwordResetToken\n * The password reset token that was created by {@link Application#sendPasswordResetEmail Application.sendPasswordResetEmail()}.\n *\n * @param {Function} callback\n * Callback function, will be called with (err).\n *\n * @example\n *\n * var passwordResetToken = 'eyJraWQiOiI0Qk9aM1kyMTg0T0Q5VFJMS..'; // The token that was created by Application.sendPasswordResetEmail().\n *\n * application.verifyPasswordResetToken(passwordResetToken, function(err) {\n *   if (err) {\n *     console.log(err); // Token is invalid, expired, or already used.\n *   } else {\n *     console.log('Token is valid.');\n *   }\n * });\n */\nApplication.prototype.verifyPasswordResetToken = function verifyApplicationPasswordResetToken(passwordResetToken, callback) {\n  var href = this.passwordResetTokens.href + '/' + passwordResetToken;\n  return this.dataStore.getResource(href, callback);\n};\n\n/**\n * Sets a new password for the user, using the supplied password reset token.\n * The password reset token will be verified and the\n * {@link https://docs.stormpath.com/rest/product-guide/latest/reference.html#ref-password-policy password strength policy}\n * of the account's directory will be enforced.\n *\n * If this operation is successful, the password reset token will be consumed\n * and cannot be used again.\n *\n * @param {String} passwordResetToken\n * The password reset token that was created by {@link Application#sendPasswordResetEmail Application.sendPasswordResetEmail()}.\n *\n * @param {String} newPassword\n * The new password that the user desires.\n *\n * @param {Function} callback\n * Callback function, will be called with (err).\n *\n * @example\n *\n * var passwordResetToken = 'eyJraWQiOiI0Qk9aM1kyMTg0T0Q5VFJMS..'; // The token that was created by Application.sendPasswordResetEmail().\n *\n * var newPassword = 'Pa@ssw0Rd!1;'; // The new password that the user desires.\n *\n * application.resetPassword(passwordResetToken, newPassword, function(err) {\n *   if (err) {\n *     console.log(err); // Token is invalid, or password is not strong enough.\n *   } else {\n *     console.log('Password was reset.');\n *   }\n * });\n */\nApplication.prototype.resetPassword = function resetApplicationPassword(token, password, callback) {\n  var href = this.passwordResetTokens.href + '/' + token;\n  return this.dataStore.createResource(href, {expand: 'account'}, { password: password }, callback);\n};\n\n/**\n * Get the {@link SamlPolicy} of the application.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link SamlPolicy} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link SamlPolicy samlPolicy}).\n */\nApplication.prototype.getSamlPolicy = function getSamlPolicy(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.samlPolicy.href, args.options, require('./SamlPolicy'), args.callback);\n};\n\n/**\n * Get the account's collection for this Application, which is a list of all\n * accounts in all account stores that are mapped to this application.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `createdAt`, `email`, `givenName`, `middleName`, `modifiedAt`, `surname`,\n * `status`, `username`.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Account} objects.\n *\n * @example\n *\n * var query = {\n *   givenName: 'foo'\n * };\n *\n * application.getAccounts(query, function(err, collection) {\n *   collection.each(function(account, next) {\n *     console.log('Found account for ' + account.givenName + ' (' + account.email + ')');\n *     next();\n *   });\n * });\n */\nApplication.prototype.getAccounts = function getApplicationAccounts(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accounts.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n * @description\n *\n * Use this method to get an account from a provider directory (Google,\n * Facebook, etc). To use this method, you need to do the following:\n *\n * - Configure an application with the provider, and connect it with a Stormpath\n *   Directory. For instructions, please see\n *   {@link https://docs.stormpath.com/rest/product-guide/latest/auth_n.html#how-social-authentication-works How Social Authentication Works}.\n *\n * - Prompt the user to authenticate with the provider, via your provider\n *   application (e.g. Facebook application consent screen, Google+ login).\n *\n * - Collect the access token or code that is returned after the user provides\n *   consent to your application.\n *\n * - Pass that access token to this function, and declare the provider type.\n *\n * A new {@link Account} is created in the provider directory, if this user is\n * authenticating for the first time. Otherwise, the existing {@link Account}\n * resource will be retrieved.\n *\n * @param {Object} providerAccountRequest\n * An object which enumerates the provider store and the access token or code\n * that was obtained by the provider. Some providers use access tokens, while\n * others use codes. Only specify one or the other.\n *\n * @param {Object} providerAccountRequest.providerData\n *\n * @param {String} providerAccountRequest.providerData.providerId\n * The providerId of the directory, e.g. `github`, `google`, `facebook`,\n * `linkedin`.\n *\n * @param {String} [providerAccountRequest.providerData.accessToken]\n * The access token that was obtained from the provider.\n *\n * @param {String} [providerAccountRequest.providerData.code]\n * The access code that was obtained from the provider.\n *\n * @param {Function} callback\n * Callback function to call with parameters (`err`, {@link ProviderAccountResult}).\n *\n * @example\n *\n * var providerAccountRequest = {\n *   providerData: {\n *     providerId: 'facebook',\n *     accessToken: 'abc1235'\n *   }\n * };\n *\n * application.getAccount(providerAccountRequest, function(err, providerAccountResult) {\n *   if (providerAccountResult.created) {\n *     console.log('This user was newly created in the directory.');\n *   }\n *\n *   console.log(providerAccountResult.account);\n * });\n */\nApplication.prototype.getAccount = function getAccount(/* providerData, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['providerData', 'options', 'callback']);\n\n  if (!args.callback || !args.providerData || !args.providerData.providerData) {\n    throw new Error('Incorrect usage. Usage: Application.getAccount(providerData, [options], callback);');\n  }\n\n  var providerData = args.providerData.providerData;\n\n  if (typeof providerData !== 'object' || typeof providerData.providerId !== 'string' || (typeof providerData.code !== 'string' && typeof providerData.accessToken !== 'string')) {\n    throw new Error('This method is used to create or access social accounts only. Did you mean to call Client.getAccount(href)?');\n  }\n\n  function wrapCallback(cb) {\n    return function(err, account) {\n\n      /**\n       * @typedef {Object} ProviderAccountResult\n       *\n       * @property {Account} account\n       * The account from the Stormpath Directory.\n       *\n       * @property {Boolean} created\n       * True if this account was created for the first time.\n       */\n      if (err) {\n        return cb(err);\n      }\n\n      var isNew = account._isNew;\n      delete account._isNew;\n\n      cb(err, { account: account, created: isNew });\n    };\n  }\n\n  return this.dataStore.createResource(this.accounts.href, args.options, args.providerData, require('./Account'), wrapCallback(args.callback));\n};\n\n/**\n * Creates an {@link Account} in the application's default account store.\n *\n * @param {AccountData} accountData\n * The data for the new account object.\n *\n * @param {Object} [requestOptions]\n * Query parameters for this request.  These  can be any of the {@link ExpansionOptions},\n * e.g. to retrieve linked resources of the {@link Account} during this request, or one\n * of the other options listed below.\n *\n * @param {Boolean} [requestOptions.passwordFormat=null]\n * Set this to `MCF` if you already have a password hash, and can provide the\n * hash as the stormpath2 MCF has format.  For more information see\n * [Importing Accounts with MCF Hash Passwords](https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt.html#importing-mcf)\n *\n * @param {Function} callback - Callback function, will be called with (err,\n * {@link Account}).\n *\n * @example\n *\n * var account = {\n *   givenName: 'Foo',\n *   surname: 'Bar',\n *   username: 'foolmeonce',\n *   email: 'foo@example.com',\n *   password: 'Changeme1!'\n * };\n *\n * application.createAccount(account, function(err, createdAccount) {\n *   console.log(createdAccount);\n * });\n */\nApplication.prototype.createAccount = function createApplicationAccount(/* account, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['account', 'options', 'callback']);\n  return this.dataStore.createResource(this.accounts.href, args.options, args.account, require('./Account'), args.callback);\n};\n\n/**\n * Get the groups collection for this Application, which is a list of all\n * groups that are directly mapped to the application, and all groups that\n * exist in a directory that is mapped to the application.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `name`, `description`, `status`.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Group} objects.\n *\n * @example\n *\n * var query = {\n *   name: 'admins'\n * };\n *\n * application.getGroups(query, function(err, collection) {\n *   if (collection && collection.items.length === 1) {\n *     console.log('Found the admins group, href is: ' + group.href);\n *   }\n * });\n */\nApplication.prototype.getGroups = function getApplicationGroups(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.groups.href, args.options, require('./Group'), args.callback);\n};\n\n/**\n * Creates a group within the default group store of the Application. If the\n * application does not have a default group store, this will error.\n *\n * @param {Group} group\n * New group definition.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link Group}).\n *\n * @example\n *\n * var group = {\n *   name: 'New Users'\n * };\n *\n * application.createGroup(group, function (err, group) {\n *   if (!err) {\n *     console.log('Group Created!');\n *   }\n * });\n */\nApplication.prototype.createGroup = function createApplicationGroup(/* group, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['group', 'options', 'callback']);\n  return this.dataStore.createResource(this.groups.href, args.options, args.group, require('./Group'), args.callback);\n};\n\n/**\n * Gets the OAuth policy of this application. The OAuth policy defines the TTL\n * settings for the Access Tokens and Refresh Tokens that are issued by this\n * application's OAuth Token endpoint.\n *\n * The values must be an [ISO8060 Duration Formatted String](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link OAuthPolicy}).\n *\n * @example\n *\n * application.getOAuthPolicy(function (err, oAuthPolicy) {\n *   // Set the Access Token TTL to 1 hour, and disable Refresh Tokens.\n *   oAuthPolicy.accessTokenTtl = 'PT1H';\n *   oAuthPolicy.refreshTokenTtl = 'PT0D';\n *   oAuthPolicy.save();\n * });\n */\nApplication.prototype.getOAuthPolicy = function getOAuthPolicy(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.oAuthPolicy.href, args.options, require('./OAuthPolicy'), args.callback);\n};\n\n/**\n * Gets the Stormpath tenant resource that owns this resource.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Tenant} during this request.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link Tenant}).\n */\nApplication.prototype.getTenant = function getApplicationTenant(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.tenant.href, args.options, require('./Tenant'), args.callback);\n};\n\n/**\n * @description\n *\n * Retrieves the specified {@link ApiKey} for an Account that may login to the Application\n * (as determined by the application's mapped account stores). If the API Key does\n * not correspond to an Account that may login to the application, then a 404\n * error is provided to the callback.\n *\n * By default, the {@link ApiKey} resource is heavily encrypted. It is encrypted while\n * in transit from our REST API, and while at rest in the local cache that is\n * maintained by the SDK. The encryption input is the Tenant Api Key Secret\n * that was used when the {@link Client Client Instance} was constructed.\n * The default encryption strength is password-based AES 256 encryption and the\n * PBKDF2 implementation will use 1024 iterations to derive the AES 256 key.\n *\n * At the risk of potentially decreased security, you can use the options\n * argument to specify a lower level of encryption key size, e.g. 192 or 128.\n * You can also request a lower number of key iterations. This can reduce the\n * CPU time required to decrypt the key after transit or when retrieving from\n * cache. It is not recommended to go much lower than 1024 (if at all) in\n * security sensitive environments.\n *\n * @param {String} apiKeyId\n * The ID of the {@link ApiKey} to search for.\n *\n * @param {Object} options\n * Options for API Key encryption.\n *\n * @param {String} [options.encryptionKeySize=256]\n * Set to 128 or 192 to change the AES key encryption size.\n *\n * @param {String} [options.encryptionKeyIterations=1024]\n * The number of iterations to use in the PBKDF operation.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link ApiKey}).\n *\n * @example\n *\n * application.getApiKey('xxxxAAAyyBb', function(err, apiKey) {\n *   if (err) {\n *     console.log('Api Key could not be found.');\n *   } else {\n *     console.log(apiKey);\n *   }\n * });\n */\nApplication.prototype.getApiKey = function getApiKey(apiKeyId, options, callback) {\n  var argCount = Array.prototype.slice.call(arguments).length;\n  var cb = argCount === 3 ? callback : options;\n\n  var dataStore = this.dataStore;\n  var opts = _.extend({},dataStore.apiKeyEncryptionOptions,argCount === 3 ? options : {id:apiKeyId});\n\n  return dataStore.getResource(this.apiKeys.href, opts, require('./ApiKey'), function(err,result){\n    if(err){\n      cb(err);\n    }else if(result instanceof require('./ApiKey')){\n      // this happens if we found it in the cache. manually 'expand' the account\n      dataStore.getResource(result.account.href,function(err,account){\n        if(err){ cb(err); }else{\n          result.account = account;\n          cb(null,result);\n        }\n      });\n\n    }else if(result && result.items && result.items.length === 1 ){\n      cb(null,result.items[0]);\n    }else{\n      var error = new Error('ApiKey not found');\n      error.status = 404;\n      cb(error);\n    }\n  });\n};\n\n/**\n * @description\n *\n * This method allows you to issue API-Key based Access Tokens and perform API\n * Key authentication for your users, as described in\n * [Using Stormpath for API Authentication](http://docs.stormpath.com/guides/api-key-management/).\n *\n * **NOTE**: The OAuth flow that this method supports is the Client\n * Credentials workflow, which requires the {@link Account} to have an\n * {@link ApiKey}. The issued access tokens are stateless and cannot be\n * revoked. If you want to issue revoke-able Access Tokens and Refresh Tokens,\n * please use the {@link OAuthPasswordGrantRequestAuthenticator} to create\n * password-based tokens.\n *\n * **Issuing Access tokens**\n *\n * To issue Access tokens, the user must supply their {@link ApiKey} in the\n * Authorization header, as HTTP Basic format, and the POST body must define\n * the `client_credentials` grant type. The user may also provide the scope that\n * they desire. For example, the request may look like this:\n *\n * ```\n * Authorization: Basic <Base64 Encoded api_key_id:api_key_secret>\n *\n * grant_type=client_credentials\n * scope=scope-I-want\n * ```\n *\n * This method will process the request and create an access token, if the API\n * key and secret is valid, and if the account is reachable by this application\n * and the account is not disabled. You may optionally define a `scopeFactory`\n * to determine if the scope should be issued. An example of how to issue\n * access tokens is provided below.\n *\n * **Authenticating Access tokens**\n *\n * If the user has been issued an access token, they can use it to authenticate\n * requests by providing it in the `Authorization` header of the request, with\n * this format:\n *\n * ```\n * Authorization: Bearer <access_token>\n * ```\n *\n * If the token is not expired and the account is still enabled, this method\n * will produce an {@link OAuthClientCredentialsAuthenticationResult}.\n * Otherwise you will receive an authentication error, and you should not allow\n * the user to access the protected resource.\n *\n * This method will not make authorization decisions, based on the scope of the\n * token, this must be done by your application. Please see the example below.\n *\n * @param {Object} options\n * The data for this request, the `request` property must be supplied.\n *\n * @param {Object} options.request\n * An [Express-like request object](http://expressjs.com/en/api.html#req), that\n * must have the following properties:\n *\n * @param {String} options.request.url\n * The url of the request, including query parameters.\n *\n * @param {String} options.request.method\n * The method of the request, GET or POST depending on the type of request.\n *\n * @param {Object} options.request.headers\n * An object that contains the headers of the request, so that we can read the\n * `Authorization` header.\n *\n * @param {Object} options.request.body\n * An object that has the posted form body, this is required when requesting\n * an access token.\n *\n * @param {String} options.request.body.grant_type\n * Must be `client_credentials`.\n *\n * @param {String} options.request.body.username\n * The username or email address of the {@link Account} that is requesting an\n * access token.\n *\n * @param {String} options.request.body.password\n * The password of the {@link Account} that is requesting an access token.\n *\n * @param {Function} [options.scopeFactory]\n * A function that can define custom scope for the access token. When a user\n * is requesting an access token, we will call this function and you can tell us\n * what scope to add to the token. The function will be called with the\n * parameters `(account, requestedScope, callback)`. The `requestedScope` is\n * the value of the `scope` field from the user's POST, and the `callback`\n * should be called with the parameters `(err, grantedScope)`.\n *\n * @param {Number} [options.ttl]\n * The lifetime of the Access Tokens that are created by this method, in\n * seconds. Default is 3600 (one hour) if not specified.\n *\n * @param {Function} callback\n * The callback to call with the the authentication result, will be called with\n * the parameters (err, {@link OAuthClientCredentialsAuthenticationResult}).\n *\n * @example\n *\n * // This is how you would require HTTP Basic or Access Token authentication, for a route:\n * app.get('/protected/resource', function(req, res) {\n *   application.authenticateApiRequest({ request: req }, function(err, authResult) {\n *     authResult.getAccount(function(err, account) {\n *       if (err) {\n *         return res.status(err.status).json(err);\n *       }\n *\n *       var message = 'Hello, ' + account.username + '! Thanks for authenticating.';\n *\n *       if (authResult.grantedScopes) {\n *         message += ' You have been granted: ' + authResult.grantedScopes.join(' ');\n *       }\n *\n *       res.json({ message: message });\n *     });\n *   });\n * });\n *\n * @example\n *\n * // This is how you would implement the token endpoint in your application:\n * app.post('/oauth/token', function(req, res) {\n *   application.authenticateApiRequest({\n *     request: req,\n *     scopeFactory: function(account, requestedScopes, callback) {\n *       // Determine what scope to give, then provide the granted scope to the callback.\n *       callback(null, 'granted-scope');\n *     }\n *   }, function(err, authResult) {\n *     if (err) {\n *       res.status(err.status).json(err);\n *     } else {\n *       res.json(authResult.tokenResponse);\n *     }\n *   });\n * });\n */\nApplication.prototype.authenticateApiRequest = function authenticateApiRequest(options,callback) {\n  if(typeof options!=='object'){\n    throw new ApiAuthRequestError({userMessage: 'options must be an object' });\n  }\n\n  if(typeof options.request!=='object'){\n    throw new ApiAuthRequestError({userMessage: 'options.request must be an object' });\n  }\n\n  if(options.ttl && (typeof options.ttl!=='number')){\n    throw new ApiAuthRequestError({userMessage: 'ttl must be a number'});\n  }\n  var validAccessTokenRequestLocations = ['header','body','url'];\n  var defaultAccessTokenRequestLocations = ['header','body'];\n  var locationsToSearch;\n\n  if(Array.isArray(options.locations)){\n    locationsToSearch = options.locations.filter(function(location){\n      return validAccessTokenRequestLocations.indexOf(location) > -1;\n    });\n  }else{\n    locationsToSearch = defaultAccessTokenRequestLocations;\n  }\n\n  var ttl = options.ttl;\n\n  var req = options.request;\n\n  var scopeFactory = typeof options.scopeFactory === 'function' ? options.scopeFactory : null;\n\n  var parser = new AuthRequestParser(req,locationsToSearch);\n\n  var authHeaderValue = parser.authorizationValue;\n\n  var accessToken = parser.accessToken;\n\n  var grantType = parser.grantType;\n\n  if(grantType && grantType!=='client_credentials'){\n    return callback(new ApiAuthRequestError({userMessage: 'Unsupported grant_type'}));\n  }\n\n  var authenticator;\n\n  if(authHeaderValue){\n    if(authHeaderValue.match(/Basic/i)){\n      if(grantType){\n        authenticator = new OAuthBasicExchangeAuthenticator(\n          this,\n          req,\n          ttl,\n          scopeFactory,\n          parser.requestedScope\n        );\n      }else{\n        authenticator = new BasicApiAuthenticator(\n          this,\n          authHeaderValue,\n          ttl\n        );\n      }\n    }else if(authHeaderValue.match(/Bearer/i)){\n      authenticator = new OauthAccessTokenAuthenticator(\n        this,\n        authHeaderValue.replace(/Bearer /i,''),\n        ttl\n      );\n    }else{\n      return callback(new ApiAuthRequestError({userMessage: 'Invalid Authorization value', statusCode: 400}));\n    }\n  }else if(accessToken){\n    authenticator = new OauthAccessTokenAuthenticator(this, accessToken, ttl);\n  }\n\n  if(!authenticator){\n    return callback(new ApiAuthRequestError({userMessage: 'Must provide access_token.', statusCode: 401}));\n  }\n\n  if(authenticator instanceof Error){\n    return callback(authenticator);\n  }\n\n  authenticator.authenticate(callback);\n};\n\n/**\n * Retrieves the list of {@link ApplicationAccountStoreMapping Application\n * Account Store Mappings} for this application.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection. This collection\n * does not support attribute or filter searches.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link ApplicationAccountStoreMapping} objects.\n *\n * @example\n *\n * application.getAccountStoreMappings({ expand: 'accountStore' }, function(err, accountStoreMappings) {\n *   if (!err) {\n *     console.log(accountStoreMappings.items);\n *   }\n * });\n */\nApplication.prototype.getAccountStoreMappings = function getAccountStoreMappings(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accountStoreMappings.href, args.options, ApplicationAccountStoreMapping, args.callback);\n};\n\nApplication.prototype.getAuthToken = function getAccountStoreMappings(/* jwtAccessTokenString, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['jwtAccessTokenString', 'options', 'callback'], true);\n  return this.dataStore.getResource(this.href + '/authTokens/' + args. jwtAccessTokenString, args.options, InstanceResource, args.callback);\n};\n\n/**\n * Retrieves the {@link ApplicationAccountStoreMapping} that represents the link\n * to the Application's default Account Store, which is the {@link Directory}\n * that new accounts will be created in when using {@link\n * Application#createAccount Application.createAccount()}.\n *\n *  **Note**: This method is named incorrectly, it should be returning the {@link\n * Directory} resource (not the {@link ApplicationAccountStoreMapping}). This\n * will be fixed in version 1.0.0.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the account store during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link ApplicationAccountStoreMapping}).\n *\n * @example\n *\n * application.getDefaultAccountStore({ expand: 'accountStore' }, function(err, applicationAccountStoreMapping) {\n *   if (!err) {\n *     console.log(applicationAccountStoreMapping.accountStore.name);\n *   }\n * });\n */\nApplication.prototype.getDefaultAccountStore = function getDefaultAccountStore(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  if (!this.defaultAccountStoreMapping) {\n    return args.callback();\n  }\n\n  return this.dataStore.getResource(this.defaultAccountStoreMapping.href, args.options, ApplicationAccountStoreMapping, args.callback);\n};\n\n/**\n * Sets the default Account Store for this Application by setting the\n * `isDefaultAccountStore` property of the {@link AccountStoreMapping} that\n * represents the link between this application and the account store.  If this\n * mapping does not already exist it will be automatically created.\n *\n * @param {Directory|Group|Object} accountStore\n * The Account Store to set as the default Account Store for this application.\n * This can be a materialized {@link Directory}, {@link Group}, or object\n * literal with an `href` property that identifies the Account Store.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link ApplicationAccountStoreMapping}).\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * client.getDirectory(directoryHref, function(err, directory){\n *   application.setDefaultAcccountStore(directory, function (err) {\n *     if (!err) {\n *       console.log('Directory was set as default account store');\n *     }\n *   });\n * })\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * application.setDefaultAcccountStore({href: directoryHref}, function (err) {\n *   if (!err) {\n *     console.log('Directory was set as default account store');\n *   }\n * });\n *\n */\nApplication.prototype.setDefaultAccountStore = function setDefaultAccountStore(store, callback) {\n  var self = this;\n  store = 'string' === typeof store ? {href: store} : store;\n\n  this.getAccountStoreMappings(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    res.detectSeries(function(asm, cb){cb(asm.accountStore.href === store.href);}, onAsmFound);\n  });\n\n  function onAsmFound(asm) {\n    if (asm) {\n      asm.isDefaultAccountStore = true;\n      return asm.save(clearCache);\n    }\n\n    var mapping = new ApplicationAccountStoreMapping({ isDefaultAccountStore: true })\n      .setApplication(self)\n      .setAccountStore(store);\n\n    return self.dataStore.createResource('/accountStoreMappings', null, mapping, ApplicationAccountStoreMapping, clearCache);\n  }\n\n  function clearCache(err, map) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.dataStore._evict(self.href, function(err){\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, map);\n    });\n  }\n};\n\n/**\n * Retrieves the {@link ApplicationAccountStoreMapping} that represents the link\n * to the Application's default group store, which is the {@link Directory}\n * that new groups will be created in when using {@link Application#createGroup\n * Application.createGroup()}.\n *\n *  **Note**: This method is named incorrectly, it should be returning the {@link\n * Directory} resource (not the {@link ApplicationAccountStoreMapping}). This\n * will be fixed in version 1.0.0.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the account store during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link ApplicationAccountStoreMapping}).\n *\n * @example\n *\n * application.getDefaultGroupStore({ expand: 'accountStore' }, function(err, applicationAccountStoreMapping) {\n *   if (!err) {\n *     console.log(applicationAccountStoreMapping.accountStore.name);\n *   }\n * });\n */\nApplication.prototype.getDefaultGroupStore = function getDefaultGroupStore(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  if (!this.defaultGroupStoreMapping) {\n    return args.callback();\n  }\n\n  return this.dataStore.getResource(this.defaultGroupStoreMapping.href, args.options, ApplicationAccountStoreMapping, args.callback);\n};\n\n/**\n * Sets the default Group Store for this Application by setting the\n * `isDefaultGroupStore` property of the {@link AccountStoreMapping} that\n * represents the link between this application and the account store.  If this\n * mapping does not already exist it will be automatically created.\n *\n * @param {Directory|Object} directory\n * The {@link Directory} to set as the default group store for this application.\n * This can be a materialized {@link Directory}, or object literal with an\n * `href` property that identifies the {@link Directory}.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link ApplicationAccountStoreMapping}).\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * client.getDirectory(directoryHref, function(err, directory}{\n *   application.setDefaultGroupStore(directory, function (err, applicationAccountStoreMapping) {\n *     if (!err) {\n *       console.log('Directory was set as default group store');\n *     }\n *   });\n * })\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * application.setDefaultGroupStore({href: directoryHref}, function (err) {\n *   if (!err) {\n *     console.log('Directory was set as default group store');\n *   }\n * });\n *\n */\nApplication.prototype.setDefaultGroupStore = function setDefaultGroupStore(store, callback) {\n  var self = this;\n  store = 'string' === typeof store ? {href: store} : store;\n\n  this.getAccountStoreMappings(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    res.detectSeries(function(asm, cb){cb(asm.accountStore.href === store.href);}, onAsmFound);\n  });\n\n  function onAsmFound(asm) {\n    if (asm) {\n      asm.isDefaultGroupStore = true;\n      return asm.save(updateApp);\n    }\n\n    var mapping = new ApplicationAccountStoreMapping({ isDefaultGroupStore: true })\n      .setApplication(self)\n      .setAccountStore(store);\n\n    return self.dataStore.createResource('/accountStoreMappings', null, mapping, ApplicationAccountStoreMapping, updateApp);\n  }\n\n  function updateApp(err, map) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.dataStore._evict(self.href, function(err){\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, map);\n    });\n  }\n};\n\n/**\n * Creates a mapping between an Application and an Account Store, the Account\n * Store can be a {@link Directory}, {@link Group}, or {@link Organization}.\n *\n * @param {Object} accountStoreMapping\n *\n * @param {Directory|Group|Organization|Object} accountStoreMapping.accountStore\n * The Account Store to set as the default Account Store for this application.\n * This can be a materialized {@link Directory}, {@link Group}, {@link\n * Organization}, or object literal with an `href` property that identifies the\n * Account Store.\n *\n * @param {Boolean} [accountStoreMapping.isDefaultAccountStore=false] Set to\n * `true` if you want this account store to be the default store where new accounts\n * are placed when calling {@link Application#createAccount Application.createAccount()}.\n * If you need to change the default account store in the future, use\n * {@link Application#setDefaultAccountStore Application.setDefaultAccountStore()}\n *\n * @param {Boolean} [accountStoreMapping.isDefaultGroupStore=false] Set to\n * `true` if you want this account store to be the default location of groups when\n * calling {@link Application#createGroup Application.createGroup()}.\n * In this situation, the account store must be a {@link Directory}.  If you\n * need to change the default group store in the future, use\n * {@link Application#setDefaultGroupStore Application.setDefaultGroupStore()}\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link ApplicationAccountStoreMapping}).\n *\n * @example\n *\n * client.getDirectory(directoryHref, function(err, directory}{\n *   application.createAccountStoreMapping({ accountStore: directory }, function (err, applicationAccountStoreMapping) {\n *     if (!err) {\n *       console.log('Directory was mapped to the application.');\n *     }\n *   });\n * })\n *\n * @example\n *\n * var mapping = {\n *   accountStore: {\n *     href: 'https://api.stormpath.com/v1/directories/xxx'\n *   }\n * };\n *\n * application.createAccountStoreMapping(mapping, function (err, applicationAccountStoreMapping) {\n *   if (!err) {\n *     console.log('Directory was mapped to the application.');\n *   }\n * });\n *\n */\nApplication.prototype.createAccountStoreMapping = function createAccountStoreMapping(/* mapping, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['mapping', 'options', 'callback']);\n\n  args.mapping = new ApplicationAccountStoreMapping(args.mapping).setApplication(this);\n\n  return this.dataStore.createResource('/accountStoreMappings', args.options, args.mapping, ApplicationAccountStoreMapping, args.callback);\n};\n\n/**\n * Used to create multiple account store mappings at once.\n *\n * @param  {Object[]} mappings\n * An array of mapping definitions, the same that you would pass to {@link\n * Application#createAccountStoreMapping Application.createAccountStoreMapping()}.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, [{@link ApplicationAccountStoreMapping\n * ApplicationAccountStoreMappings}]).\n */\nApplication.prototype.createAccountStoreMappings = function createAccountStoreMappings(mappings,callback){\n  var self = this;\n  async.mapSeries(mappings,function(mapping,next){\n    self.createAccountStoreMapping(mapping,next);\n  },callback);\n};\n\n/*\n  @TODO - remove this in version 1.0, use createAccountStoreMapping() instead\n */\n\nApplication.prototype.addAccountStore = function addAccountStore(store, callback) {\n  var mapping = new ApplicationAccountStoreMapping().setAccountStore(store).setApplication(this);\n  return this.dataStore.createResource('/accountStoreMappings', null, mapping, ApplicationAccountStoreMapping, callback);\n};\n\n/**\n * Gets the {@link CustomData} object for this resource.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link CustomData}).\n */\nApplication.prototype.getCustomData = function getCustomData(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.customData.href, args.options, require('./CustomData'), args.callback);\n};\n\n/**\n* Retrieves the application's {@link AccountLinkingPolicy}, which determines if\n* and how accounts in its default account store are linked, so that {@link AccountLink}\n* instances are automatically created between two accounts that would match this policy.\n*\n* @param {ExpansionOptions} options\n* Options for expanding the account linking policy. Can be expanded on `tenant`.\n*\n* @param {Function} callback\n* The function that will be called when the query is finished, with the parameters\n* (err, {@link AccountLinkingPolicy}).\n*/\nApplication.prototype.getAccountLinkingPolicy = function getApplicationAccountLinkingPolicy(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.accountLinkingPolicy.href, args.options, require('./AccountLinkingPolicy'), args.callback);\n};\n\nmodule.exports = Application;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/PasswordResetToken.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class PasswordResetToken\n *\n * @description\n *\n * Encapsulates a PasswordResetToken resource. For full documentation of this\n * resource, please see\n * [REST API Reference: Password Reset Tokens](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#password-reset-tokens).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Application#sendPasswordResetEmail Application.sendPasswordResetEmail()}.\n *\n * To revoke a password reset token, call `delete()` on an instance of this class.\n *\n * @param {Object} passwordResetTokenResource\n *\n * The JSON representation of this resource.\n *\n */\nfunction PasswordResetToken() {\n  PasswordResetToken.super_.apply(this, arguments);\n}\nutils.inherits(PasswordResetToken, InstanceResource);\n\nmodule.exports = PasswordResetToken;\n\n/**\n * @method PasswordResetToken.delete\n *\n * @description\n *\n * Deletes this resource from the API.\n *\n * @param {Function} callback\n * The function to call when the delete operation is complete. Will be called\n * with the parameter (err).\n */\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Challenge.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar FactorCtor = require('./FactorInstantiator').Constructor;\nvar utils = require('../utils');\n\n/**\n * @class Challenge\n *\n * @description\n *\n * Encapsulates a Challenge resource. For full documentation of this resource,\n * please see\n * [REST API Reference: Challenge](https://docs.stormpath.com/rest/product-guide/latest/reference.html#challenge).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Client#getChallenge Client.getChallenge()}\n * - {@link SmsFactor#createChallenge SmsFactor.createChallenge()}\n * - {@link GoogleAuthenticatorFactor#createChallenge GoogleAuthenticatorFactor.createChallenge()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} challengeResource\n *\n * The JSON representation of this resource.\n */\nfunction Challenge() {\n  Challenge.super_.apply(this, arguments);\n}\n\nutils.inherits(Challenge, InstanceResource);\n\n/**\n * Retrieves the factor instance ({@link SmsFactor} or {@link GoogleAuthenticatorFactor})\n * that this challenge is linked to.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Factor} for this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link SmsFactor}) or (err, {@link GoogleAuthenticatorFactor}),\n * depending on the type of the returned resource.\n*/\nChallenge.prototype.getFactor = function getFactor(/* [options], cb */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.factor.href, args.options, FactorCtor, args.callback);\n};\n\n/**\n* Retrieves the {@link Account} this challenge belongs to.\n*\n* @param {ExpansionOptions} [expansionOptions]\n* For retrieving linked resources of the {@link Account} for this request.\n* This resource supports expansions for `customData`, `tenant`, `directory`,\n* `groups`, and `groupMemberships`. Groups and group memberships can also be\n* expanded and paginated.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called with\n* (err, {@link Account}).\n*/\n\nChallenge.prototype.getAccount = function getAccount(/* [options], cb */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.account.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n * This method verifies the challenge by posting the challenge code to the challenge\n * resource. If the posted code is correct, the callback will return the same\n * challenge resource, but the `STATUS` property will now be `SUCCESS`.  If the\n * code is incorrect, the status will be `FAILED`.  If the challenge has expired,\n * an error will be returned.\n *\n * @param {String} code\n *\n * The code to post to the challenge. If the challenge is for a `google-authenticator`\n * factor, the code is from the user's Google Authenticator application. If the\n * challenge is for an `SMS` factor, the code is the one that was sent to the\n * user's phone number when the challenge was created\n *\n * @param {Object} [requestOptions]\n * Query parameters for this request. These can be any of the {@link ExpansionOptions},\n * e.g. to retrieve linked resources of the {@link Challenge} during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with\n * (err, {@link Challenge}).\n *\n * @example\n * challenge.verifyCode('815331', function(err, updatedChallenge){\n *   if (err) {\n *     // The challenge has expired or has already been verified\n *     return console.log(err);\n *   }\n *\n *   if (updatedChallenge.status === 'FAILED') {\n *     return console.log('Incorrect code, please try again.');\n *   }\n *\n *   console.log(updatedChallenge.status); // SUCCESS\n * });\n*/\n\nChallenge.prototype.verifyCode = function verifyCode(/* code, [options], callback */) {\n  var args = utils.resolveArgs(arguments, ['code', 'options', 'callback']);\n\n  return this.dataStore.createResource(this.href, args.options, {code: args.code}, Challenge, args.callback);\n};\n\nmodule.exports = Challenge;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Directory.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class Directory\n *\n * @description\n * Encapsulates a Directory resource. For full documentation of this resource, please see\n * [REST API Reference: Directory](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#directory).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Account#getDirectory Account.getDirectory()}\n * - {@link AccountStoreMapping#getAccountStore AccountStoreMapping.getAccountStore()}\n * - {@link Client#getDirectory Client.getDirectory()}\n * - {@link Client#getDirectories Client.getDirectories()}\n * - {@link Group#getDirectory Group.getDirectory()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} directoryResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction Directory() {\n  Directory.super_.apply(this, arguments);\n}\n\nutils.inherits(Directory, InstanceResource);\n\n/**\n * Get the account's collection, which is a list of all the accounts in this\n * Directory.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `createdAt`, `email`, `givenName`, `middleName`, `modifiedAt`, `surname`,\n * `status`, `username`.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Account} objects.\n *\n * @example\n * var query = {\n *   email: 'foo@example.com'\n * };\n *\n * directory.getAccounts(query, function(err, collection) {\n *   collection.each(function(account, next) {\n *     console.log('Found account for ' + account.givenName + ' (' + account.email + ')');\n *     next();\n *   });\n * });\n */\nDirectory.prototype.getAccounts = function getDirectoryAccounts(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accounts.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n * Get the {@link AccountCreationPolicy} resource of this Directory resource.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link AccountCreationPolicy} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link AccountCreationPolicy}).\n */\nDirectory.prototype.getAccountCreationPolicy = function getAccountCreationPolicy(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accountCreationPolicy.href, args.options, require('./InstanceResource'), args.callback);\n};\n\n/**\n * Get the {@link Schema} resource of this Directory resource. The schema allows\n * you to control which attributes are required when accounts are created in this\n * directory.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Schema} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Schema}).\n */\nDirectory.prototype.getAccountSchema = function getAccountSchema(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accountSchema.href, args.options, require('./Schema'), args.callback);\n};\n\n/**\n * Get the {@link PasswordPolicy} resource of this Directory resource.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link PasswordPolicy} during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link PasswordPolicy}).\n */\nDirectory.prototype.getPasswordPolicy = function getPasswordPolicy(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.passwordPolicy.href, args.options, require('./PasswordPolicy'), args.callback);\n};\n\n/**\n * Creates an {@link Account} in this directory.\n *\n * @param {AccountData} accountData\n * The data for the new account object.\n *\n * @param {Object} [requestOptions]\n * Query parameters for this request.  These  can be any of the {@link ExpansionOptions},\n * e.g. to retrieve linked resources of the {@link Account} during this request, or one\n * of the other options listed below.\n *\n * @param {Boolean} [requestOptions.registrationWorkflowEnabled=null]\n * Set this to `false` if you need to disable the email verification workflow while\n * creating this account.  This is typically used when importing accounts from\n * another system.\n *\n * @param {Function} callback - Callback function, will be called with (err,\n * {@link Account}).\n *\n * @example\n * var account = {\n *   givenName: 'Foo',\n *   surname: 'Bar',\n *   username: 'foolmeonce',\n *   email: 'foo@example.com',\n *   password: 'Changeme1!'\n * };\n *\n * directory.createAccount(account, function (err, createdAccount) {\n *   console.log(createdAccount);\n * });\n */\nDirectory.prototype.createAccount = function createDirectoryAccount(/* account, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['account', 'options', 'callback']);\n  return this.dataStore.createResource(this.accounts.href, args.options, args.account, require('./Account'), args.callback);\n};\n\n/**\n * Retrieves a list of all the groups that are in this directory.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Group} objects.\n *\n * @example\n * directory.getGroups(function (err, groupsCollection) {\n *   groupsCollection.each(function(group, next) {\n *     console.log(group.name);\n *     next();\n *   });\n * });\n */\nDirectory.prototype.getGroups = function getDirectoryGroups(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.groups.href, args.options, require('./Group'), args.callback);\n};\n\n/**\n * Creates a {@link Group} in this directory.\n *\n * @param {Object} groupData\n * The new group data.\n *\n * @param {String} [groupData.description]\n * A description of this group.\n *\n * @param {String} groupData.name\n * The name of the group.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Group}).\n *\n * @example\n * var newGroup = {\n *   name: 'Customers',\n *   description: 'Users who have registered through the e-commerce site.'\n * };\n *\n * directory.createGroup(newGroup, function (err, group) {\n *   console.log(group.href);\n * });\n */\nDirectory.prototype.createGroup = function createDirectoryGroup(/* group, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['group', 'options', 'callback']);\n  return this.dataStore.createResource(this.groups.href, args.options, args.group, require('./Group'), args.callback);\n};\n\n/**\n * Get the {@link Tenant} resource that owns this directory.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Tenant} resources during\n * this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Tenant}).\n */\nDirectory.prototype.getTenant = function getDirectoryTenant(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.tenant.href, args.options, require('./Tenant'), args.callback);\n};\n\n/**\n * Get the {@link Provider} resource of this directory, this resource tells you\n * what type of directory this is.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link Provider}|{@link SamlProvider}).\n */\nDirectory.prototype.getProvider = function getProvider(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  if (!this.provider){\n    return args.callback();\n  }\n\n  function providerFactory(provider, dataStore) {\n    var providerName = 'Provider';\n\n    if (provider.providerId === 'saml') {\n      providerName = 'SamlProvider';\n    }\n\n    var ProviderType = require('./' + providerName);\n\n    return new ProviderType(provider, dataStore);\n  }\n\n  return this.dataStore.getResource(this.provider.href, args.options, providerFactory, args.callback);\n};\n\n/**\n * Retrieves a list of all the {@link Organization Organizations} that this\n * directory is mapped to.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Organization} objects.\n *\n * @example\n * directory.getOrganizations(function (err, organizationsCollection) {\n *   organizationsCollection.each(function(organization, next) {\n *     console.log(organization.name);\n *     next();\n *   });\n * });\n */\nDirectory.prototype.getOrganizations = function getOrganizations(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.organizations.href, args.options, require('./Organization'), args.callback);\n};\n\n/**\n * Retrieves a list of all the {@link OrganizationAccountStoreMapping\n * OrganizationAccountStoreMappings}, that represent the mappings between this\n * directory and the specified {@link Organization Organizations}.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when then the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link OrganizationAccountStoreMapping} objects.\n *\n * @example\n * directory.getOrganizationMappings(function (err, organizationMappingsCollection) {\n *   organizationMappingsCollection.each(function(mapping, next) {\n *     console.log(mapping.href);\n *     next();\n *   });\n * });\n */\nDirectory.prototype.getOrganizationMappings = function getOrganizationMappings(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.organizationMappings.href, args.options, require('./OrganizationAccountStoreMapping'), args.callback);\n};\n\n/**\n * Gets the {@link CustomData} object for this resource.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link CustomData}).\n */\nDirectory.prototype.getCustomData = function getCustomData(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.customData.href, args.options, require('./CustomData'), args.callback);\n};\n\nmodule.exports = Directory;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Field.js":"'use strict';\n\nvar Resource = require('./Resource');\nvar utils = require('../utils');\n\n/**\n * @class Field\n *\n * @description\n * Encapsulates an account field, as part of a {@link Schema}.\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n *\n * - {@link Schema#getFields Schema.getFields()}.\n */\nfunction Field(){\n  Field.super_.apply(this, arguments);\n}\n\nutils.inherits(Field, Resource);\n\n/**\n * Save changes to this resource.\n *\n * @param {Function} callback\n * The function to call when the save operation is complete. Will be called\n * with the parameters (err, updatedResource).\n */\nField.prototype.save = function save(callback) {\n  this.dataStore.saveResource(this, callback);\n};\n\nmodule.exports = Field;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Group.js":"'use strict';\n\nvar DirectoryChildResource = require('./DirectoryChildResource');\nvar utils = require('../utils');\n\n/**\n * @class Group\n *\n * @description\n * Encapsulates a Group resource. For full documentation of this resource, please see\n * [REST API Reference: Group](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#group).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Client#getGroup Client.getGroup()}\n * - {@link GroupMembership#getGroup GroupMembership.getGroup()}\n *\n * @augments {InstanceResource}\n *\n * @augments {DirectoryChildResource}\n *\n * @param {Object} groupResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction Group() {\n  Group.super_.apply(this, arguments);\n}\n\nutils.inherits(Group, DirectoryChildResource);\n\n/**\n * Add an account to this group. This will create a {@link GroupMembership} for\n * the account.\n *\n * @param {Account|Object} account An existing instance of {@link Account}, or\n * an object literal with an `href` property that identifies the account to add.\n *\n * @param {Function} callback - Callback function, will be called with (err,\n * {@link GroupMembership}).\n */\nGroup.prototype.addAccount = function addGroupAccount(/* accountOrAccountHref, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['account', 'options', 'callback']);\n\n  if (typeof args.account === 'string') {\n    args.account = {\n      href: args.account\n    };\n  }\n\n  return this._createGroupMembership(args.account, this, args.options, args.callback);\n};\n\n/**\n * Get the account's collection, which is a list of all the accounts in this\n * Group.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `createdAt`, `email`, `givenName`, `middleName`, `modifiedAt`, `surname`,\n * `status`, `username`.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Account} objects.\n *\n * @example\n * var query = {\n *   email: 'foo@example.com'\n * };\n *\n * group.getAccounts(query, function (err, collection) {\n *   collection.each(function (account, next) {\n *     console.log('Found account for ' + account.givenName + ' (' + account.email + ')');\n *     next();\n *   });\n * });\n */\nGroup.prototype.getAccounts = function getGroupAccounts(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accounts.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n * Retrieves the list of {@link GroupMembership GroupMemberships} for this group.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection. This collection\n * does not support attribute or filter searches.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link GroupMembership} objects.\n *\n * @example\n * group.getAccountMemberships({ expand: 'account' }, function (err, memberships) {\n *   memberships.each(function (membership, next) {\n *     console.log(membership.account.fullName + ' is in this group');\n *     next();\n *   });\n * });\n */\nGroup.prototype.getAccountMemberships = function getGroupAccountMemberships(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accountMemberships.href, args.options, require('./GroupMembership'), args.callback);\n};\n\nmodule.exports = Group;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/GroupMembership.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class GroupMembership\n *\n * @description\n * Encapsulates a GroupMembership resource. For full documentation of this resource, please see\n * [REST API Reference: Group Membership](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#group-membership).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Account#getGroupMemberships Account.getGroupMemberships()}\n *\n * To remove the group membership, call the `delete()` method on an instance of this class.\n *\n * @augments {InstanceResource}\n *\n * @param {Object} groupMembershipResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction GroupMembership() {\n  GroupMembership.super_.apply(this, arguments);\n}\nutils.inherits(GroupMembership, InstanceResource);\n\n/**\n * Retrieves the {@link Account account} resource of this membership.\n *\n * @param {ExpansionOptions} [options]\n * For retrieving linked resources of the {@link Account} during this request.\n *\n * @param {Function} Callback\n * Callback function, will be called with (err, {@link Account account}).\n */\nGroupMembership.prototype.getAccount = function getGroupMembershipAccount(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.account.href, args.options, require('./Account'), args.callback);\n};\n\n/**\n * Retrieves the {@link Group group} resource of this membership.\n *\n * @param {ExpansionOptions} [options]\n * For retrieving linked resources of the {@link Group group} during this request.\n *\n * @param {Function} Callback\n * Callback function, will be called with (err, {@link Group group}).\n */\nGroupMembership.prototype.getGroup = function getGroupMembershipGroup(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.group.href, args.options, require('./Group'), args.callback);\n};\n\nmodule.exports = GroupMembership;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/IdSiteModel.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class IdSiteModel\n *\n * @description\n * Encapsulates a IdSiteModel resource. For full documentation of this resource, please see\n * [REST API Reference: ID Site](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#id-site).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Organization#getIdSiteModel Organization.getIdSiteModel()}\n * - {@link Tenant#getIdSites Tenant.getIdSites()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} idSiteModelResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction IdSiteModel() {\n  IdSiteModel.super_.apply(this, arguments);\n}\n\nutils.inherits(IdSiteModel, InstanceResource);\n\nmodule.exports = IdSiteModel;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/OAuthPolicy.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class OAuthPolicy\n *\n * @description\n *\n * Encapsulates a OAuth Policy resource of an {@link Application}. For full\n * documentation of this resource please see\n * [REST API Reference: OAuth Policy](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#oauth-policy).\n *\n * For a high level overview of this feature, please see\n * [How Token-Based Authentication Works](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html#how-token-based-authentication-works).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Application#getOAuthPolicy Application.getOAuthPolicy()}\n *\n * @param {Object} oAuthPolicyResource\n *\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n *\n */\nfunction OAuthPolicy() {\n  OAuthPolicy.super_.apply(this, arguments);\n}\n\nutils.inherits(OAuthPolicy, InstanceResource);\n\nmodule.exports = OAuthPolicy;\n\n\n/**\n * @method OAuthPolicy.save\n *\n * @description\n *\n * Save changes to this resource.\n *\n * @param {Function} callback\n * The function to call when the save operation is complete. Will be called\n * with the parameters (err, updatedResource).\n */","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/OrganizationAccountStoreMapping.js":"'use strict';\n\nvar utils = require('../utils');\nvar AccountStoreMapping = require('./AccountStoreMapping');\n\n/**\n * @class\n *\n * @augments {AccountStoreMapping}\n *\n * @description\n *\n * Encapsulates an Organization Account Store Mapping, which represents the link\n * between an {@link Organization} and a {@link Directory} or {@link Group}. For\n * full documentation of this resource, please see\n * [REST API Reference: Account Store Mapping](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#account-store-mapping).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Directory#getOrganizationMappings Directory.getOrganizationMappings()}.\n * - {@link Organization#getAccountStoreMappings Organization.getAccountStoreMappings()}.\n *\n * @param {object} accountStoreMappingResource\n *\n * The JSON representation of this resource.\n *\n */\nfunction OrganizationAccountStoreMapping() {\n  OrganizationAccountStoreMapping.super_.apply(this, arguments);\n}\n\nutils.inherits(OrganizationAccountStoreMapping, AccountStoreMapping);\n\n/**\n * @description\n *\n * Gets the {@link Organization} that is associated with this account store mapping.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Organization} during this request.\n *\n * @param {Function} callback\n * The callback to call when the operation is complete. Will be called with\n * (err, {@link Organization}).\n */\nOrganizationAccountStoreMapping.prototype.getOrganization = function getOrganization(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.organization.href, args.options, require('./Organization'), args.callback);\n};\n\n/**\n * This is not necessary, organization can be passed to createAccountStoreMapping().  Remove in 1.0\n *\n * @private\n */\nOrganizationAccountStoreMapping.prototype.setOrganization = function setOrganization(organization) {\n  this.organization = { href: organization.href };\n  return this;\n};\n\nmodule.exports = OrganizationAccountStoreMapping;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Organization.js":"'use strict';\n\nvar async = require('async');\nvar utils = require('../utils');\n\nvar Account = require('./Account');\nvar Application = require('./Application');\nvar CustomData = require('./CustomData');\nvar IdSiteModel = require('./IdSiteModel');\nvar OrganizationAccountStoreMapping = require('./OrganizationAccountStoreMapping');\n\n/**\n * @class Organization\n *\n * @description\n *\n * Encapsulates a Organization resource. For full documentation of this resource,\n * please see\n * [REST API Reference: Organization](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#organization).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link AccountStoreMapping#getAccountStore AccountStoreMapping.getAccountStore()}\n * - {@link Client#getOrganization Client.getOrganization()}\n * - {@link Client#getOrganizations Client.getOrganizations()}\n * - {@link Directory#getOrganizations Directory.getOrganizations()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} organizationResource\n *\n * The JSON representation of this resource.\n *\n */\nfunction Organization() {\n  Organization.super_.apply(this, arguments);\n}\n\nutils.inherits(Organization, require('./InstanceResource'));\n\n/**\n * Creates an {@link Account} in the organization's default account store.\n *\n * @param {AccountData} accountData\n * The data for the new account object.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Account} during this request.\n *\n * @param {Function} callback - Callback function, will be called with (err,\n * {@link Account}).\n *\n * @example\n *\n * var account = {\n *   givenName: 'Foo',\n *   surname: 'Bar',\n *   username: 'foolmeonce',\n *   email: 'foo@example.com',\n *   password: 'Changeme1!'\n * };\n *\n * organization.createAccount(account, function(err, createdAccount) {\n *   console.log(createdAccount);\n * });\n */\nOrganization.prototype.createAccount = function createAccount(/* account, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['account', 'options', 'callback']);\n  return this.dataStore.createResource(this.accounts.href, args.options, args.account, Account, args.callback);\n};\n\n/**\n * Creates a group within the default group store of the Organization. If the\n * organization does not have a default group store, this will error.\n *\n * @param {Group} group\n * New group definition.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, {@link Group}).\n *\n * @example\n *\n * var group = {\n *   name: 'New Users'\n * };\n *\n * organization.createGroup(group, function (err, group) {\n *   if (!err) {\n *     console.log('Group Created!');\n *   }\n * });\n */\nOrganization.prototype.createGroup = function createGroup(/* group, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['group', 'options', 'callback']);\n  return this.dataStore.createResource(this.groups.href, args.options, args.group, require('./Group'), args.callback);\n};\n\n/**\n * Use this method to get an account from a provider directory. This method is\n * the same as {@link Application#getAccount Application.getAccount()} but\n * will be scoped to the account stores that are mapped to this Organization.\n *\n * @param {Object} providerAccountRequest\n * See {@link Application#getAccount Application.getAccount()}.\n *\n * @param {Function} callback\n * Callback function to call with parameters (`err`, {@link ProviderAccountResult}).\n *\n * @example\n *\n * var providerAccountRequest = {\n *   providerData: {\n *     providerId: 'facebook',\n *     accessToken: 'abc1235'\n *   }\n * };\n *\n * organization.getAccount(providerAccountRequest, function(err, providerAccountResult) {\n *   if (providerAccountResult.created) {\n *     console.log('This user was newly created in the directory.');\n *   }\n *\n *   console.log(providerAccountResult.account);\n * });\n */\nOrganization.prototype.getAccount = function () {\n  Application.prototype.getAccount.apply(this, arguments);\n};\n\n/**\n * Get the account's collection for this Organization, which is a list of all\n * accounts in all account stores that are mapped to this organization.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `createdAt`, `email`, `givenName`, `middleName`, `modifiedAt`, `surname`,\n * `status`, `username`.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Account} objects.\n *\n * @example\n *\n * var query = {\n *   givenName: 'foo'\n * };\n *\n * organization.getAccounts(query, function(err, collection) {\n *   collection.each(function(account, next) {\n *     console.log('Found account for ' + account.givenName + ' (' + account.email + ')');\n *     next();\n *   });\n * });\n */\nOrganization.prototype.getAccounts = function getAccounts(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accounts.href, args.options, Account, args.callback);\n};\n\n/**\n * Gets the {@link CustomData} object for this resource.\n *\n * @param {Function} callback\n * The callback that will be called with the parameters (err, {@link CustomData}).\n */\nOrganization.prototype.getCustomData = function getCustomData(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.customData.href, args.options, CustomData, args.callback);\n};\n\n/**\n * Retrieves the default {@link OrganizationAccountStoreMapping} for this\n * Organization, which represents the link to the default {@link Directory} or\n * {@link Group} for newly created accounts when  calling {@link Organization#createAccount\n * Organization.createAccount()}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For expanding the account store resource during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link OrganizationAccountStoreMapping}).\n *\n * @example\n *\n * organization.getDefaultAccountStoreMapping({ expand: 'accountStore' }, function(err, organizationAccountStoreMapping) {\n *   if (!err) {\n *     // Print the name of the default account store\n *     console.log(organizationAccountStoreMapping.accountStore.name);\n *   }\n * });\n */\nOrganization.prototype.getDefaultAccountStoreMapping = function getDefaultAccountStoreMapping(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  if (!this.defaultAccountStoreMapping) {\n    return args.callback();\n  }\n\n  return this.dataStore.getResource(this.defaultAccountStoreMapping.href, args.options, OrganizationAccountStoreMapping, args.callback);\n};\n\n/**\n * Retrieves the default {@link OrganizationAccountStoreMapping} for this\n * Organization, which represents the link to the default  {@link Group} for\n * newly created groups when calling {@link Organization#createGroup\n * Organization.createGroup()}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For expanding the account store resource during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link OrganizationAccountStoreMapping}).\n *\n * @example\n *\n * organization.getDefaultGroupStoreMapping({ expand: 'accountStore' }, function(err, organizationAccountStoreMapping) {\n *   if (!err) {\n *     // Print the name of the default group store\n *     console.log(organizationAccountStoreMapping.accountStore.name);\n *   }\n * });\n */\nOrganization.prototype.getDefaultGroupStoreMapping = function getDefaultGroupStoreMapping(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  if (!this.defaultGroupStoreMapping) {\n    return args.callback();\n  }\n\n  return this.dataStore.getResource(this.defaultGroupStoreMapping.href, args.options, OrganizationAccountStoreMapping, args.callback);\n};\n\n/**\n * Retrieves the default account store for this Organization, which is the\n * {@link Directory} or {@link Group} that new accounts will be created in when\n * calling {@link Organization#createAccount Organization.createAccount()}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the account store during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link Directory}|{@link Group}).\n *\n * @example\n *\n * organization.getDefaultAccountStore(function(err, accountStore) {\n *   if (!err) {\n *     // Print the name of the default account store\n *     console.log(accountStore.name);\n *   }\n * });\n */\nOrganization.prototype.getDefaultAccountStore = function getDefaultAccountStore(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.getDefaultAccountStoreMapping({ expand: 'accountStore' }, function (err, organizationAccountStoreMapping) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    if (!organizationAccountStoreMapping) {\n      return args.callback(null, null);\n    }\n\n    organizationAccountStoreMapping.getAccountStore(args.options, args.callback);\n  });\n};\n\n/**\n * Retrieves the default group store for this Organization, which is the\n * {@link Group} that new groups will be created in when calling\n * {@link Organization#createGroup Organization.createGroup()}.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the account store during this request.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link Group}).\n *\n * @example\n *\n * organization.getDefaultGroupStore(function(err, accountStore) {\n *   if (!err) {\n *     // Print the name of the default group store\n *     console.log(accountStore.name);\n *   }\n * });\n */\nOrganization.prototype.getDefaultGroupStore = function getDefaultGroupStore(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.getDefaultGroupStoreMapping({ expand: 'accountStore' }, function (err, organizationAccountStoreMapping) {\n    if (err) {\n      return args.callback(err);\n    }\n\n    if (!organizationAccountStoreMapping) {\n      return args.callback(null, null);\n    }\n\n    organizationAccountStoreMapping.getAccountStore(args.options, args.callback);\n  });\n};\n\n/**\n * Get the groups collection for this Organization, which is a list of all\n * groups that are directly mapped to the organization, and all groups that\n * exist in a directory that is mapped to the organization.\n *\n * @param {CollectionQueryOptions} collectionQueryOptions\n * Options for querying, paginating, and expanding the collection. This collection\n * supports filter searches and the following attribute searches:\n * `name`, `description`, `status`.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Group} objects.\n *\n * @example\n *\n * var query = {\n *   name: 'admins'\n * };\n *\n * organization.getGroups(query, function(err, collection) {\n *   if (collection && collection.items.length === 1) {\n *     console.log('Found the admins group, href is: ' + group.href);\n *   }\n * });\n */\nOrganization.prototype.getGroups = function getGroups(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.groups.href, args.options, require('./Group'), args.callback);\n};\n\n/**\n * Not yet documented, as this is not yet unique to the organization, this is\n * internally bound to the application.\n *\n * @private\n */\nOrganization.prototype.getIdSiteModel = function getIdSiteModel(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.idSiteModel.href, args.options, IdSiteModel, args.callback);\n};\n\n/**\n * Retrieves the list of {@link OrganizationAccountStoreMapping Organization\n * Account Store Mappings} for this organization.\n *\n * @param {CollectionQueryOptions} [collectionQueryOptions]\n * Options for querying, paginating, and expanding the collection. This collection\n * does not support attribute or filter searches.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link OrganizationAccountStoreMapping} objects.\n *\n * @example\n *\n * organization.getAccountStoreMappings({ expand: 'accountStore' }, function(err, accountStoreMappings) {\n *   if (!err) {\n *     console.log(accountStoreMappings.items);\n *   }\n * });\n */\nOrganization.prototype.getAccountStoreMappings = function getAccountStoreMappings(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.accountStoreMappings.href, args.options, OrganizationAccountStoreMapping, args.callback);\n};\n\n/**\n * Creates a mapping between this Organization and an Account Store, the Account\n * Store can be a {@link Directory} or {@link Group}.\n *\n * @param {Object} accountStoreMapping\n *\n * @param {Directory|Group|Object} accountStoreMapping.accountStore\n * The Account Store to set as the default Account Store for this organization.\n * This can be a materialized {@link Directory}, {@link Group}, or object\n * literal with an `href` property that identifies the Account Store.\n *\n * @param {Boolean} [accountStoreMapping.isDefaultAccountStore=false] Set to\n * `true` if you want this account store to be the default store where new accounts\n * are placed when calling {@link Organization#createAccount Organization.createAccount()}.\n * If you need to change the default account store in the future, use\n * {@link Organization#setDefaultAccountStore Organization.setDefaultAccountStore()}\n *\n * @param {Boolean} [accountStoreMapping.isDefaultGroupStore=false] Set to\n * `true` if you want this account store to be the default location of groups when\n * calling {@link Organization#createGroup Organization.createGroup()}.\n * In this situation, the account store must be a {@link Directory}.  If you\n * need to change the default group store in the future, use\n * {@link Organization#setDefaultGroupStore Organization.setDefaultGroupStore()}\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link OrganizationAccountStoreMapping}).\n *\n * @example\n *\n * client.getDirectory(directoryHref, function(err, directory}{\n *   organization.createAccountStoreMapping({ accountStore: directory }, function (err, organizationAccountStoreMapping) {\n *     if (!err) {\n *       console.log('Directory was mapped to the organization.');\n *     }\n *   });\n * })\n *\n * @example\n *\n * var mapping = {\n *   accountStore: {\n *     href: 'https://api.stormpath.com/v1/directories/xxx'\n *   }\n * };\n *\n * organization.createAccountStoreMapping(mapping, function (err, organizationAccountStoreMapping) {\n *   if (!err) {\n *     console.log('Directory was mapped to the organization.');\n *   }\n * });\n *\n */\nOrganization.prototype.createAccountStoreMapping = function createAccountStoreMapping(/* mapping, [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['mapping', 'options', 'callback']);\n\n  args.mapping = new OrganizationAccountStoreMapping(args.mapping).setOrganization(this);\n\n  return this.dataStore.createResource('/organizationAccountStoreMappings', args.options, args.mapping, OrganizationAccountStoreMapping, args.callback);\n};\n\n/**\n * Used to create multiple account store mappings at once.\n *\n * @param  {Object[]} mappings\n * An array of mapping definitions, the same that you would pass to {@link\n * Organization#createAccountStoreMapping Organization.createAccountStoreMapping()}.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called with the\n * parameters (err, [{@link OrganizationAccountStoreMapping\n * OrganizationAccountStoreMappings}]).\n */\nOrganization.prototype.createAccountStoreMappings = function createAccountStoreMappings(mappings, callback) {\n  async.mapSeries(mappings, function(mapping, next) {\n    this.createAccountStoreMapping(mapping, next);\n  }.bind(this), callback);\n};\n\n/**\n * Sets the default Account Store for this Organization by setting the\n * `isDefaultAccountStore` property of the {@link OrganizationAccountStoreMapping} that\n * represents the link between this Organization and the account store.  If this\n * mapping does not already exist it will be automatically created.\n *\n * @param {Directory|Group|Object} accountStore\n * The Account Store to set as the default Account Store for this organization.\n * This can be a materialized {@link Directory}, {@link Group}, or object\n * literal with an `href` property that identifies the Account Store.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link OrganizationAccountStoreMapping}).\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * client.getDirectory(directoryHref, function(err, directory){\n *   organization.setDefaultAcccountStore(directory, function (err) {\n *     if (!err) {\n *       console.log('Directory was set as default account store');\n *     }\n *   });\n * })\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * organization.setDefaultAcccountStore({href: directoryHref}, function (err) {\n *   if (!err) {\n *     console.log('Directory was set as default account store');\n *   }\n * });\n *\n */\nOrganization.prototype.setDefaultAccountStore = function setDefaultAccountStore(store, callback) {\n  var self = this;\n  store = 'string' === typeof store ? {href: store} : store;\n\n  this.getAccountStoreMappings(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    res.detectSeries(function(asm, cb){cb(asm.accountStore.href === store.href);}, onAsmFound);\n  });\n\n  function onAsmFound(asm) {\n    if (asm) {\n      asm.isDefaultAccountStore = true;\n      return asm.save(clearCache);\n    }\n\n    var mapping = new OrganizationAccountStoreMapping({ isDefaultAccountStore: true })\n      .setOrganization(self)\n      .setAccountStore(store);\n\n    return self.dataStore.createResource('/accountStoreMappings', null, mapping, OrganizationAccountStoreMapping, clearCache);\n  }\n\n  function clearCache(err, map) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.dataStore._evict(self.href, function(err){\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, map);\n    });\n  }\n};\n\n/**\n * Sets the default Group Store for this Organization by setting the\n * `isDefaultGroupStore` property of the {@link AccountStoreMapping} that\n * represents the link between this organization and the account store.  If this\n * mapping does not already exist it will be automatically created.\n *\n * @param {Directory|Object} directory\n * The {@link Directory} to set as the default group store for this organization.\n * This can be a materialized {@link Directory}, or object literal with an\n * `href` property that identifies the {@link Directory}.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link OrganizationAccountStoreMapping}).\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * client.getDirectory(directoryHref, function(err, directory}{\n *   organization.setDefaultGroupStore(directory, function (err, organizationAccountStoreMapping) {\n *     if (!err) {\n *       console.log('Directory was set as default group store');\n *     }\n *   });\n * })\n *\n * @example\n *\n * var directoryHref; // The HREF of an existing directory.\n *\n * organization.setDefaultGroupStore({href: directoryHref}, function (err) {\n *   if (!err) {\n *     console.log('Directory was set as default group store');\n *   }\n * });\n *\n */\nOrganization.prototype.setDefaultGroupStore = function setDefaultGroupStore(store, callback) {\n  var self = this;\n  store = 'string' === typeof store ? {href: store} : store;\n\n  this.getAccountStoreMappings(function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    res.detectSeries(function(asm, cb){cb(asm.accountStore.href === store.href);}, onAsmFound);\n  });\n\n  function onAsmFound(asm) {\n    if (asm) {\n      asm.isDefaultGroupStore = true;\n      return asm.save(updateApp);\n    }\n\n    var mapping = new OrganizationAccountStoreMapping({ isDefaultGroupStore: true })\n      .setOrganization(self)\n      .setAccountStore(store);\n\n    return self.dataStore.createResource('/accountStoreMappings', null, mapping, OrganizationAccountStoreMapping, updateApp);\n  }\n\n  function updateApp(err, map) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.dataStore._evict(self.href, function(err){\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, map);\n    });\n  }\n};\n\n/**\n* Retrieves the organization's {@link AccountLinkingPolicy}, which determines if\n* and how accounts in its default account store are linked, so that {@link AccountLink}\n* instances are automatically created between two accounts that would match this policy.\n*\n* @param {ExpansionOptions} options\n* Options for expanding the account linking policy. Can be expanded on `tenant`.\n*\n* @param {Function} callback\n* The function that will be called when the query is finished, with the parameters\n* (err, {@link AccountLinkingPolicy}).\n*/\nOrganization.prototype.getAccountLinkingPolicy = function getOrganizationAccountLinkingPolicy(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n\n  return this.dataStore.getResource(this.accountLinkingPolicy.href, args.options, require('./AccountLinkingPolicy'), args.callback);\n};\n\nmodule.exports = Organization;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/PasswordPolicy.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class PasswordPolicy\n *\n * @description\n * Encapsulates a PasswordPolicy resource of a {@link Directory}. For full documentation of this resource, please see\n * [REST API Reference: Password Policy](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#password-policy).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Directory#getPasswordPolicy Directory.getPasswordPolicy()}.\n *\n * @augments {InstanceResource}\n *\n * @param {Object} passwordPolicyResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction PasswordPolicy() {\n  PasswordPolicy.super_.apply(this, arguments);\n}\n\nutils.inherits(PasswordPolicy, InstanceResource);\n\n/**\n * Get the {@link Strength} resource of this PasswordPolicy resource.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link Strength} resource during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link Strength}).\n */\nPasswordPolicy.prototype.getStrength = function() {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.strength.href, args.options, require('./Strength'), args.callback);\n};\n\nmodule.exports = PasswordPolicy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Phone.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class Phone\n *\n * @description\n *\n * Encapsulates a Phone resource. For full documentation of this resource,\n * please see\n * [REST API Reference: Phone](https://docs.stormpath.com/rest/product-guide/latest/reference.html#ref-phone).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link SmsFactor#getPhone SmsFactor.getPhone()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} phoneResource\n *\n * The JSON representation of this resource.\n */\nfunction Phone() {\n  Phone.super_.apply(this, arguments);\n}\n\nutils.inherits(Phone, InstanceResource);\n\n/**\n* Retrieves the {@link Account} this phone belongs to.\n*\n* @param {ExpansionOptions} [expansionOptions]\n* For retrieving linked resources of the {@link Account} for this request.\n* This resource supports expansions for `customData`, `tenant`, `directory`,\n* `groups`, and `groupMemberships`. Groups and group memberships can also be\n* expanded and paginated.\n*\n* @param {Function} callback\n* The function to call when the operation is complete. Will be called with\n* (err, {@link Account}).\n*/\nPhone.prototype.getAccount = function getPhoneAccount(/* callback */) {\n  var args = utils.resolveArgs(arguments, ['callback'], true);\n  return this.dataStore.getResource(this.account.href, {}, require('./Account'), args.callback);\n};\n\nmodule.exports = Phone;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/ProviderData.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class ProviderData\n *\n * @description\n * Encapsulates a ProviderData resource of a {@link Account}. For full documentation of this resource, please see\n * [REST API Reference: ProviderData](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#provider-data).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Account#getProviderData Account.getProviderData()}.\n *\n * @augments {InstanceResource}\n *\n * @param {Object} providerDataResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction ProviderData() {\n  ProviderData.super_.apply(this, arguments);\n}\n\nutils.inherits(ProviderData, InstanceResource);\n\nmodule.exports = ProviderData;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Provider.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class Provider\n *\n * @description\n * Encapsulates a Provider resource of a {@link Directory}. For full documentation of this resource, please see\n * [REST API Reference: Provider](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#provider).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Directory#getProvider Directory.getProvider()}.\n *\n * @augments {InstanceResource}\n *\n * @param {Object} providerResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction Provider() {\n  Provider.super_.apply(this, arguments);\n}\n\nutils.inherits(Provider, InstanceResource);\n\nmodule.exports = Provider;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/RefreshToken.js":"'use strict';\n\nvar utils = require('../utils');\n\n/**\n * @class RefreshToken\n *\n * @description\n *\n * Encapsulates a Stormpath OAuth Refresh Token Resource. For full documentation\n * of this resource, please see\n * [REST API Reference: Refresh Token](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#password-policy).\n * For a high-level overview of token management, please see\n * {@link https://docs.stormpath.com/rest/product-guide/latest/auth_n.html#introduction-to-token-based-authentication Introduction to Token-Based Authentication}.\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Client#getRefreshToken Client.getRefreshToken()}\n * - {@link Account#getRefreshTokens Account.getRefreshTokens()}\n *\n * To revoke a refresh token, invoke the `delete()` method on an instance of\n * this class.\n *\n * @param {Object} refreshTokenResource\n *\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction RefreshToken() {\n  RefreshToken.super_.apply(this, arguments);\n}\n\nutils.inherits(RefreshToken, require('./InstanceResource'));\n\nmodule.exports = RefreshToken;\n\n/**\n * Deletes this resource from the API.\n *\n * @method RefreshToken.delete\n *\n * @param {Function} callback\n * The function to call when the delete operation is complete. Will be called\n * with the parameter (err).\n */\n\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/SamlAttributeStatementMappingRules.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class SamlAttributeStatementMappingRules\n *\n * @description\n *\n * Encapsulates a AttributeStatementMappingRules resource.\n * For more information about this resource, please see:\n * [REST API Reference: Configure SAML Attribute Mapping](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html#step-7-configure-saml-attribute-mapping-optional).\n *\n * For a high-level overview of SAML Authentication, please see\n * [Authenticating Against a SAML Directory](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#authenticating-against-a-saml-directory).\n *\n * For more information about configuring SAML Authentication, please see\n * [Configuring SAML via REST](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#configuring-saml-via-rest).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link SamlProvider#getAttributeStatementMappingRules SamlProvider.getAttributeStatementMappingRules()}\n *\n * @param {Object} attributeStatementMappingRules\n *\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n *\n */\nfunction SamlAttributeStatementMappingRules() {\n  SamlAttributeStatementMappingRules.super_.apply(this, arguments);\n}\n\nutils.inherits(SamlAttributeStatementMappingRules, InstanceResource);\n\nmodule.exports = SamlAttributeStatementMappingRules;\n\n/**\n * @method SamlAttributeStatementMappingRules.save\n *\n * @description\n *\n * Save changes to this resource.\n *\n * @param {Function} callback\n * The function to call when the save operation is complete. Will be called\n * with the parameters (err, updatedResource).\n */","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/SamlPolicy.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class SamlPolicy\n *\n * @description\n *\n * Encapsulates the SAML Policy of an {@link Application}. For full documentation\n * of the this resource, please see\n * [REST API Reference: SAML Policy Resource](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#saml-policy-resource).\n *\n * For a high-level overview of SAML Authentication, please see\n * [Authenticating Against a SAML Directory](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#authenticating-against-a-saml-directory).\n *\n * For more information about configuring SAML Authentication, please see\n * [Configuring SAML via REST](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#configuring-saml-via-rest).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Application#getSamlPolicy Application.getSamlPolicy()}\n *\n * @param {Object} samlPolicyResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n *\n */\nfunction SamlPolicy() {\n  SamlPolicy.super_.apply(this, arguments);\n}\n\nutils.inherits(SamlPolicy, InstanceResource);\n\n/**\n * Get the {@link SamlServiceProvider} resource of this SAML Policy resource.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link SamlServiceProvider} resource during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link SamlServiceProvider samlServiceProvider}).\n */\nSamlPolicy.prototype.getServiceProvider = function getServiceProvider(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.serviceProvider.href, args.options, require('./SamlServiceProvider'), args.callback);\n};\n\nmodule.exports = SamlPolicy;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/SamlProvider.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class SamlProvider\n *\n * @description\n *\n * Encapsulates a SamlProvider resource, which is a type of {@link Provider}.\n * For full documentation of the Provider resource, please see\n * [REST API Reference: Provider](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#provider).\n *\n * For a high-level overview of SAML Authentication, please see\n * [Authenticating Against a SAML Directory](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#authenticating-against-a-saml-directory).\n *\n * For more information about configuring SAML Authentication, please see\n * [Configuring SAML via REST](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#configuring-saml-via-rest).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link Directory#getProvider Directory.getProvider()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} samlProviderResource\n *\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n *\n */\nfunction SamlProvider() {\n  SamlProvider.super_.apply(this, arguments);\n}\n\nutils.inherits(SamlProvider, InstanceResource);\n\n/**\n * Get the {@link SamlAttributeStatementMappingRules} resource of this SamlProvider resouce.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link SamlAttributeStatementMappingRules} resource during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link SamlAttributeStatementMappingRules samlServiceProviderMetadata}).\n */\nSamlProvider.prototype.getAttributeStatementMappingRules = function getAttributeStatementMappingRules(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.attributeStatementMappingRules.href, args.options, require('./SamlAttributeStatementMappingRules'), args.callback);\n};\n\n/**\n * Get the {@link SamlServiceProviderMetadata} resource of this SamlProvider resouce.\n *\n * @param {ExpansionOptions} [expansionOptions]\n * For retrieving linked resources of the {@link SamlServiceProviderMetadata} resource during this request.\n *\n * @param {Function} callback\n * Callback function, will be called with (err, {@link SamlServiceProviderMetadata samlServiceProviderMetadata}).\n */\nSamlProvider.prototype.getServiceProviderMetadata = function getServiceProviderMetadata(/* [options,] callback */) {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.serviceProviderMetadata.href, args.options, require('./SamlServiceProviderMetadata'), args.callback);\n};\n\nmodule.exports = SamlProvider;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/SamlServiceProvider.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class SamlServiceProvider\n *\n * @description\n *\n * Encapsulates the SAML Service Provider of an {@link Application}. For full\n * documentation of this resource, please see\n * [REST API Reference: SAML Policy Resource](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#saml-policy-resource).\n *\n * For a high-level overview of SAML Authentication, please see\n * [Authenticating Against a SAML Directory](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#authenticating-against-a-saml-directory).\n *\n * For more information about configuring SAML Authentication, please see\n * [Configuring SAML via REST](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#configuring-saml-via-rest).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link SamlPolicy#getServiceProvider SamlPolicy.getServiceProvider()}\n *\n * @param {Object} samlServiceProviderResource\n *\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction SamlServiceProvider() {\n  SamlServiceProvider.super_.apply(this, arguments);\n}\n\nutils.inherits(SamlServiceProvider, InstanceResource);\n\nmodule.exports = SamlServiceProvider;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/SamlServiceProviderMetadata.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class SamlServiceProviderMetadata\n *\n * @description\n *\n * Encapsulates a SAML Service Provider Metadata Resource. For full\n * documentation of this resource, please see\n * [Retrieve Your Service Provider Metadata](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#step-3-retrieve-your-service-provider-metadata).\n *\n * For a high-level overview of SAML Authentication, please see\n * [Authenticating Against a SAML Directory](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#authenticating-against-a-saml-directory).\n *\n * For more information about configuring SAML Authentication, please see\n * [Configuring SAML via REST](https://docs.stormpath.com/rest/product-guide/latest/auth_n.html?#configuring-saml-via-rest).\n *\n * This class should not be manually constructed. It should be obtained from one\n * of these methods:\n *\n * - {@link SamlProvider#getServiceProviderMetadata SamlProvider.getServiceProviderMetadata()}\n *\n * @param {Object} samlServiceProviderMetadataResource\n *\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction SamlServiceProviderMetadata() {\n  SamlServiceProviderMetadata.super_.apply(this, arguments);\n}\n\nutils.inherits(SamlServiceProviderMetadata, InstanceResource);\n\nmodule.exports = SamlServiceProviderMetadata;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Schema.js":"'use strict';\n\nvar Resource = require('./Resource');\nvar utils = require('../utils');\n\n/**\n * @class Schema\n *\n * @description\n * Encapsulates the Schema resource of a {@link Directory}. This schema allows you\n * to control which Account attributes (referred to as fields) are required when\n * creating new accounts in the directory. For full documentation of this resource, please see\n * [How to Manage an Account’s Required Attributes](https://docs.stormpath.com/rest/product-guide/latest/accnt_mgmt.html#how-to-manage-an-account-s-required-attributes).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Directory#getAccountSchema Directory.getAccountSchema()}.\n *\n * @example <caption>Disabling a field requirement.</caption>\n * var _ = require('lodash');\n *\n * schema.getFields(function (err, fieldsCollection) {\n *   var givenNameField = _.find(fieldsCollection.items, {\n *     name: 'givenName'\n *   });\n *\n *   givenNameField.required = false;\n *\n *   givenNameField.save();\n * });\n */\nfunction Schema() {\n  Schema.super_.apply(this, arguments);\n}\n\nutils.inherits(Schema, Resource);\n\n/**\n * Get the collection of {@link Field Fields} for this schema.\n *\n * @param {CollectionQueryOptions} [options]\n * Options for querying, paginating, and expanding the collection.\n *\n * @param {Function} callback\n * The function to call when the operation is complete. Will be called\n * with the parameters (err, {@link CollectionResource}). The collection will\n * be a list of {@link Field} objects.\n */\nSchema.prototype.getFields = function () {\n  var args = utils.resolveArgs(arguments, ['options', 'callback'], true);\n  return this.dataStore.getResource(this.fields.href, args.options, require('./Field'), args.callback);\n};\n\nmodule.exports = Schema;","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/SmtpServer.js":"'use strict';\n\nvar utils = require('../utils');\nvar InstanceResource = require('./InstanceResource');\n\n/**\n * @class SmtpServer\n *\n * @description\n * Encapsulates a SmtpServer resource. For full documentation of this resource, please see\n * [REST API Reference: SMTP Server](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#smtp-server).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link Client#getSmtpServers Client.getSmtpServers()}\n * - {@link Tenant#getSmtpServers Tenant.getSmtpServers()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} smtpServerResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction SmtpServer() {\n  SmtpServer.super_.apply(this, arguments);\n}\n\nutils.inherits(SmtpServer, InstanceResource);\n\nmodule.exports = SmtpServer;\n","/home/travis/build/npmtest/node-npmtest-stormpath/node_modules/stormpath/lib/resource/Strength.js":"'use strict';\n\nvar InstanceResource = require('./InstanceResource');\nvar utils = require('../utils');\n\n/**\n * @class Strength\n *\n * @description\n * Encapsulates a Password Strength resource of a {@link PasswordPolicy}. For full documentation of the this resource, please see\n * [REST API Reference: Password Strength](https://docs.stormpath.com/rest/product-guide/latest/reference.html?#password-strength).\n *\n * This class should not be manually constructed. It should be obtained from one of these methods:\n * - {@link PasswordPolicy#getStrength PasswordPolicy.getStrength()}\n *\n * @augments {InstanceResource}\n *\n * @param {Object} passwordStrengthResource\n * The JSON representation of this resource, retrieved the Stormpath REST API.\n */\nfunction Strength() {\n  Strength.super_.apply(this, arguments);\n}\n\nutils.inherits(Strength, InstanceResource);\n\nmodule.exports = Strength;\n"}